{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/labels.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { hasDriveLetter, toSlashes } from \"./extpath.js\";\nimport { posix, sep, win32 } from \"./path.js\";\nimport { OS, OperatingSystem, isMacintosh, isWindows } from \"./platform.js\";\nimport { extUri, extUriIgnorePathCase } from \"./resources.js\";\nimport { rtrim, startsWithIgnoreCase } from \"./strings.js\";\nimport type { URI } from \"./uri.js\";\n\nexport interface IPathLabelFormatting {\n\t/**\n\t * The OS the path label is from to produce a label\n\t * that matches OS expectations.\n\t */\n\treadonly os: OperatingSystem;\n\n\t/**\n\t * Whether to add a `~` when the path is in the\n\t * user home directory.\n\t *\n\t * Note: this only applies to Linux, macOS but not\n\t * Windows.\n\t */\n\treadonly tildify?: IUserHomeProvider;\n\n\t/**\n\t * Whether to convert to a relative path if the path\n\t * is within any of the opened workspace folders.\n\t */\n\treadonly relative?: IRelativePathProvider;\n}\n\nexport interface IRelativePathProvider {\n\t/**\n\t * Whether to not add a prefix when in multi-root workspace.\n\t */\n\treadonly noPrefix?: boolean;\n\n\tgetWorkspace(): { folders: { uri: URI; name?: string }[] };\n\tgetWorkspaceFolder(resource: URI): { uri: URI; name?: string } | null;\n}\n\nexport interface IUserHomeProvider {\n\tuserHome: URI;\n}\n\nexport function getPathLabel(\n\tresource: URI,\n\tformatting: IPathLabelFormatting,\n): string {\n\tconst { os, tildify: tildifier, relative: relatifier } = formatting;\n\n\t// return early with a relative path if we can resolve one\n\tif (relatifier) {\n\t\tconst relativePath = getRelativePathLabel(resource, relatifier, os);\n\t\tif (typeof relativePath === \"string\") {\n\t\t\treturn relativePath;\n\t\t}\n\t}\n\n\t// otherwise try to resolve a absolute path label and\n\t// apply target OS standard path separators if target\n\t// OS differs from actual OS we are running in\n\tlet absolutePath = resource.fsPath;\n\tif (os === OperatingSystem.Windows && !isWindows) {\n\t\tabsolutePath = absolutePath.replace(/\\//g, \"\\\\\");\n\t} else if (os !== OperatingSystem.Windows && isWindows) {\n\t\tabsolutePath = absolutePath.replace(/\\\\/g, \"/\");\n\t}\n\n\t// macOS/Linux: tildify with provided user home directory\n\tif (os !== OperatingSystem.Windows && tildifier?.userHome) {\n\t\tconst userHome = tildifier.userHome.fsPath;\n\n\t\t// This is a bit of a hack, but in order to figure out if the\n\t\t// resource is in the user home, we need to make sure to convert it\n\t\t// to a user home resource. We cannot assume that the resource is\n\t\t// already a user home resource.\n\t\tlet userHomeCandidate: string;\n\t\tif (\n\t\t\tresource.scheme !== tildifier.userHome.scheme &&\n\t\t\tresource.path[0] === posix.sep &&\n\t\t\tresource.path[1] !== posix.sep\n\t\t) {\n\t\t\tuserHomeCandidate = tildifier.userHome.with({\n\t\t\t\tpath: resource.path,\n\t\t\t}).fsPath;\n\t\t} else {\n\t\t\tuserHomeCandidate = absolutePath;\n\t\t}\n\n\t\tabsolutePath = tildify(userHomeCandidate, userHome, os);\n\t}\n\n\t// normalize\n\tconst pathLib = os === OperatingSystem.Windows ? win32 : posix;\n\treturn pathLib.normalize(\n\t\tnormalizeDriveLetter(absolutePath, os === OperatingSystem.Windows),\n\t);\n}\n\nfunction getRelativePathLabel(\n\tresource: URI,\n\trelativePathProvider: IRelativePathProvider,\n\tos: OperatingSystem,\n): string | undefined {\n\tconst pathLib = os === OperatingSystem.Windows ? win32 : posix;\n\tconst extUriLib =\n\t\tos === OperatingSystem.Linux ? extUri : extUriIgnorePathCase;\n\n\tconst workspace = relativePathProvider.getWorkspace();\n\tconst firstFolder = workspace.folders.at(0);\n\tif (!firstFolder) {\n\t\treturn undefined;\n\t}\n\n\t// This is a bit of a hack, but in order to figure out the folder\n\t// the resource belongs to, we need to make sure to convert it\n\t// to a workspace resource. We cannot assume that the resource is\n\t// already matching the workspace.\n\tif (\n\t\tresource.scheme !== firstFolder.uri.scheme &&\n\t\tresource.path[0] === posix.sep &&\n\t\tresource.path[1] !== posix.sep\n\t) {\n\t\tresource = firstFolder.uri.with({ path: resource.path });\n\t}\n\n\tconst folder = relativePathProvider.getWorkspaceFolder(resource);\n\tif (!folder) {\n\t\treturn undefined;\n\t}\n\n\tlet relativePathLabel: string | undefined;\n\tif (extUriLib.isEqual(folder.uri, resource)) {\n\t\trelativePathLabel = \"\"; // no label if paths are identical\n\t} else {\n\t\trelativePathLabel = extUriLib.relativePath(folder.uri, resource) ?? \"\";\n\t}\n\n\t// normalize\n\tif (relativePathLabel) {\n\t\trelativePathLabel = pathLib.normalize(relativePathLabel);\n\t}\n\n\t// always show root basename if there are multiple folders\n\tif (workspace.folders.length > 1 && !relativePathProvider.noPrefix) {\n\t\tconst rootName = folder.name\n\t\t\t? folder.name\n\t\t\t: extUriLib.basenameOrAuthority(folder.uri);\n\t\trelativePathLabel = relativePathLabel\n\t\t\t? `${rootName} \u2022 ${relativePathLabel}`\n\t\t\t: rootName;\n\t}\n\n\treturn relativePathLabel;\n}\n\nexport function normalizeDriveLetter(\n\tpath: string,\n\tisWindowsOS: boolean = isWindows,\n): string {\n\tif (hasDriveLetter(path, isWindowsOS)) {\n\t\treturn path.charAt(0).toUpperCase() + path.slice(1);\n\t}\n\n\treturn path;\n}\n\nlet normalizedUserHomeCached: { original: string; normalized: string } =\n\tObject.create(null);\nexport function tildify(path: string, userHome: string, os = OS): string {\n\tif (os === OperatingSystem.Windows || !path || !userHome) {\n\t\treturn path; // unsupported on Windows\n\t}\n\n\tlet normalizedUserHome =\n\t\tnormalizedUserHomeCached.original === userHome\n\t\t\t? normalizedUserHomeCached.normalized\n\t\t\t: undefined;\n\tif (!normalizedUserHome) {\n\t\tnormalizedUserHome = userHome;\n\t\tif (isWindows) {\n\t\t\tnormalizedUserHome = toSlashes(normalizedUserHome); // make sure that the path is POSIX normalized on Windows\n\t\t}\n\t\tnormalizedUserHome = `${rtrim(normalizedUserHome, posix.sep)}${posix.sep}`;\n\t\tnormalizedUserHomeCached = {\n\t\t\toriginal: userHome,\n\t\t\tnormalized: normalizedUserHome,\n\t\t};\n\t}\n\n\tlet normalizedPath = path;\n\tif (isWindows) {\n\t\tnormalizedPath = toSlashes(normalizedPath); // make sure that the path is POSIX normalized on Windows\n\t}\n\n\t// Linux: case sensitive, macOS: case insensitive\n\tif (\n\t\tos === OperatingSystem.Linux\n\t\t\t? normalizedPath.startsWith(normalizedUserHome)\n\t\t\t: startsWithIgnoreCase(normalizedPath, normalizedUserHome)\n\t) {\n\t\treturn `~/${normalizedPath.substr(normalizedUserHome.length)}`;\n\t}\n\n\treturn path;\n}\n\nexport function untildify(path: string, userHome: string): string {\n\treturn path.replace(/^~($|\\/|\\\\)/, `${userHome}$1`);\n}\n\n/**\n * Shortens the paths but keeps them easy to distinguish.\n * Replaces not important parts with ellipsis.\n * Every shorten path matches only one original path and vice versa.\n *\n * Algorithm for shortening paths is as follows:\n * 1. For every path in list, find unique substring of that path.\n * 2. Unique substring along with ellipsis is shortened path of that path.\n * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string\n *    and if present segment is not substring to any other paths then present segment is unique path,\n *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,\n *    if it is true take present segment as unique path.\n * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.\n *\n * Example 1\n * 1. consider 2 paths i.e. ['a\\\\b\\\\c\\\\d', 'a\\\\f\\\\b\\\\c\\\\d']\n * 2. find unique path of first path,\n * \ta. 'd' is present in path2 and is suffix of path2, hence not unique of present path.\n * \tb. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.\n * \tc. 'd\\\\c' is suffix of path2.\n *  d. 'b\\\\c' is not suffix of present path.\n *  e. 'a\\\\b' is not present in path2, hence unique path is 'a\\\\b...'.\n * 3. for path2, 'f' is not present in path1 hence unique is '...\\\\f\\\\...'.\n *\n * Example 2\n * 1. consider 2 paths i.e. ['a\\\\b', 'a\\\\b\\\\c'].\n * \ta. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\\\b'.\n * 2. for path2, 'c' is not present in path1 hence unique path is '..\\\\c'.\n */\nconst ellipsis = \"\\u2026\";\nconst unc = \"\\\\\\\\\";\nconst home = \"~\";\nexport function shorten(\n\tpaths: string[],\n\tpathSeparator: string = sep,\n): string[] {\n\tconst shortenedPaths: string[] = new Array(paths.length);\n\n\t// for every path\n\tlet match = false;\n\tfor (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {\n\t\tconst originalPath = paths[pathIndex];\n\n\t\tif (originalPath === \"\") {\n\t\t\tshortenedPaths[pathIndex] = `.${pathSeparator}`;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!originalPath) {\n\t\t\tshortenedPaths[pathIndex] = originalPath;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch = true;\n\n\t\t// trim for now and concatenate unc path (e.g. \\\\network) or root path (/etc, ~/etc) later\n\t\tlet prefix = \"\";\n\t\tlet trimmedPath = originalPath;\n\t\tif (trimmedPath.indexOf(unc) === 0) {\n\t\t\tprefix = trimmedPath.substr(\n\t\t\t\t0,\n\t\t\t\ttrimmedPath.indexOf(unc) + unc.length,\n\t\t\t);\n\t\t\ttrimmedPath = trimmedPath.substr(\n\t\t\t\ttrimmedPath.indexOf(unc) + unc.length,\n\t\t\t);\n\t\t} else if (trimmedPath.indexOf(pathSeparator) === 0) {\n\t\t\tprefix = trimmedPath.substr(\n\t\t\t\t0,\n\t\t\t\ttrimmedPath.indexOf(pathSeparator) + pathSeparator.length,\n\t\t\t);\n\t\t\ttrimmedPath = trimmedPath.substr(\n\t\t\t\ttrimmedPath.indexOf(pathSeparator) + pathSeparator.length,\n\t\t\t);\n\t\t} else if (trimmedPath.indexOf(home) === 0) {\n\t\t\tprefix = trimmedPath.substr(\n\t\t\t\t0,\n\t\t\t\ttrimmedPath.indexOf(home) + home.length,\n\t\t\t);\n\t\t\ttrimmedPath = trimmedPath.substr(\n\t\t\t\ttrimmedPath.indexOf(home) + home.length,\n\t\t\t);\n\t\t}\n\n\t\t// pick the first shortest subpath found\n\t\tconst segments: string[] = trimmedPath.split(pathSeparator);\n\t\tfor (\n\t\t\tlet subpathLength = 1;\n\t\t\tmatch && subpathLength <= segments.length;\n\t\t\tsubpathLength++\n\t\t) {\n\t\t\tfor (\n\t\t\t\tlet start = segments.length - subpathLength;\n\t\t\t\tmatch && start >= 0;\n\t\t\t\tstart--\n\t\t\t) {\n\t\t\t\tmatch = false;\n\t\t\t\tlet subpath = segments\n\t\t\t\t\t.slice(start, start + subpathLength)\n\t\t\t\t\t.join(pathSeparator);\n\n\t\t\t\t// that is unique to any other path\n\t\t\t\tfor (\n\t\t\t\t\tlet otherPathIndex = 0;\n\t\t\t\t\t!match && otherPathIndex < paths.length;\n\t\t\t\t\totherPathIndex++\n\t\t\t\t) {\n\t\t\t\t\t// suffix subpath treated specially as we consider no match 'x' and 'x/...'\n\t\t\t\t\tif (\n\t\t\t\t\t\totherPathIndex !== pathIndex &&\n\t\t\t\t\t\tpaths[otherPathIndex] &&\n\t\t\t\t\t\tpaths[otherPathIndex].indexOf(subpath) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst isSubpathEnding: boolean =\n\t\t\t\t\t\t\tstart + subpathLength === segments.length;\n\n\t\t\t\t\t\t// Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.\n\t\t\t\t\t\t// prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.\n\t\t\t\t\t\tconst subpathWithSep: string =\n\t\t\t\t\t\t\tstart > 0 &&\n\t\t\t\t\t\t\tpaths[otherPathIndex].indexOf(pathSeparator) > -1\n\t\t\t\t\t\t\t\t? pathSeparator + subpath\n\t\t\t\t\t\t\t\t: subpath;\n\t\t\t\t\t\tconst isOtherPathEnding: boolean =\n\t\t\t\t\t\t\tpaths[otherPathIndex].endsWith(subpathWithSep);\n\n\t\t\t\t\t\tmatch = !isSubpathEnding || isOtherPathEnding;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// found unique subpath\n\t\t\t\tif (!match) {\n\t\t\t\t\tlet result = \"\";\n\n\t\t\t\t\t// preserve disk drive or root prefix\n\t\t\t\t\tif (segments[0].endsWith(\":\") || prefix !== \"\") {\n\t\t\t\t\t\tif (start === 1) {\n\t\t\t\t\t\t\t// extend subpath to include disk drive prefix\n\t\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t\t\tsubpathLength++;\n\t\t\t\t\t\t\tsubpath = segments[0] + pathSeparator + subpath;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\t\tresult = segments[0] + pathSeparator;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult = prefix + result;\n\t\t\t\t\t}\n\n\t\t\t\t\t// add ellipsis at the beginning if needed\n\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\tresult = result + ellipsis + pathSeparator;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = result + subpath;\n\n\t\t\t\t\t// add ellipsis at the end if needed\n\t\t\t\t\tif (start + subpathLength < segments.length) {\n\t\t\t\t\t\tresult = result + pathSeparator + ellipsis;\n\t\t\t\t\t}\n\n\t\t\t\t\tshortenedPaths[pathIndex] = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match) {\n\t\t\tshortenedPaths[pathIndex] = originalPath; // use original path if no unique subpaths found\n\t\t}\n\t}\n\n\treturn shortenedPaths;\n}\n\nexport interface ISeparator {\n\tlabel: string;\n}\n\nenum Type {\n\tTEXT = 0,\n\tVARIABLE = 1,\n\tSEPARATOR = 2,\n}\n\ninterface ISegment {\n\tvalue: string;\n\ttype: Type;\n}\n\n/**\n * Helper to insert values for specific template variables into the string. E.g. \"this $(is) a $(template)\" can be\n * passed to this function together with an object that maps \"is\" and \"template\" to strings to have them replaced.\n * @param value string to which template is applied\n * @param values the values of the templates to use\n */\nexport function template(\n\ttemplate: string,\n\tvalues: {\n\t\t[key: string]: string | ISeparator | undefined | null;\n\t} = Object.create(null),\n): string {\n\tconst segments: ISegment[] = [];\n\n\tlet inVariable = false;\n\tlet curVal = \"\";\n\tfor (const char of template) {\n\t\t// Beginning of variable\n\t\tif (char === \"$\" || (inVariable && char === \"{\")) {\n\t\t\tif (curVal) {\n\t\t\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t\t\t}\n\n\t\t\tcurVal = \"\";\n\t\t\tinVariable = true;\n\t\t}\n\n\t\t// End of variable\n\t\telse if (char === \"}\" && inVariable) {\n\t\t\tconst resolved = values[curVal];\n\n\t\t\t// Variable\n\t\t\tif (typeof resolved === \"string\") {\n\t\t\t\tif (resolved.length) {\n\t\t\t\t\tsegments.push({ value: resolved, type: Type.VARIABLE });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Separator\n\t\t\telse if (resolved) {\n\t\t\t\tconst prevSegment = segments[segments.length - 1];\n\t\t\t\tif (!prevSegment || prevSegment.type !== Type.SEPARATOR) {\n\t\t\t\t\tsegments.push({\n\t\t\t\t\t\tvalue: resolved.label,\n\t\t\t\t\t\ttype: Type.SEPARATOR,\n\t\t\t\t\t}); // prevent duplicate separators\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurVal = \"\";\n\t\t\tinVariable = false;\n\t\t}\n\n\t\t// Text or Variable Name\n\t\telse {\n\t\t\tcurVal += char;\n\t\t}\n\t}\n\n\t// Tail\n\tif (curVal && !inVariable) {\n\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t}\n\n\treturn segments\n\t\t.filter((segment, index) => {\n\t\t\t// Only keep separator if we have values to the left and right\n\t\t\tif (segment.type === Type.SEPARATOR) {\n\t\t\t\tconst left = segments[index - 1];\n\t\t\t\tconst right = segments[index + 1];\n\n\t\t\t\treturn [left, right].every(\n\t\t\t\t\t(segment) =>\n\t\t\t\t\t\tsegment &&\n\t\t\t\t\t\t(segment.type === Type.VARIABLE ||\n\t\t\t\t\t\t\tsegment.type === Type.TEXT) &&\n\t\t\t\t\t\tsegment.value.length > 0,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// accept any TEXT and VARIABLE\n\t\t\treturn true;\n\t\t})\n\t\t.map((segment) => segment.value)\n\t\t.join(\"\");\n}\n\n/**\n * Handles mnemonics for menu items. Depending on OS:\n * - Windows: Supported via & character (replace && with &)\n * -   Linux: Supported via & character (replace && with &)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicMenuLabel(\n\tlabel: string,\n\tforceDisableMnemonics?: boolean,\n): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label\n\t\t\t.replace(/\\(&&\\w\\)|&&/g, \"\")\n\t\t\t.replace(/&/g, isMacintosh ? \"&\" : \"&&\");\n\t}\n\n\treturn label.replace(/&&|&/g, (m) => (m === \"&\" ? \"&&\" : \"&\"));\n}\n\n/**\n * Handles mnemonics for buttons. Depending on OS:\n * - Windows: Supported via & character (replace && with & and & with && for escaping)\n * -   Linux: Supported via _ character (replace && with _)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicButtonLabel(\n\tlabel: string,\n\tforceDisableMnemonics?: boolean,\n): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, \"\");\n\t}\n\n\tif (isWindows) {\n\t\treturn label.replace(/&&|&/g, (m) => (m === \"&\" ? \"&&\" : \"&\"));\n\t}\n\n\treturn label.replace(/&&/g, \"_\");\n}\n\nexport function unmnemonicLabel(label: string): string {\n\treturn label.replace(/&/g, \"&&\");\n}\n\n/**\n * Splits a recent label in name and parent path, supporting both '/' and '\\' and workspace suffixes.\n * If the location is remote, the remote name is included in the name part.\n */\nexport function splitRecentLabel(recentLabel: string): {\n\tname: string;\n\tparentPath: string;\n} {\n\tif (recentLabel.endsWith(\"]\")) {\n\t\t// label with workspace suffix\n\t\tconst lastIndexOfSquareBracket = recentLabel.lastIndexOf(\n\t\t\t\" [\",\n\t\t\trecentLabel.length - 2,\n\t\t);\n\t\tif (lastIndexOfSquareBracket !== -1) {\n\t\t\tconst split = splitName(\n\t\t\t\trecentLabel.substring(0, lastIndexOfSquareBracket),\n\t\t\t);\n\t\t\tconst remoteNameWithSpace = recentLabel.substring(\n\t\t\t\tlastIndexOfSquareBracket,\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tname: split.name + remoteNameWithSpace,\n\t\t\t\tparentPath: split.parentPath,\n\t\t\t};\n\t\t}\n\t}\n\treturn splitName(recentLabel);\n}\n\nfunction splitName(fullPath: string): { name: string; parentPath: string } {\n\tconst p = fullPath.indexOf(\"/\") !== -1 ? posix : win32;\n\tconst name = p.basename(fullPath);\n\tconst parentPath = p.dirname(fullPath);\n\tif (name.length) {\n\t\treturn { name, parentPath };\n\t}\n\t// only the root segment\n\treturn { name: parentPath, parentPath: \"\" };\n}\n"],
  "mappings": "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",
  "names": ["Type", "template", "segment"]
}
