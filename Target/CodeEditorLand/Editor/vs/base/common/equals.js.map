{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/equals.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from './arrays.js';\n\nexport type EqualityComparer<T> = (a: T, b: T) => boolean;\n\n/**\n * Compares two items for equality using strict equality.\n*/\nexport const strictEquals: EqualityComparer<any> = (a, b) => a === b;\n\n/**\n * Checks if the items of two arrays are equal.\n * By default, strict equality is used to compare elements, but a custom equality comparer can be provided.\n */\nexport function itemsEquals<T>(itemEquals: EqualityComparer<T> = strictEquals): EqualityComparer<readonly T[]> {\n\treturn (a, b) => arrays.equals(a, b, itemEquals);\n}\n\n/**\n * Two items are considered equal, if their stringified representations are equal.\n*/\nexport function jsonStringifyEquals<T>(): EqualityComparer<T> {\n\treturn (a, b) => JSON.stringify(a) === JSON.stringify(b);\n}\n\n/**\n * Uses `item.equals(other)` to determine equality.\n */\nexport function itemEquals<T extends { equals(other: T): boolean }>(): EqualityComparer<T> {\n\treturn (a, b) => a.equals(b);\n}\n\n/**\n * Checks if two items are both null or undefined, or are equal according to the provided equality comparer.\n*/\nexport function equalsIfDefined<T>(v1: T | undefined | null, v2: T | undefined | null, equals: EqualityComparer<T>): boolean;\n/**\n * Returns an equality comparer that checks if two items are both null or undefined, or are equal according to the provided equality comparer.\n*/\nexport function equalsIfDefined<T>(equals: EqualityComparer<T>): EqualityComparer<T | undefined | null>;\nexport function equalsIfDefined<T>(equalsOrV1: EqualityComparer<T> | T, v2?: T | undefined | null, equals?: EqualityComparer<T>): EqualityComparer<T | undefined | null> | boolean {\n\tif (equals !== undefined) {\n\t\tconst v1 = equalsOrV1 as T | undefined;\n\t\tif (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n\t\t\treturn v2 === v1;\n\t\t}\n\t\treturn equals(v1, v2);\n\t} else {\n\t\tconst equals = equalsOrV1 as EqualityComparer<T>;\n\t\treturn (v1, v2) => {\n\t\t\tif (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n\t\t\t\treturn v2 === v1;\n\t\t\t}\n\t\t\treturn equals(v1, v2);\n\t\t};\n\t}\n}\n\n/**\n * Drills into arrays (items ordered) and objects (keys unordered) and uses strict equality on everything else.\n*/\nexport function structuralEquals<T>(a: T, b: T): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tif (!structuralEquals(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (a && typeof a === 'object' && b && typeof b === 'object') {\n\t\tif (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {\n\t\t\tconst aObj = a as Record<string, unknown>;\n\t\t\tconst bObj = b as Record<string, unknown>;\n\t\t\tconst keysA = Object.keys(aObj);\n\t\t\tconst keysB = Object.keys(bObj);\n\t\t\tconst keysBSet = new Set(keysB);\n\n\t\t\tif (keysA.length !== keysB.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (const key of keysA) {\n\t\t\t\tif (!keysBSet.has(key)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!structuralEquals(aObj[key], bObj[key])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * `getStructuralKey(a) === getStructuralKey(b) <=> structuralEquals(a, b)`\n * (assuming that a and b are not cyclic structures and nothing extends globalThis Array).\n*/\nexport function getStructuralKey(t: unknown): string {\n\treturn JSON.stringify(toNormalizedJsonStructure(t));\n}\n\nlet objectId = 0;\nconst objIds = new WeakMap<object, number>();\n\nfunction toNormalizedJsonStructure(t: unknown): unknown {\n\tif (Array.isArray(t)) {\n\t\treturn t.map(toNormalizedJsonStructure);\n\t}\n\n\tif (t && typeof t === 'object') {\n\t\tif (Object.getPrototypeOf(t) === Object.prototype) {\n\t\t\tconst tObj = t as Record<string, unknown>;\n\t\t\tconst res: Record<string, unknown> = Object.create(null);\n\t\t\tfor (const key of Object.keys(tObj).sort()) {\n\t\t\t\tres[key] = toNormalizedJsonStructure(tObj[key]);\n\t\t\t}\n\t\t\treturn res;\n\t\t} else {\n\t\t\tlet objId = objIds.get(t);\n\t\t\tif (objId === undefined) {\n\t\t\t\tobjId = objectId++;\n\t\t\t\tobjIds.set(t, objId);\n\t\t\t}\n\t\t\t// Random string to prevent collisions\n\t\t\treturn objId + '----2b76a038c20c4bcc';\n\t\t}\n\t}\n\treturn t;\n}\n"],
  "mappings": "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",
  "names": ["itemEquals", "equals", "v2"]
}
