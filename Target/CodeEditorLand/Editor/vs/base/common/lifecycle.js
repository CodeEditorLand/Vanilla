import{compareBy as A,numberComparator as S}from"./arrays.js";import{groupBy as j}from"./collections.js";import{createSingleCallFunction as m}from"./functional.js";import{Iterable as P}from"./iterator.js";import{SetMap as R}from"./map.js";const E=!1;let p=null;class y{static idx=0;livingDisposables=new Map;getDisposableData(e){let t=this.livingDisposables.get(e);return t||(t={parent:null,source:null,isSingleton:!1,value:e,idx:y.idx++},this.livingDisposables.set(e,t)),t}trackDisposable(e){const t=this.getDisposableData(e);t.source||(t.source=new Error().stack)}setParent(e,t){const i=this.getDisposableData(e);i.parent=t}markAsDisposed(e){this.livingDisposables.delete(e)}markAsSingleton(e){this.getDisposableData(e).isSingleton=!0}getRootParent(e,t){const i=t.get(e);if(i)return i;const a=e.parent?this.getRootParent(this.getDisposableData(e.parent),t):e;return t.set(e,a),a}getTrackedDisposables(){const e=new Map;return[...this.livingDisposables.entries()].filter(([,i])=>i.source!==null&&!this.getRootParent(i,e).isSingleton).flatMap(([i])=>i)}computeLeakingDisposables(e=10,t){let i;if(t)i=t;else{const l=new Map,n=[...this.livingDisposables.values()].filter(o=>o.source!==null&&!this.getRootParent(o,l).isSingleton);if(n.length===0)return;const r=new Set(n.map(o=>o.value));if(i=n.filter(o=>!(o.parent&&r.has(o.parent))),i.length===0)throw new Error("There are cyclic diposable chains!")}if(!i)return;function a(l){function n(o,u){for(;o.length>0&&u.some(h=>typeof h=="string"?h===o[0]:o[0].match(h));)o.shift()}const r=l.source.split(`
`).map(o=>o.trim().replace("at ","")).filter(o=>o!=="");return n(r,["Error",/^trackDisposable \(.*\)$/,/^DisposableTracker.trackDisposable \(.*\)$/]),r.reverse()}const b=new R;for(const l of i){const n=a(l);for(let r=0;r<=n.length;r++)b.add(n.slice(0,r).join(`
`),l)}i.sort(A(l=>l.idx,S));let v="",g=0;for(const l of i.slice(0,e)){g++;const n=a(l),r=[];for(let o=0;o<n.length;o++){let u=n[o];u=`(shared with ${b.get(n.slice(0,o+1).join(`
`)).size}/${i.length} leaks) at ${u}`;const x=b.get(n.slice(0,o).join(`
`)),_=j([...x].map(f=>a(f)[o]),f=>f);delete _[n[o]];for(const[f,w]of Object.entries(_))r.unshift(`    - stacktraces of ${w.length} other leaks continue with ${f}`);r.unshift(u)}v+=`


==================== Leaking disposable ${g}/${i.length}: ${l.value.constructor.name} ====================
${r.join(`
`)}
============================================================

`}return i.length>e&&(v+=`


... and ${i.length-e} more leaking disposables

`),{leaks:i,details:v}}}function O(s){p=s}if(E){const s="__is_disposable_tracked__";O(new class{trackDisposable(e){const t=new Error("Potentially leaked disposable").stack;setTimeout(()=>{e[s]},3e3)}setParent(e,t){if(e&&e!==k.None)try{e[s]=!0}catch{}}markAsDisposed(e){if(e&&e!==k.None)try{e[s]=!0}catch{}}markAsSingleton(e){}})}function c(s){return p?.trackDisposable(s),s}function d(s){p?.markAsDisposed(s)}function D(s,e){p?.setParent(s,e)}function M(s,e){if(p)for(const t of s)p.setParent(t,e)}function q(s){return p?.markAsSingleton(s),s}function C(s){return typeof s=="object"&&s!==null&&typeof s.dispose=="function"&&s.dispose.length===0}function T(s){if(P.is(s)){const e=[];for(const t of s)if(t)try{t.dispose()}catch(i){e.push(i)}if(e.length===1)throw e[0];if(e.length>1)throw new AggregateError(e,"Encountered errors while disposing of store");return Array.isArray(s)?[]:s}else if(s)return s.dispose(),s}function F(s){for(const e of s)C(e)&&e.dispose();return[]}function G(...s){const e=$(()=>T(s));return M(s,e),e}function $(s){const e=c({dispose:m(()=>{d(e),s()})});return e}class I{static DISABLE_DISPOSED_WARNING=!1;_toDispose=new Set;_isDisposed=!1;constructor(){c(this)}dispose(){this._isDisposed||(d(this),this._isDisposed=!0,this.clear())}get isDisposed(){return this._isDisposed}clear(){if(this._toDispose.size!==0)try{T(this._toDispose)}finally{this._toDispose.clear()}}add(e){if(!e)return e;if(e===this)throw new Error("Cannot register a disposable on itself!");return D(e,this),this._isDisposed?I.DISABLE_DISPOSED_WARNING:this._toDispose.add(e),e}delete(e){if(e){if(e===this)throw new Error("Cannot dispose a disposable on itself!");this._toDispose.delete(e),e.dispose()}}deleteAndLeak(e){e&&this._toDispose.has(e)&&(this._toDispose.delete(e),D(e,null))}}class k{static None=Object.freeze({dispose(){}});_store=new I;constructor(){c(this),D(this._store,this)}dispose(){d(this),this._store.dispose()}_register(e){if(e===this)throw new Error("Cannot register a disposable on itself!");return this._store.add(e)}}class K{_value;_isDisposed=!1;constructor(){c(this)}get value(){return this._isDisposed?void 0:this._value}set value(e){this._isDisposed||e===this._value||(this._value?.dispose(),e&&D(e,this),this._value=e)}clear(){this.value=void 0}dispose(){this._isDisposed=!0,d(this),this._value?.dispose(),this._value=void 0}clearAndLeak(){const e=this._value;return this._value=void 0,e&&D(e,null),e}}class W{_disposable=new K;_isDisposed=!1;constructor(e){this._disposable.value=e}get value(){return this._disposable.value}set value(e){this._isDisposed||e===this._disposable.value||(this._disposable.value=e)}dispose(){this._isDisposed=!0,this._disposable.dispose()}}class H{constructor(e){this._disposable=e}_counter=1;acquire(){return this._counter++,this}release(){return--this._counter===0&&this._disposable.dispose(),this}}class J{dispose=()=>{};unset=()=>{};isset=()=>!1;constructor(){c(this)}set(e){let t=e;return this.unset=()=>t=void 0,this.isset=()=>t!==void 0,this.dispose=()=>{t&&(t(),t=void 0,d(this))},this}}class Q{references=new Map;acquire(e,...t){let i=this.references.get(e);i||(i={counter:0,object:this.createReferencedObject(e,...t)},this.references.set(e,i));const{object:a}=i,b=m(()=>{--i.counter===0&&(this.destroyReferencedObject(e,i.object),this.references.delete(e))});return i.counter++,{object:a,dispose:b}}}class U{constructor(e){this.referenceCollection=e}async acquire(e,...t){const i=this.referenceCollection.acquire(e,...t);try{return{object:await i.object,dispose:()=>i.dispose()}}catch(a){throw i.dispose(),a}}}class X{constructor(e){this.object=e}dispose(){}}function Y(s){const e=new I;try{s(e)}finally{e.dispose()}}class Z{_store=new Map;_isDisposed=!1;constructor(){c(this)}dispose(){d(this),this._isDisposed=!0,this.clearAndDisposeAll()}clearAndDisposeAll(){if(this._store.size)try{T(this._store.values())}finally{this._store.clear()}}has(e){return this._store.has(e)}get size(){return this._store.size}get(e){return this._store.get(e)}set(e,t,i=!1){this._isDisposed,i||this._store.get(e)?.dispose(),this._store.set(e,t)}deleteAndDispose(e){this._store.get(e)?.dispose(),this._store.delete(e)}deleteAndLeak(e){const t=this._store.get(e);return this._store.delete(e),t}keys(){return this._store.keys()}values(){return this._store.values()}[Symbol.iterator](){return this._store[Symbol.iterator]()}}export{U as AsyncReferenceCollection,k as Disposable,Z as DisposableMap,I as DisposableStore,y as DisposableTracker,X as ImmortalReference,W as MandatoryMutableDisposable,K as MutableDisposable,H as RefCountedDisposable,Q as ReferenceCollection,J as SafeDisposable,G as combinedDisposable,T as dispose,F as disposeIfDisposable,Y as disposeOnReturn,C as isDisposable,d as markAsDisposed,q as markAsSingleton,O as setDisposableTracker,$ as toDisposable,c as trackDisposable};
