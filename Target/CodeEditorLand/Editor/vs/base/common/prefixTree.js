var h;(y=>{function f(t){return t&&typeof t=="object"&&typeof t[Symbol.iterator]=="function"}y.is=f;let r=Object.freeze([]);function e(){return r}y.empty=e;function*o(t){yield t}y.single=o;function n(t){return f(t)?t:o(t)}y.wrap=n;function s(t){return t||r}y.from=s;function*b(t){for(let i=t.length-1;i>=0;i--)yield t[i]}y.reverse=b;function c(t){return!t||t[Symbol.iterator]().next().done===!0}y.isEmpty=c;function d(t){return t[Symbol.iterator]().next().value}y.first=d;function g(t,i){let l=0;for(let u of t)if(i(u,l++))return!0;return!1}y.some=g;function m(t,i){for(let l of t)if(i(l))return l}y.find=m;function*_(t,i){for(let l of t)i(l)&&(yield l)}y.filter=_;function*R(t,i){let l=0;for(let u of t)yield i(u,l++)}y.map=R;function*V(t,i){let l=0;for(let u of t)yield*i(u,l++)}y.flatMap=V;function*N(...t){for(let i of t)yield*i}y.concat=N;function P(t,i,l){let u=l;for(let p of t)u=i(u,p);return u}y.reduce=P;function*z(t,i,l=t.length){for(i<0&&(i+=t.length),l<0?l+=t.length:l>t.length&&(l=t.length);i<l;i++)yield t[i]}y.slice=z;function w(t,i=Number.POSITIVE_INFINITY){let l=[];if(i===0)return[l,t];let u=t[Symbol.iterator]();for(let p=0;p<i;p++){let I=u.next();if(I.done)return[l,y.empty()];l.push(I.value)}return[l,{[Symbol.iterator](){return u}}]}y.consume=w;async function S(t){let i=[];for await(let l of t)i.push(l);return Promise.resolve(i)}y.asyncToArray=S})(h||={});var a=Symbol("unset"),v=class{root=new T;_size=0;get size(){return this._size}get nodes(){return this.root.children?.values()||h.empty()}get entries(){return this.root.children?.entries()||h.empty()}insert(r,e,o){this.opNode(r,n=>n._value=e,o)}mutate(r,e){this.opNode(r,o=>o._value=e(o._value===a?void 0:o._value))}mutatePath(r,e){this.opNode(r,()=>{},o=>e(o))}delete(r){let e=this.getPathToKey(r);if(!e)return;let o=e.length-1,n=e[o].node._value;if(n!==a){for(this._size--,e[o].node._value=a;o>0;o--){let{node:s,part:b}=e[o];if(s.children?.size||s._value!==a)break;e[o-1].node.children.delete(b)}return n}}*deleteRecursive(r){let e=this.getPathToKey(r);if(!e)return;let o=e[e.length-1].node;for(let n=e.length-1;n>0;n--){let s=e[n-1];if(s.node.children.delete(e[n].part),s.node.children.size>0||s.node._value!==a)break}for(let n of x(o))n._value!==a&&(this._size--,yield n._value)}find(r){let e=this.root;for(let o of r){let n=e.children?.get(o);if(!n)return;e=n}return e._value===a?void 0:e._value}hasKeyOrParent(r){let e=this.root;for(let o of r){let n=e.children?.get(o);if(!n)return!1;if(n._value!==a)return!0;e=n}return!1}hasKeyOrChildren(r){let e=this.root;for(let o of r){let n=e.children?.get(o);if(!n)return!1;e=n}return!0}hasKey(r){let e=this.root;for(let o of r){let n=e.children?.get(o);if(!n)return!1;e=n}return e._value!==a}getPathToKey(r){let e=[{part:"",node:this.root}],o=0;for(let n of r){let s=e[o].node.children?.get(n);if(!s)return;e.push({part:n,node:s}),o++}return e}opNode(r,e,o){let n=this.root;for(let c of r){if(n.children)if(n.children.has(c))n=n.children.get(c);else{let d=new T;n.children.set(c,d),n=d}else{let d=new T;n.children=new Map([[c,d]]),n=d}o?.(n)}let s=n._value===a?0:1;e(n);let b=n._value===a?0:1;this._size+=b-s}*values(){for(let{_value:r}of x(this.root))r!==a&&(yield r)}};function*x(f){let r=[f];for(;r.length>0;){let e=r.pop();if(yield e,e.children)for(let o of e.children.values())r.push(o)}}var T=class{children;get value(){return this._value===a?void 0:this._value}set value(r){this._value=r===void 0?a:r}_value=a};export{v as WellDefinedPrefixTree};
