{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/glob.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from './arrays.js';\nimport { isThenable } from './async.js';\nimport { CharCode } from './charCode.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters, ltrim } from './strings.js';\n\nexport interface IRelativePattern {\n\n\t/**\n\t * A base file path to which this pattern will be matched against relatively.\n\t */\n\treadonly base: string;\n\n\t/**\n\t * A file glob pattern like `*.{ts,js}` that will be matched on file paths\n\t * relative to the base path.\n\t *\n\t * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,\n\t * the file glob pattern will match on `index.js`.\n\t */\n\treadonly pattern: string;\n}\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\ninterface SiblingClause {\n\twhen: string;\n}\n\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\n\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number, isLastPattern?: boolean): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n\t\t\t//           in which case also matches (Path Sep followed by Path Val)\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(segment => segment === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Treat globstar specially\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (previousSegmentWasGlobStar) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tregEx += starsToRegExp(2, index === segments.length - 1);\n\t\t\t}\n\n\t\t\t// Anything else, not globstar\n\t\t\telse {\n\n\t\t\t\t// States\n\t\t\t\tlet inBraces = false;\n\t\t\t\tlet braceVal = '';\n\n\t\t\t\tlet inBrackets = false;\n\t\t\t\tlet bracketVal = '';\n\n\t\t\t\tfor (const char of segment) {\n\n\t\t\t\t\t// Support brace expansion\n\t\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\t\tbraceVal += char;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support brackets\n\t\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t\t// range operator\n\t\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\t\tres = char;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\t\tres = '^';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tres = escapeRegExpCharacters(char);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbracketVal += res;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (char) {\n\t\t\t\t\t\tcase '{':\n\t\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '[':\n\t\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '}': {\n\t\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n\n\t\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase ']': {\n\t\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase '?':\n\t\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tregEx += escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tail: Add the slash we had split on if there is more to\n\t\t\t\t// come and the remaining pattern is not a globstar\n\t\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after\n\t\t\t\t// some to be included in the RegEx to prevent a folder called\n\t\t\t\t// \"something\" to match as well.\n\t\t\t\tif (\n\t\t\t\t\tindex < segments.length - 1 &&\t\t\t// more segments to come after this\n\t\t\t\t\t(\n\t\t\t\t\t\tsegments[index + 1] !== GLOBSTAR ||\t// next segment is not **, or...\n\t\t\t\t\t\tindex + 2 < segments.length\t\t\t// ...next segment is ** but there is more segments after that\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tregEx += PATH_REGEX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update globstar state\n\t\t\tpreviousSegmentWasGlobStar = (segment === GLOBSTAR);\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t\t\t\t\t\t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; \t\t\t\t\t\t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The `ParsedExpression` returns a `Promise`\n// iff `hasSibling` returns a `Promise`.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\ninterface IGlobOptions {\n\n\t/**\n\t * Simplify patterns for use as exclusion filters during\n\t * tree traversal to skip entire subtrees. Cannot be used\n\t * outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle relative patterns\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivials\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) {\n\t\tparsedPattern = trivia1(pattern.substr(4), pattern); \t\t\t// common pattern: **/*.txt just need endsWith check\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { \t// common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\tconst wrappedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (!isEqualOrParent(path, arg2.base, !isLinux)) {\n\t\t\t// skip glob matching if `base` is not a parent of `path`\n\t\t\treturn null;\n\t\t}\n\n\t\t// Given we have checked `base` being a parent of `path`,\n\t\t// we can now remove the `base` portion of the `path`\n\t\t// and only match on the remaining path components\n\t\t// For that we try to extract the portion of the `path`\n\t\t// that comes after the `base` portion. We have to account\n\t\t// for the fact that `base` might end in a path separator\n\t\t// (https://github.com/microsoft/vscode/issues/162498)\n\n\t\treturn parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n\t};\n\n\t// Make sure to preserve associated metadata\n\twrappedPattern.allBasenames = parsedPattern.allBasenames;\n\twrappedPattern.allPaths = parsedPattern.allPaths;\n\twrappedPattern.basenames = parsedPattern.basenames;\n\twrappedPattern.patterns = parsedPattern.patterns;\n\n\treturn wrappedPattern;\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base: string, pattern: string): ParsedStringPattern {\n\treturn function (path: string, basename?: string) {\n\t\treturn typeof path === 'string' && path.endsWith(base) ? pattern : null;\n\t};\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, pattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (basename) {\n\t\t\treturn basename === base ? pattern : null;\n\t\t}\n\n\t\treturn path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n\t};\n\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [pattern];\n\tparsedPattern.allBasenames = basenames;\n\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n\t\t.split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (patternsLength === 1) {\n\t\treturn parsedPatterns[0];\n\t}\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif (parsedPatterns[i](path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst usingPosixSep = sep === posix.sep;\n\tconst nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n\tconst nativePathEnd = sep + nativePath;\n\tconst targetPathEnd = posix.sep + targetPath;\n\n\tlet parsedPattern: ParsedStringPattern;\n\tif (matchPathEnds) {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n\t\t};\n\t} else {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n\t\t};\n\t}\n\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, \u2026)\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, \u2026)\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options?: IGlobOptions): ParsedPattern | ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[] } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern | undefined | null;\n\tif (!rp) {\n\t\treturn false;\n\t}\n\n\treturn typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (patternsLength === 1) {\n\t\t\treturn parsedPatterns[0] as ParsedStringPattern;\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\tconst result = parsedPatterns[i](path, basename);\n\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t\t}\n\n\t\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t\t// later processing and await the result properly.\n\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\tif (!resultPromises) {\n\t\t\t\t\t\tresultPromises = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tresultPromises.push(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// With result promises, we have to loop over each and\n\t\t\t// await the result before we can return any result.\n\t\t\tif (resultPromises) {\n\t\t\t\treturn (async () => {\n\t\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, base?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!base) {\n\t\t\t\t\tbase = basename(path);\n\t\t\t\t}\n\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = base.substr(0, base.length - extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = parsedPattern(path, base, name, hasSibling);\n\t\t\tif (typeof result === 'string') {\n\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t}\n\n\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t// later processing and await the result properly.\n\t\t\tif (isThenable(result)) {\n\t\t\t\tif (!resultPromises) {\n\t\t\t\t\tresultPromises = [];\n\t\t\t\t}\n\n\t\t\t\tresultPromises.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// With result promises, we have to loop over each and\n\t\t// await the result before we can return any result.\n\t\tif (resultPromises) {\n\t\t\treturn (async () => {\n\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t})();\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = value.when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', () => name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(match => match ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\n\t\t\tresult.requiresSiblings = true;\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, [] as string[]);\n\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, [] as string[]);\n\t}\n\n\tconst aggregate: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasename = path.substr(i);\n\t\t}\n\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\n\treturn aggregatedPatterns;\n}\n\nexport function patternsEquals(patternsA: Array<string | IRelativePattern> | undefined, patternsB: Array<string | IRelativePattern> | undefined): boolean {\n\treturn equals(patternsA, patternsB, (a, b) => {\n\t\tif (typeof a === 'string' && typeof b === 'string') {\n\t\t\treturn a === b;\n\t\t}\n\n\t\tif (typeof a !== 'string' && typeof b !== 'string') {\n\t\t\treturn a.base === b.base && a.pattern === b.pattern;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n"],
  "mappings": "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",
  "names": ["match", "basename", "pattern", "resultExpression", "withBasenames", "allPaths", "basenames", "patterns"]
}
