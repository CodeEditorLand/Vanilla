{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/glob.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from \"./arrays.js\";\nimport { isThenable } from \"./async.js\";\nimport { CharCode } from \"./charCode.js\";\nimport { isEqualOrParent } from \"./extpath.js\";\nimport { LRUCache } from \"./map.js\";\nimport { basename, extname, posix, sep } from \"./path.js\";\nimport { isLinux } from \"./platform.js\";\nimport { escapeRegExpCharacters, ltrim } from \"./strings.js\";\n\nexport interface IRelativePattern {\n\t/**\n\t * A base file path to which this pattern will be matched against relatively.\n\t */\n\treadonly base: string;\n\n\t/**\n\t * A file glob pattern like `*.{ts,js}` that will be matched on file paths\n\t * relative to the base path.\n\t *\n\t * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,\n\t * the file glob pattern will match on `index.js`.\n\t */\n\treadonly pattern: string;\n}\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\ninterface SiblingClause {\n\twhen: string;\n}\n\nexport const GLOBSTAR = \"**\";\nexport const GLOB_SPLIT = \"/\";\n\nconst PATH_REGEX = \"[/\\\\\\\\]\"; // any slash or backslash\nconst NO_PATH_REGEX = \"[^/\\\\\\\\]\"; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number, isLastPattern?: boolean): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn \"\";\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n\t\t\t//           in which case also matches (Path Sep followed by Path Val)\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : \"\"})*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = \"\";\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = \"\";\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"{\":\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase \"}\":\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase \"[\":\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase \"]\":\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn \"\";\n\t}\n\n\tlet regEx = \"\";\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every((segment) => segment === GLOBSTAR)) {\n\t\tregEx = \".*\";\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\t\t\t// Treat globstar specially\n\t\t\tif (segment === GLOBSTAR) {\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (previousSegmentWasGlobStar) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tregEx += starsToRegExp(2, index === segments.length - 1);\n\t\t\t}\n\n\t\t\t// Anything else, not globstar\n\t\t\telse {\n\t\t\t\t// States\n\t\t\t\tlet inBraces = false;\n\t\t\t\tlet braceVal = \"\";\n\n\t\t\t\tlet inBrackets = false;\n\t\t\t\tlet bracketVal = \"\";\n\n\t\t\t\tfor (const char of segment) {\n\t\t\t\t\t// Support brace expansion\n\t\t\t\t\tif (char !== \"}\" && inBraces) {\n\t\t\t\t\t\tbraceVal += char;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support brackets\n\t\t\t\t\tif (\n\t\t\t\t\t\tinBrackets &&\n\t\t\t\t\t\t(char !== \"]\" ||\n\t\t\t\t\t\t\t!bracketVal) /* ] is literally only allowed as first character in brackets to match it */\n\t\t\t\t\t) {\n\t\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t\t// range operator\n\t\t\t\t\t\tif (char === \"-\") {\n\t\t\t\t\t\t\tres = char;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\t\telse if (\n\t\t\t\t\t\t\t(char === \"^\" || char === \"!\") &&\n\t\t\t\t\t\t\t!bracketVal\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tres = \"^\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\t\tres = \"\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tres = escapeRegExpCharacters(char);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbracketVal += res;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (char) {\n\t\t\t\t\t\tcase \"{\":\n\t\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase \"[\":\n\t\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase \"}\": {\n\t\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, \",\");\n\n\t\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map((choice) => parseRegExp(choice)).join(\"|\")})`;\n\n\t\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\t\tbraceVal = \"\";\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase \"]\": {\n\t\t\t\t\t\t\tregEx += \"[\" + bracketVal + \"]\";\n\n\t\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\t\tbracketVal = \"\";\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase \"?\":\n\t\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tregEx += escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tail: Add the slash we had split on if there is more to\n\t\t\t\t// come and the remaining pattern is not a globstar\n\t\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after\n\t\t\t\t// some to be included in the RegEx to prevent a folder called\n\t\t\t\t// \"something\" to match as well.\n\t\t\t\tif (\n\t\t\t\t\tindex < segments.length - 1 && // more segments to come after this\n\t\t\t\t\t(segments[index + 1] !== GLOBSTAR || // next segment is not **, or...\n\t\t\t\t\t\tindex + 2 < segments.length) // ...next segment is ** but there is more segments after that\n\t\t\t\t) {\n\t\t\t\t\tregEx += PATH_REGEX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update globstar state\n\t\t\tpreviousSegmentWasGlobStar = segment === GLOBSTAR;\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w.-]+\\/?(,\\*\\*\\/\\*?[\\w.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w.-]+(\\/[\\w.-]+)*)\\/?$/; // something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The `ParsedExpression` returns a `Promise`\n// iff `hasSibling` returns a `Promise`.\nexport type ParsedExpression = (\n\tpath: string,\n\tbasename?: string,\n\thasSibling?: (name: string) => boolean | Promise<boolean>,\n) => string | null | Promise<string | null> /* the matching pattern */;\n\ninterface IGlobOptions {\n\t/**\n\t * Simplify patterns for use as exclusion filters during\n\t * tree traversal to skip entire subtrees. Cannot be used\n\t * outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(\n\t\tpath: string,\n\t\tbasename?: string,\n\t): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\ninterface ParsedExpressionPattern {\n\t(\n\t\tpath: string,\n\t\tbasename?: string,\n\t\tname?: string,\n\t\thasSibling?: (name: string) => boolean | Promise<boolean>,\n\t): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = () => false;\n\nconst NULL = (): string | null => null;\n\nfunction parsePattern(\n\targ1: string | IRelativePattern,\n\toptions: IGlobOptions,\n): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle relative patterns\n\tlet pattern: string;\n\tif (typeof arg1 !== \"string\") {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivials\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) {\n\t\tparsedPattern = trivia1(pattern.substr(4), pattern); // common pattern: **/*.txt just need endsWith check\n\t} else if ((match = T2.exec(trimForExclusions(pattern, options)))) {\n\t\t// common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {\n\t\t// repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if ((match = T4.exec(trimForExclusions(pattern, options)))) {\n\t\t// common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if ((match = T5.exec(trimForExclusions(pattern, options)))) {\n\t\t// common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(\n\tparsedPattern: ParsedStringPattern,\n\targ2: string | IRelativePattern,\n): ParsedStringPattern {\n\tif (typeof arg2 === \"string\") {\n\t\treturn parsedPattern;\n\t}\n\n\tconst wrappedPattern: ParsedStringPattern = (path, basename) => {\n\t\tif (!isEqualOrParent(path, arg2.base, !isLinux)) {\n\t\t\t// skip glob matching if `base` is not a parent of `path`\n\t\t\treturn null;\n\t\t}\n\n\t\t// Given we have checked `base` being a parent of `path`,\n\t\t// we can now remove the `base` portion of the `path`\n\t\t// and only match on the remaining path components\n\t\t// For that we try to extract the portion of the `path`\n\t\t// that comes after the `base` portion. We have to account\n\t\t// for the fact that `base` might end in a path separator\n\t\t// (https://github.com/microsoft/vscode/issues/162498)\n\n\t\treturn parsedPattern(\n\t\t\tltrim(path.substr(arg2.base.length), sep),\n\t\t\tbasename,\n\t\t);\n\t};\n\n\t// Make sure to preserve associated metadata\n\twrappedPattern.allBasenames = parsedPattern.allBasenames;\n\twrappedPattern.allPaths = parsedPattern.allPaths;\n\twrappedPattern.basenames = parsedPattern.basenames;\n\twrappedPattern.patterns = parsedPattern.patterns;\n\n\treturn wrappedPattern;\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith(\"/**\")\n\t\t? pattern.substr(0, pattern.length - 2)\n\t\t: pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base: string, pattern: string): ParsedStringPattern {\n\treturn (path: string, basename?: string) =>\n\t\ttypeof path === \"string\" && path.endsWith(base) ? pattern : null;\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, pattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\n\tconst parsedPattern: ParsedStringPattern = (\n\t\tpath: string,\n\t\tbasename?: string,\n\t) => {\n\t\tif (typeof path !== \"string\") {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (basename) {\n\t\t\treturn basename === base ? pattern : null;\n\t\t}\n\n\t\treturn path === base ||\n\t\t\tpath.endsWith(slashBase) ||\n\t\t\tpath.endsWith(backslashBase)\n\t\t\t? pattern\n\t\t\t: null;\n\t};\n\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [pattern];\n\tparsedPattern.allBasenames = basenames;\n\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(\n\t\tpattern\n\t\t\t.slice(1, -1)\n\t\t\t.split(\",\")\n\t\t\t.map((pattern) => parsePattern(pattern, options))\n\t\t\t.filter((pattern) => pattern !== NULL),\n\t\tpattern,\n\t);\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (patternsLength === 1) {\n\t\treturn parsedPatterns[0];\n\t}\n\n\tconst parsedPattern: ParsedStringPattern = (\n\t\tpath: string,\n\t\tbasename?: string,\n\t) => {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif (parsedPatterns[i](path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(\n\t\t(pattern) => !!pattern.allBasenames,\n\t);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce(\n\t\t(all, current) =>\n\t\t\tcurrent.allPaths ? all.concat(current.allPaths) : all,\n\t\t[] as string[],\n\t);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(\n\ttargetPath: string,\n\tpattern: string,\n\tmatchPathEnds: boolean,\n): ParsedStringPattern {\n\tconst usingPosixSep = sep === posix.sep;\n\tconst nativePath = usingPosixSep\n\t\t? targetPath\n\t\t: targetPath.replace(ALL_FORWARD_SLASHES, sep);\n\tconst nativePathEnd = sep + nativePath;\n\tconst targetPathEnd = posix.sep + targetPath;\n\n\tlet parsedPattern: ParsedStringPattern;\n\tif (matchPathEnds) {\n\t\tparsedPattern = (path: string, basename?: string) =>\n\t\t\ttypeof path === \"string\" &&\n\t\t\t(path === nativePath ||\n\t\t\t\tpath.endsWith(nativePathEnd) ||\n\t\t\t\t(!usingPosixSep &&\n\t\t\t\t\t(path === targetPath || path.endsWith(targetPathEnd))))\n\t\t\t\t? pattern\n\t\t\t\t: null;\n\t} else {\n\t\tparsedPattern = (path: string, basename?: string) =>\n\t\t\ttypeof path === \"string\" &&\n\t\t\t(path === nativePath || (!usingPosixSep && path === targetPath))\n\t\t\t\t? pattern\n\t\t\t\t: null;\n\t}\n\n\tparsedPattern.allPaths = [(matchPathEnds ? \"*/\" : \"./\") + targetPath];\n\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn (path: string) => {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n\t\t\treturn typeof path === \"string\" && regExp.test(path)\n\t\t\t\t? pattern\n\t\t\t\t: null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, \u2026)\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function match(\n\tpattern: string | IRelativePattern,\n\tpath: string,\n): boolean;\nexport function match(\n\texpression: IExpression,\n\tpath: string,\n\thasSibling?: (name: string) => boolean,\n): string /* the matching pattern */;\nexport function match(\n\targ1: string | IExpression | IRelativePattern,\n\tpath: string,\n\thasSibling?: (name: string) => boolean,\n): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== \"string\") {\n\t\treturn false;\n\t}\n\n\treturn parse(arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, \u2026)\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function parse(\n\tpattern: string | IRelativePattern,\n\toptions?: IGlobOptions,\n): ParsedPattern;\nexport function parse(\n\texpression: IExpression,\n\toptions?: IGlobOptions,\n): ParsedExpression;\nexport function parse(\n\targ1: string | IExpression | IRelativePattern,\n\toptions?: IGlobOptions,\n): ParsedPattern | ParsedExpression;\nexport function parse(\n\targ1: string | IExpression | IRelativePattern,\n\toptions: IGlobOptions = {},\n): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === \"string\" || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst resultPattern: ParsedPattern & {\n\t\t\tallBasenames?: string[];\n\t\t\tallPaths?: string[];\n\t\t} = (path: string, basename?: string) =>\n\t\t\t!!parsedPattern(path, basename);\n\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern | undefined | null;\n\tif (!rp) {\n\t\treturn false;\n\t}\n\n\treturn typeof rp.base === \"string\" && typeof rp.pattern === \"string\";\n}\n\nexport function getBasenameTerms(\n\tpatternOrExpression: ParsedPattern | ParsedExpression,\n): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(\n\tpatternOrExpression: ParsedPattern | ParsedExpression,\n): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(\n\texpression: IExpression,\n\toptions: IGlobOptions,\n): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(\n\t\tObject.getOwnPropertyNames(expression)\n\t\t\t.map((pattern) =>\n\t\t\t\tparseExpressionPattern(pattern, expression[pattern], options),\n\t\t\t)\n\t\t\t.filter((pattern) => pattern !== NULL),\n\t);\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (\n\t\t!parsedPatterns.some(\n\t\t\t(parsedPattern) =>\n\t\t\t\t!!(<ParsedExpressionPattern>parsedPattern).requiresSiblings,\n\t\t)\n\t) {\n\t\tif (patternsLength === 1) {\n\t\t\treturn parsedPatterns[0] as ParsedStringPattern;\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = (\n\t\t\tpath: string,\n\t\t\tbasename?: string,\n\t\t) => {\n\t\t\tlet resultPromises: Promise<string | null>[] | undefined;\n\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\tconst result = parsedPatterns[i](path, basename);\n\t\t\t\tif (typeof result === \"string\") {\n\t\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t\t}\n\n\t\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t\t// later processing and await the result properly.\n\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\tif (!resultPromises) {\n\t\t\t\t\t\tresultPromises = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tresultPromises.push(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// With result promises, we have to loop over each and\n\t\t\t// await the result before we can return any result.\n\t\t\tif (resultPromises) {\n\t\t\t\treturn (async () => {\n\t\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\t\tif (typeof result === \"string\") {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(\n\t\t\t(pattern) => !!pattern.allBasenames,\n\t\t);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce(\n\t\t\t(all, current) =>\n\t\t\t\tcurrent.allPaths ? all.concat(current.allPaths) : all,\n\t\t\t[] as string[],\n\t\t);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = (\n\t\tpath: string,\n\t\tbase?: string,\n\t\thasSibling?: (name: string) => boolean | Promise<boolean>,\n\t) => {\n\t\tlet name: string | undefined;\n\t\tlet resultPromises: Promise<string | null>[] | undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = <ParsedExpressionPattern>parsedPatterns[i];\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!base) {\n\t\t\t\t\tbase = basename(path);\n\t\t\t\t}\n\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = base.substr(0, base.length - extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = parsedPattern(path, base, name, hasSibling);\n\t\t\tif (typeof result === \"string\") {\n\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t}\n\n\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t// later processing and await the result properly.\n\t\t\tif (isThenable(result)) {\n\t\t\t\tif (!resultPromises) {\n\t\t\t\t\tresultPromises = [];\n\t\t\t\t}\n\n\t\t\t\tresultPromises.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// With result promises, we have to loop over each and\n\t\t// await the result before we can return any result.\n\t\tif (resultPromises) {\n\t\t\treturn (async () => {\n\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\tif (typeof result === \"string\") {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t})();\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(\n\t\t(pattern) => !!pattern.allBasenames,\n\t);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce(\n\t\t(all, current) =>\n\t\t\tcurrent.allPaths ? all.concat(current.allPaths) : all,\n\t\t[] as string[],\n\t);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(\n\tpattern: string,\n\tvalue: boolean | SiblingClause,\n\toptions: IGlobOptions,\n): ParsedStringPattern | ParsedExpressionPattern {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === \"boolean\") {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = value.when;\n\t\tif (typeof when === \"string\") {\n\t\t\tconst result: ParsedExpressionPattern = (\n\t\t\t\tpath: string,\n\t\t\t\tbasename?: string,\n\t\t\t\tname?: string,\n\t\t\t\thasSibling?: (name: string) => boolean | Promise<boolean>,\n\t\t\t) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace(\"$(basename)\", () => name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched)\n\t\t\t\t\t? matched.then((match) => (match ? pattern : null))\n\t\t\t\t\t: matched\n\t\t\t\t\t\t? pattern\n\t\t\t\t\t\t: null;\n\t\t\t};\n\n\t\t\tresult.requiresSiblings = true;\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(\n\tparsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>,\n\tresult?: string,\n): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(\n\t\t(parsedPattern) => !!(<ParsedStringPattern>parsedPattern).basenames,\n\t);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, [] as string[]);\n\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, [] as string[]);\n\t}\n\n\tconst aggregate: ParsedStringPattern = (\n\t\tpath: string,\n\t\tbasename?: string,\n\t) => {\n\t\tif (typeof path !== \"string\") {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasename = path.substr(i);\n\t\t}\n\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(\n\t\t(parsedPattern) => !(<ParsedStringPattern>parsedPattern).basenames,\n\t);\n\taggregatedPatterns.push(aggregate);\n\n\treturn aggregatedPatterns;\n}\n\nexport function patternsEquals(\n\tpatternsA: Array<string | IRelativePattern> | undefined,\n\tpatternsB: Array<string | IRelativePattern> | undefined,\n): boolean {\n\treturn equals(patternsA, patternsB, (a, b) => {\n\t\tif (typeof a === \"string\" && typeof b === \"string\") {\n\t\t\treturn a === b;\n\t\t}\n\n\t\tif (typeof a !== \"string\" && typeof b !== \"string\") {\n\t\t\treturn a.base === b.base && a.pattern === b.pattern;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n"],
  "mappings": "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",
  "names": ["match", "basename", "pattern", "resultExpression", "withBasenames", "allPaths", "basenames", "patterns"]
}
