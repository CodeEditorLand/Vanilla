{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/observableInternal/utils.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { autorun, autorunOpts, autorunWithStoreHandleChanges } from './autorun.js';\nimport { BaseObservable, ConvenientObservable, IObservable, IObserver, IReader, ITransaction, _setKeepObserved, _setRecomputeInitiallyAndOnChange, observableValue, subtransaction, transaction } from './base.js';\nimport { DebugNameData, DebugOwner, IDebugNameData, getDebugName, } from './debugName.js';\nimport { BugIndicatingError, DisposableStore, EqualityComparer, Event, IDisposable, IValueWithChangeEvent, strictEquals, toDisposable } from './commonFacade/deps.js';\nimport { derived, derivedOpts } from './derived.js';\nimport { getLogger } from './logging.js';\n\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable<T>(value: T): IObservable<T> {\n\treturn new ConstObservable(value);\n}\n\nclass ConstObservable<T> extends ConvenientObservable<T, void> {\n\tconstructor(private readonly value: T) {\n\t\tsuper();\n\t}\n\n\tpublic override get debugName(): string {\n\t\treturn this.toString();\n\t}\n\n\tpublic get(): T {\n\t\treturn this.value;\n\t}\n\tpublic addObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\tpublic removeObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\n\toverride toString(): string {\n\t\treturn `Const: ${this.value}`;\n\t}\n}\n\n\nexport function observableFromPromise<T>(promise: Promise<T>): IObservable<{ value?: T }> {\n\tconst observable = observableValue<{ value?: T }>('promiseValue', {});\n\tpromise.then((value) => {\n\t\tobservable.set({ value }, undefined);\n\t});\n\treturn observable;\n}\n\n\nexport function observableFromEvent<T, TArgs = unknown>(\n\towner: DebugOwner,\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T>;\nexport function observableFromEvent<T, TArgs = unknown>(\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T>;\nexport function observableFromEvent(...args:\n\t[owner: DebugOwner, event: Event<any>, getValue: (args: any | undefined) => any]\n\t| [event: Event<any>, getValue: (args: any | undefined) => any]\n): IObservable<any> {\n\tlet owner;\n\tlet event;\n\tlet getValue;\n\tif (args.length === 3) {\n\t\t[owner, event, getValue] = args;\n\t} else {\n\t\t[event, getValue] = args;\n\t}\n\treturn new FromEventObservable(\n\t\tnew DebugNameData(owner, undefined, getValue),\n\t\tevent,\n\t\tgetValue,\n\t\t() => FromEventObservable.globalTransaction,\n\t\tstrictEquals\n\t);\n}\n\nexport function observableFromEventOpts<T, TArgs = unknown>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t},\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T> {\n\treturn new FromEventObservable(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue),\n\t\tevent,\n\t\tgetValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? strictEquals\n\t);\n}\n\nexport class FromEventObservable<TArgs, T> extends BaseObservable<T> {\n\tpublic static globalTransaction: ITransaction | undefined;\n\n\tprivate value: T | undefined;\n\tprivate hasValue = false;\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tprivate readonly event: Event<TArgs>,\n\t\tpublic readonly _getValue: (args: TArgs | undefined) => T,\n\t\tprivate readonly _getTransaction: () => ITransaction | undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate getDebugName(): string | undefined {\n\t\treturn this._debugNameData.getDebugName(this);\n\t}\n\n\tpublic get debugName(): string {\n\t\tconst name = this.getDebugName();\n\t\treturn 'From Event' + (name ? `: ${name}` : '');\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = (args: TArgs | undefined) => {\n\t\tconst newValue = this._getValue(args);\n\t\tconst oldValue = this.value;\n\n\t\tconst didChange = !this.hasValue || !(this._equalityComparator(oldValue!, newValue));\n\t\tlet didRunTransaction = false;\n\n\t\tif (didChange) {\n\t\t\tthis.value = newValue;\n\n\t\t\tif (this.hasValue) {\n\t\t\t\tdidRunTransaction = true;\n\t\t\t\tsubtransaction(\n\t\t\t\t\tthis._getTransaction(),\n\t\t\t\t\t(tx) => {\n\t\t\t\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\n\t\t\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst name = this.getDebugName();\n\t\t\t\t\t\treturn 'Event fired' + (name ? `: ${name}` : '');\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.hasValue = true;\n\t\t}\n\n\t\tif (!didRunTransaction) {\n\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\t\t}\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t\tthis.hasValue = false;\n\t\tthis.value = undefined;\n\t}\n\n\tpublic get(): T {\n\t\tif (this.subscription) {\n\t\t\tif (!this.hasValue) {\n\t\t\t\tthis.handleEvent(undefined);\n\t\t\t}\n\t\t\treturn this.value!;\n\t\t} else {\n\t\t\t// no cache, as there are no subscribers to keep it updated\n\t\t\tconst value = this._getValue(undefined);\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nexport namespace observableFromEvent {\n\texport const Observer = FromEventObservable;\n\n\texport function batchEventsGlobally(tx: ITransaction, fn: () => void): void {\n\t\tlet didSet = false;\n\t\tif (FromEventObservable.globalTransaction === undefined) {\n\t\t\tFromEventObservable.globalTransaction = tx;\n\t\t\tdidSet = true;\n\t\t}\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\t\t\tif (didSet) {\n\t\t\t\tFromEventObservable.globalTransaction = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function observableSignalFromEvent(\n\tdebugName: string,\n\tevent: Event<any>\n): IObservable<void> {\n\treturn new FromEventObservableSignal(debugName, event);\n}\n\nclass FromEventObservableSignal extends BaseObservable<void> {\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tpublic readonly debugName: string,\n\t\tprivate readonly event: Event<any>,\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = () => {\n\t\ttransaction(\n\t\t\t(tx) => {\n\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\t() => this.debugName\n\t\t);\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\n/**\n * Creates a signal that can be triggered to invalidate observers.\n * Signals don't have a value - when they are triggered they indicate a change.\n * However, signals can carry a delta that is passed to observers.\n */\nexport function observableSignal<TDelta = void>(debugName: string): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(owner: object): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(debugNameOrOwner: string | object): IObservableSignal<TDelta> {\n\tif (typeof debugNameOrOwner === 'string') {\n\t\treturn new ObservableSignal<TDelta>(debugNameOrOwner);\n\t} else {\n\t\treturn new ObservableSignal<TDelta>(undefined, debugNameOrOwner);\n\t}\n}\n\nexport interface IObservableSignal<TChange> extends IObservable<void, TChange> {\n\ttrigger(tx: ITransaction | undefined, change: TChange): void;\n}\n\nclass ObservableSignal<TChange> extends BaseObservable<void, TChange> implements IObservableSignal<TChange> {\n\tpublic get debugName() {\n\t\treturn new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n\t}\n\n\tpublic override toString(): string {\n\t\treturn this.debugName;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | undefined,\n\t\tprivate readonly _owner?: object,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic trigger(tx: ITransaction | undefined, change: TChange): void {\n\t\tif (!tx) {\n\t\t\ttransaction(tx => {\n\t\t\t\tthis.trigger(tx, change);\n\t\t\t}, () => `Trigger signal ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const o of this.observers) {\n\t\t\ttx.updateObserver(o, this);\n\t\t\to.handleChange(this, change);\n\t\t}\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\nexport function signalFromObservable<T>(owner: DebugOwner | undefined, observable: IObservable<T>): IObservable<void> {\n\treturn derivedOpts({\n\t\towner,\n\t\tequalsFn: () => false,\n\t}, reader => {\n\t\tobservable.read(reader);\n\t});\n}\n\n/**\n * @deprecated Use `debouncedObservable2` instead.\n */\nexport function debouncedObservable<T>(observable: IObservable<T>, debounceMs: number, disposableStore: DisposableStore): IObservable<T | undefined> {\n\tconst debouncedObservable = observableValue<T | undefined>('debounced', undefined);\n\n\tlet timeout: any = undefined;\n\n\tdisposableStore.add(autorun(reader => {\n\t\t/** @description debounce */\n\t\tconst value = observable.read(reader);\n\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\t\ttimeout = setTimeout(() => {\n\t\t\ttransaction(tx => {\n\t\t\t\tdebouncedObservable.set(value, tx);\n\t\t\t});\n\t\t}, debounceMs);\n\n\t}));\n\n\treturn debouncedObservable;\n}\n\n/**\n * Creates an observable that debounces the input observable.\n */\nexport function debouncedObservable2<T>(observable: IObservable<T>, debounceMs: number): IObservable<T> {\n\tlet hasValue = false;\n\tlet lastValue: T | undefined;\n\n\tlet timeout: any = undefined;\n\n\treturn observableFromEvent<T, void>(cb => {\n\t\tconst d = autorun(reader => {\n\t\t\tconst value = observable.read(reader);\n\n\t\t\tif (!hasValue) {\n\t\t\t\thasValue = true;\n\t\t\t\tlastValue = value;\n\t\t\t} else {\n\t\t\t\tif (timeout) {\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t}\n\t\t\t\ttimeout = setTimeout(() => {\n\t\t\t\t\tlastValue = value;\n\t\t\t\t\tcb();\n\t\t\t\t}, debounceMs);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tdispose() {\n\t\t\t\td.dispose();\n\t\t\t\thasValue = false;\n\t\t\t\tlastValue = undefined;\n\t\t\t},\n\t\t};\n\t}, () => {\n\t\tif (hasValue) {\n\t\t\treturn lastValue!;\n\t\t} else {\n\t\t\treturn observable.get();\n\t\t}\n\t});\n}\n\nexport function wasEventTriggeredRecently(event: Event<any>, timeoutMs: number, disposableStore: DisposableStore): IObservable<boolean> {\n\tconst observable = observableValue('triggeredRecently', false);\n\n\tlet timeout: any = undefined;\n\n\tdisposableStore.add(event(() => {\n\t\tobservable.set(true, undefined);\n\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\t\ttimeout = setTimeout(() => {\n\t\t\tobservable.set(false, undefined);\n\t\t}, timeoutMs);\n\t}));\n\n\treturn observable;\n}\n\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved<T>(observable: IObservable<T>): IDisposable {\n\tconst o = new KeepAliveObserver(false, undefined);\n\tobservable.addObserver(o);\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setKeepObserved(keepObserved);\n\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange<T>(observable: IObservable<T>, handleValue?: (value: T) => void): IDisposable {\n\tconst o = new KeepAliveObserver(true, handleValue);\n\tobservable.addObserver(o);\n\tif (handleValue) {\n\t\thandleValue(observable.get());\n\t} else {\n\t\tobservable.reportChanges();\n\t}\n\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\n\nexport class KeepAliveObserver implements IObserver {\n\tprivate _counter = 0;\n\n\tconstructor(\n\t\tprivate readonly _forceRecompute: boolean,\n\t\tprivate readonly _handleValue: ((value: any) => void) | undefined,\n\t) { }\n\n\tbeginUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis._counter++;\n\t}\n\n\tendUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis._counter--;\n\t\tif (this._counter === 0 && this._forceRecompute) {\n\t\t\tif (this._handleValue) {\n\t\t\t\tthis._handleValue(observable.get());\n\t\t\t} else {\n\t\t\t\tobservable.reportChanges();\n\t\t\t}\n\t\t}\n\t}\n\n\thandlePossibleChange<T>(observable: IObservable<T, unknown>): void {\n\t\t// NO OP\n\t}\n\n\thandleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\t// NO OP\n\t}\n}\n\nexport function derivedObservableWithCache<T>(owner: DebugOwner, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> {\n\tlet lastValue: T | undefined = undefined;\n\tconst observable = derivedOpts({ owner, debugReferenceFn: computeFn }, reader => {\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn observable;\n}\n\nexport function derivedObservableWithWritableCache<T>(owner: object, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T>\n\t& { clearCache(transaction: ITransaction): void; setCache(newValue: T | undefined, tx: ITransaction | undefined): void } {\n\tlet lastValue: T | undefined = undefined;\n\tconst onChange = observableSignal('derivedObservableWithWritableCache');\n\tconst observable = derived(owner, reader => {\n\t\tonChange.read(reader);\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn Object.assign(observable, {\n\t\tclearCache: (tx: ITransaction) => {\n\t\t\tlastValue = undefined;\n\t\t\tonChange.trigger(tx);\n\t\t},\n\t\tsetCache: (newValue: T | undefined, tx: ITransaction | undefined) => {\n\t\t\tlastValue = newValue;\n\t\t\tonChange.trigger(tx);\n\t\t}\n\t});\n}\n\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached<TIn, TOut, TKey = TIn>(owner: DebugOwner, items: IObservable<readonly TIn[]>, map: (input: TIn, store: DisposableStore) => TOut, keySelector?: (input: TIn) => TKey): IObservable<readonly TOut[]> {\n\tlet m = new ArrayMap(map, keySelector);\n\tconst self = derivedOpts({\n\t\tdebugReferenceFn: map,\n\t\towner,\n\t\tonLastObserverRemoved: () => {\n\t\t\tm.dispose();\n\t\t\tm = new ArrayMap(map);\n\t\t}\n\t}, (reader) => {\n\t\tm.setItems(items.read(reader));\n\t\treturn m.getItems();\n\t});\n\treturn self;\n}\n\nclass ArrayMap<TIn, TOut, TKey> implements IDisposable {\n\tprivate readonly _cache = new Map<TKey, { out: TOut; store: DisposableStore }>();\n\tprivate _items: TOut[] = [];\n\tconstructor(\n\t\tprivate readonly _map: (input: TIn, store: DisposableStore) => TOut,\n\t\tprivate readonly _keySelector?: (input: TIn) => TKey,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._cache.forEach(entry => entry.store.dispose());\n\t\tthis._cache.clear();\n\t}\n\n\tpublic setItems(items: readonly TIn[]): void {\n\t\tconst newItems: TOut[] = [];\n\t\tconst itemsToRemove = new Set(this._cache.keys());\n\n\t\tfor (const item of items) {\n\t\t\tconst key = this._keySelector ? this._keySelector(item) : item as unknown as TKey;\n\n\t\t\tlet entry = this._cache.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tconst store = new DisposableStore();\n\t\t\t\tconst out = this._map(item, store);\n\t\t\t\tentry = { out, store };\n\t\t\t\tthis._cache.set(key, entry);\n\t\t\t} else {\n\t\t\t\titemsToRemove.delete(key);\n\t\t\t}\n\t\t\tnewItems.push(entry.out);\n\t\t}\n\n\t\tfor (const item of itemsToRemove) {\n\t\t\tconst entry = this._cache.get(item)!;\n\t\t\tentry.store.dispose();\n\t\t\tthis._cache.delete(item);\n\t\t}\n\n\t\tthis._items = newItems;\n\t}\n\n\tpublic getItems(): TOut[] {\n\t\treturn this._items;\n\t}\n}\n\nexport class ValueWithChangeEventFromObservable<T> implements IValueWithChangeEvent<T> {\n\tconstructor(public readonly observable: IObservable<T>) {\n\t}\n\n\tget onDidChange(): Event<void> {\n\t\treturn Event.fromObservableLight(this.observable);\n\t}\n\n\tget value(): T {\n\t\treturn this.observable.get();\n\t}\n}\n\nexport function observableFromValueWithChangeEvent<T>(owner: DebugOwner, value: IValueWithChangeEvent<T>): IObservable<T> {\n\tif (value instanceof ValueWithChangeEventFromObservable) {\n\t\treturn value.observable;\n\t}\n\treturn observableFromEvent(owner, value.onDidChange, () => value.value);\n}\n\n/**\n * Creates an observable that has the latest changed value of the given observables.\n * Initially (and when not observed), it has the value of the last observable.\n * When observed and any of the observables change, it has the value of the last changed observable.\n * If multiple observables change in the same transaction, the last observable wins.\n*/\nexport function latestChangedValue<T extends IObservable<any>[]>(owner: DebugOwner, observables: T): IObservable<ReturnType<T[number]['get']>> {\n\tif (observables.length === 0) {\n\t\tthrow new BugIndicatingError();\n\t}\n\n\tlet hasLastChangedValue = false;\n\tlet lastChangedValue: any = undefined;\n\n\tconst result = observableFromEvent<any, void>(owner, cb => {\n\t\tconst store = new DisposableStore();\n\t\tfor (const o of observables) {\n\t\t\tstore.add(autorunOpts({ debugName: () => getDebugName(result, new DebugNameData(owner, undefined, undefined)) + '.updateLastChangedValue' }, reader => {\n\t\t\t\thasLastChangedValue = true;\n\t\t\t\tlastChangedValue = o.read(reader);\n\t\t\t\tcb();\n\t\t\t}));\n\t\t}\n\t\tstore.add({\n\t\t\tdispose() {\n\t\t\t\thasLastChangedValue = false;\n\t\t\t\tlastChangedValue = undefined;\n\t\t\t},\n\t\t});\n\t\treturn store;\n\t}, () => {\n\t\tif (hasLastChangedValue) {\n\t\t\treturn lastChangedValue;\n\t\t} else {\n\t\t\treturn observables[observables.length - 1].get();\n\t\t}\n\t});\n\treturn result;\n}\n\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nexport function derivedConstOnceDefined<T>(owner: DebugOwner, fn: (reader: IReader) => T): IObservable<T | undefined> {\n\treturn derivedObservableWithCache<T | undefined>(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\n\ntype RemoveUndefined<T> = T extends undefined ? never : T;\n\nexport function runOnChange<T, TChange>(observable: IObservable<T, TChange>, cb: (value: T, previousValue: undefined | T, deltas: RemoveUndefined<TChange>[]) => void): IDisposable {\n\tlet _previousValue: T | undefined;\n\treturn autorunWithStoreHandleChanges({\n\t\tcreateEmptyChangeSummary: () => ({ deltas: [] as RemoveUndefined<TChange>[], didChange: false }),\n\t\thandleChange: (context, changeSummary) => {\n\t\t\tif (context.didChange(observable)) {\n\t\t\t\tconst e = context.change;\n\t\t\t\tif (e !== undefined) {\n\t\t\t\t\tchangeSummary.deltas.push(e as RemoveUndefined<TChange>);\n\t\t\t\t}\n\t\t\t\tchangeSummary.didChange = true;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t}, (reader, changeSummary) => {\n\t\tconst value = observable.read(reader);\n\t\tconst previousValue = _previousValue;\n\t\tif (changeSummary.didChange) {\n\t\t\t_previousValue = value;\n\t\t\tcb(value, previousValue, changeSummary.deltas);\n\t\t}\n\t});\n}\n\nexport function runOnChangeWithStore<T, TChange>(observable: IObservable<T, TChange>, cb: (value: T, previousValue: undefined | T, deltas: RemoveUndefined<TChange>[], store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = runOnChange(observable, (value, previousValue: undefined | T, deltas) => {\n\t\tstore.clear();\n\t\tcb(value, previousValue, deltas, store);\n\t});\n\treturn {\n\t\tdispose() {\n\t\t\tdisposable.dispose();\n\t\t\tstore.dispose();\n\t\t}\n\t};\n}\n"],
  "mappings": "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",
  "names": ["observableFromEvent", "tx", "debouncedObservable"]
}
