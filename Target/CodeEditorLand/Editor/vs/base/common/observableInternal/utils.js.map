{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/observableInternal/utils.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\tautorun,\n\tautorunOpts,\n\tautorunWithStoreHandleChanges,\n} from \"./autorun.js\";\nimport {\n\tBaseObservable,\n\tConvenientObservable,\n\ttype IObservable,\n\ttype IObserver,\n\ttype IReader,\n\ttype ITransaction,\n\t_setKeepObserved,\n\t_setRecomputeInitiallyAndOnChange,\n\tobservableValue,\n\tsubtransaction,\n\ttransaction,\n} from \"./base.js\";\nimport {\n\tBugIndicatingError,\n\tDisposableStore,\n\ttype EqualityComparer,\n\tEvent,\n\ttype IDisposable,\n\ttype IValueWithChangeEvent,\n\tstrictEquals,\n\ttoDisposable,\n} from \"./commonFacade/deps.js\";\nimport {\n\tDebugNameData,\n\ttype DebugOwner,\n\ttype IDebugNameData,\n\tgetDebugName,\n} from \"./debugName.js\";\nimport { derived, derivedOpts } from \"./derived.js\";\nimport { getLogger } from \"./logging.js\";\n\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable<T>(value: T): IObservable<T> {\n\treturn new ConstObservable(value);\n}\n\nclass ConstObservable<T> extends ConvenientObservable<T, void> {\n\tconstructor(private readonly value: T) {\n\t\tsuper();\n\t}\n\n\tpublic override get debugName(): string {\n\t\treturn this.toString();\n\t}\n\n\tpublic get(): T {\n\t\treturn this.value;\n\t}\n\tpublic addObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\tpublic removeObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\n\toverride toString(): string {\n\t\treturn `Const: ${this.value}`;\n\t}\n}\n\nexport function observableFromPromise<T>(\n\tpromise: Promise<T>,\n): IObservable<{ value?: T }> {\n\tconst observable = observableValue<{ value?: T }>(\"promiseValue\", {});\n\tpromise.then((value) => {\n\t\tobservable.set({ value }, undefined);\n\t});\n\treturn observable;\n}\n\nexport function observableFromEvent<T, TArgs = unknown>(\n\towner: DebugOwner,\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T>;\nexport function observableFromEvent<T, TArgs = unknown>(\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T>;\nexport function observableFromEvent(\n\t...args:\n\t\t| [\n\t\t\t\towner: DebugOwner,\n\t\t\t\tevent: Event<any>,\n\t\t\t\tgetValue: (args: any | undefined) => any,\n\t\t  ]\n\t\t| [event: Event<any>, getValue: (args: any | undefined) => any]\n): IObservable<any> {\n\tlet owner;\n\tlet event;\n\tlet getValue;\n\tif (args.length === 3) {\n\t\t[owner, event, getValue] = args;\n\t} else {\n\t\t[event, getValue] = args;\n\t}\n\treturn new FromEventObservable(\n\t\tnew DebugNameData(owner, undefined, getValue),\n\t\tevent,\n\t\tgetValue,\n\t\t() => FromEventObservable.globalTransaction,\n\t\tstrictEquals,\n\t);\n}\n\nexport function observableFromEventOpts<T, TArgs = unknown>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t},\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T> {\n\treturn new FromEventObservable(\n\t\tnew DebugNameData(\n\t\t\toptions.owner,\n\t\t\toptions.debugName,\n\t\t\toptions.debugReferenceFn ?? getValue,\n\t\t),\n\t\tevent,\n\t\tgetValue,\n\t\t() => FromEventObservable.globalTransaction,\n\t\toptions.equalsFn ?? strictEquals,\n\t);\n}\n\nexport class FromEventObservable<TArgs, T> extends BaseObservable<T> {\n\tpublic static globalTransaction: ITransaction | undefined;\n\n\tprivate value: T | undefined;\n\tprivate hasValue = false;\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tprivate readonly event: Event<TArgs>,\n\t\tpublic readonly _getValue: (args: TArgs | undefined) => T,\n\t\tprivate readonly _getTransaction: () => ITransaction | undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate getDebugName(): string | undefined {\n\t\treturn this._debugNameData.getDebugName(this);\n\t}\n\n\tpublic get debugName(): string {\n\t\tconst name = this.getDebugName();\n\t\treturn \"From Event\" + (name ? `: ${name}` : \"\");\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = (args: TArgs | undefined) => {\n\t\tconst newValue = this._getValue(args);\n\t\tconst oldValue = this.value;\n\n\t\tconst didChange =\n\t\t\t!this.hasValue || !this._equalityComparator(oldValue!, newValue);\n\t\tlet didRunTransaction = false;\n\n\t\tif (didChange) {\n\t\t\tthis.value = newValue;\n\n\t\t\tif (this.hasValue) {\n\t\t\t\tdidRunTransaction = true;\n\t\t\t\tsubtransaction(\n\t\t\t\t\tthis._getTransaction(),\n\t\t\t\t\t(tx) => {\n\t\t\t\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, {\n\t\t\t\t\t\t\toldValue,\n\t\t\t\t\t\t\tnewValue,\n\t\t\t\t\t\t\tchange: undefined,\n\t\t\t\t\t\t\tdidChange,\n\t\t\t\t\t\t\thadValue: this.hasValue,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst name = this.getDebugName();\n\t\t\t\t\t\treturn \"Event fired\" + (name ? `: ${name}` : \"\");\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.hasValue = true;\n\t\t}\n\n\t\tif (!didRunTransaction) {\n\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, {\n\t\t\t\toldValue,\n\t\t\t\tnewValue,\n\t\t\t\tchange: undefined,\n\t\t\t\tdidChange,\n\t\t\t\thadValue: this.hasValue,\n\t\t\t});\n\t\t}\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t\tthis.hasValue = false;\n\t\tthis.value = undefined;\n\t}\n\n\tpublic get(): T {\n\t\tif (this.subscription) {\n\t\t\tif (!this.hasValue) {\n\t\t\t\tthis.handleEvent(undefined);\n\t\t\t}\n\t\t\treturn this.value!;\n\t\t} else {\n\t\t\t// no cache, as there are no subscribers to keep it updated\n\t\t\tconst value = this._getValue(undefined);\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nexport namespace observableFromEvent {\n\texport const Observer = FromEventObservable;\n\n\texport function batchEventsGlobally(\n\t\ttx: ITransaction,\n\t\tfn: () => void,\n\t): void {\n\t\tlet didSet = false;\n\t\tif (FromEventObservable.globalTransaction === undefined) {\n\t\t\tFromEventObservable.globalTransaction = tx;\n\t\t\tdidSet = true;\n\t\t}\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\t\t\tif (didSet) {\n\t\t\t\tFromEventObservable.globalTransaction = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function observableSignalFromEvent(\n\tdebugName: string,\n\tevent: Event<any>,\n): IObservable<void> {\n\treturn new FromEventObservableSignal(debugName, event);\n}\n\nclass FromEventObservableSignal extends BaseObservable<void> {\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tpublic readonly debugName: string,\n\t\tprivate readonly event: Event<any>,\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = () => {\n\t\ttransaction(\n\t\t\t(tx) => {\n\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\t() => this.debugName,\n\t\t);\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\n/**\n * Creates a signal that can be triggered to invalidate observers.\n * Signals don't have a value - when they are triggered they indicate a change.\n * However, signals can carry a delta that is passed to observers.\n */\nexport function observableSignal<TDelta = void>(\n\tdebugName: string,\n): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(\n\towner: object,\n): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(\n\tdebugNameOrOwner: string | object,\n): IObservableSignal<TDelta> {\n\tif (typeof debugNameOrOwner === \"string\") {\n\t\treturn new ObservableSignal<TDelta>(debugNameOrOwner);\n\t} else {\n\t\treturn new ObservableSignal<TDelta>(undefined, debugNameOrOwner);\n\t}\n}\n\nexport interface IObservableSignal<TChange> extends IObservable<void, TChange> {\n\ttrigger(tx: ITransaction | undefined, change: TChange): void;\n}\n\nclass ObservableSignal<TChange>\n\textends BaseObservable<void, TChange>\n\timplements IObservableSignal<TChange>\n{\n\tpublic get debugName() {\n\t\treturn (\n\t\t\tnew DebugNameData(\n\t\t\t\tthis._owner,\n\t\t\t\tthis._debugName,\n\t\t\t\tundefined,\n\t\t\t).getDebugName(this) ?? \"Observable Signal\"\n\t\t);\n\t}\n\n\tpublic override toString(): string {\n\t\treturn this.debugName;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | undefined,\n\t\tprivate readonly _owner?: object,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic trigger(tx: ITransaction | undefined, change: TChange): void {\n\t\tif (!tx) {\n\t\t\ttransaction(\n\t\t\t\t(tx) => {\n\t\t\t\t\tthis.trigger(tx, change);\n\t\t\t\t},\n\t\t\t\t() => `Trigger signal ${this.debugName}`,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const o of this.observers) {\n\t\t\ttx.updateObserver(o, this);\n\t\t\to.handleChange(this, change);\n\t\t}\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\nexport function signalFromObservable<T>(\n\towner: DebugOwner | undefined,\n\tobservable: IObservable<T>,\n): IObservable<void> {\n\treturn derivedOpts(\n\t\t{\n\t\t\towner,\n\t\t\tequalsFn: () => false,\n\t\t},\n\t\t(reader) => {\n\t\t\tobservable.read(reader);\n\t\t},\n\t);\n}\n\n/**\n * @deprecated Use `debouncedObservable2` instead.\n */\nexport function debouncedObservable<T>(\n\tobservable: IObservable<T>,\n\tdebounceMs: number,\n\tdisposableStore: DisposableStore,\n): IObservable<T | undefined> {\n\tconst debouncedObservable = observableValue<T | undefined>(\n\t\t\"debounced\",\n\t\tundefined,\n\t);\n\n\tlet timeout: any;\n\n\tdisposableStore.add(\n\t\tautorun((reader) => {\n\t\t\t/** @description debounce */\n\t\t\tconst value = observable.read(reader);\n\n\t\t\tif (timeout) {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t}\n\t\t\ttimeout = setTimeout(() => {\n\t\t\t\ttransaction((tx) => {\n\t\t\t\t\tdebouncedObservable.set(value, tx);\n\t\t\t\t});\n\t\t\t}, debounceMs);\n\t\t}),\n\t);\n\n\treturn debouncedObservable;\n}\n\n/**\n * Creates an observable that debounces the input observable.\n */\nexport function debouncedObservable2<T>(\n\tobservable: IObservable<T>,\n\tdebounceMs: number,\n): IObservable<T> {\n\tlet hasValue = false;\n\tlet lastValue: T | undefined;\n\n\tlet timeout: any;\n\n\treturn observableFromEvent<T, void>(\n\t\t(cb) => {\n\t\t\tconst d = autorun((reader) => {\n\t\t\t\tconst value = observable.read(reader);\n\n\t\t\t\tif (hasValue) {\n\t\t\t\t\tif (timeout) {\n\t\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\t}\n\t\t\t\t\ttimeout = setTimeout(() => {\n\t\t\t\t\t\tlastValue = value;\n\t\t\t\t\t\tcb();\n\t\t\t\t\t}, debounceMs);\n\t\t\t\t} else {\n\t\t\t\t\thasValue = true;\n\t\t\t\t\tlastValue = value;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\td.dispose();\n\t\t\t\t\thasValue = false;\n\t\t\t\t\tlastValue = undefined;\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t\t() => {\n\t\t\tif (hasValue) {\n\t\t\t\treturn lastValue!;\n\t\t\t} else {\n\t\t\t\treturn observable.get();\n\t\t\t}\n\t\t},\n\t);\n}\n\nexport function wasEventTriggeredRecently(\n\tevent: Event<any>,\n\ttimeoutMs: number,\n\tdisposableStore: DisposableStore,\n): IObservable<boolean> {\n\tconst observable = observableValue(\"triggeredRecently\", false);\n\n\tlet timeout: any;\n\n\tdisposableStore.add(\n\t\tevent(() => {\n\t\t\tobservable.set(true, undefined);\n\n\t\t\tif (timeout) {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t}\n\t\t\ttimeout = setTimeout(() => {\n\t\t\t\tobservable.set(false, undefined);\n\t\t\t}, timeoutMs);\n\t\t}),\n\t);\n\n\treturn observable;\n}\n\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved<T>(observable: IObservable<T>): IDisposable {\n\tconst o = new KeepAliveObserver(false, undefined);\n\tobservable.addObserver(o);\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setKeepObserved(keepObserved);\n\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange<T>(\n\tobservable: IObservable<T>,\n\thandleValue?: (value: T) => void,\n): IDisposable {\n\tconst o = new KeepAliveObserver(true, handleValue);\n\tobservable.addObserver(o);\n\tif (handleValue) {\n\t\thandleValue(observable.get());\n\t} else {\n\t\tobservable.reportChanges();\n\t}\n\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\n\nexport class KeepAliveObserver implements IObserver {\n\tprivate _counter = 0;\n\n\tconstructor(\n\t\tprivate readonly _forceRecompute: boolean,\n\t\tprivate readonly _handleValue: ((value: any) => void) | undefined,\n\t) {}\n\n\tbeginUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis._counter++;\n\t}\n\n\tendUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis._counter--;\n\t\tif (this._counter === 0 && this._forceRecompute) {\n\t\t\tif (this._handleValue) {\n\t\t\t\tthis._handleValue(observable.get());\n\t\t\t} else {\n\t\t\t\tobservable.reportChanges();\n\t\t\t}\n\t\t}\n\t}\n\n\thandlePossibleChange<T>(observable: IObservable<T, unknown>): void {\n\t\t// NO OP\n\t}\n\n\thandleChange<T, TChange>(\n\t\tobservable: IObservable<T, TChange>,\n\t\tchange: TChange,\n\t): void {\n\t\t// NO OP\n\t}\n}\n\nexport function derivedObservableWithCache<T>(\n\towner: DebugOwner,\n\tcomputeFn: (reader: IReader, lastValue: T | undefined) => T,\n): IObservable<T> {\n\tlet lastValue: T | undefined;\n\tconst observable = derivedOpts(\n\t\t{ owner, debugReferenceFn: computeFn },\n\t\t(reader) => {\n\t\t\tlastValue = computeFn(reader, lastValue);\n\t\t\treturn lastValue;\n\t\t},\n\t);\n\treturn observable;\n}\n\nexport function derivedObservableWithWritableCache<T>(\n\towner: object,\n\tcomputeFn: (reader: IReader, lastValue: T | undefined) => T,\n): IObservable<T> & {\n\tclearCache(transaction: ITransaction): void;\n\tsetCache(newValue: T | undefined, tx: ITransaction | undefined): void;\n} {\n\tlet lastValue: T | undefined;\n\tconst onChange = observableSignal(\"derivedObservableWithWritableCache\");\n\tconst observable = derived(owner, (reader) => {\n\t\tonChange.read(reader);\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn Object.assign(observable, {\n\t\tclearCache: (tx: ITransaction) => {\n\t\t\tlastValue = undefined;\n\t\t\tonChange.trigger(tx);\n\t\t},\n\t\tsetCache: (newValue: T | undefined, tx: ITransaction | undefined) => {\n\t\t\tlastValue = newValue;\n\t\t\tonChange.trigger(tx);\n\t\t},\n\t});\n}\n\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached<TIn, TOut, TKey = TIn>(\n\towner: DebugOwner,\n\titems: IObservable<readonly TIn[]>,\n\tmap: (input: TIn, store: DisposableStore) => TOut,\n\tkeySelector?: (input: TIn) => TKey,\n): IObservable<readonly TOut[]> {\n\tlet m = new ArrayMap(map, keySelector);\n\tconst self = derivedOpts(\n\t\t{\n\t\t\tdebugReferenceFn: map,\n\t\t\towner,\n\t\t\tonLastObserverRemoved: () => {\n\t\t\t\tm.dispose();\n\t\t\t\tm = new ArrayMap(map);\n\t\t\t},\n\t\t},\n\t\t(reader) => {\n\t\t\tm.setItems(items.read(reader));\n\t\t\treturn m.getItems();\n\t\t},\n\t);\n\treturn self;\n}\n\nclass ArrayMap<TIn, TOut, TKey> implements IDisposable {\n\tprivate readonly _cache = new Map<\n\t\tTKey,\n\t\t{ out: TOut; store: DisposableStore }\n\t>();\n\tprivate _items: TOut[] = [];\n\tconstructor(\n\t\tprivate readonly _map: (input: TIn, store: DisposableStore) => TOut,\n\t\tprivate readonly _keySelector?: (input: TIn) => TKey,\n\t) {}\n\n\tpublic dispose(): void {\n\t\tthis._cache.forEach((entry) => entry.store.dispose());\n\t\tthis._cache.clear();\n\t}\n\n\tpublic setItems(items: readonly TIn[]): void {\n\t\tconst newItems: TOut[] = [];\n\t\tconst itemsToRemove = new Set(this._cache.keys());\n\n\t\tfor (const item of items) {\n\t\t\tconst key = this._keySelector\n\t\t\t\t? this._keySelector(item)\n\t\t\t\t: (item as unknown as TKey);\n\n\t\t\tlet entry = this._cache.get(key);\n\t\t\tif (entry) {\n\t\t\t\titemsToRemove.delete(key);\n\t\t\t} else {\n\t\t\t\tconst store = new DisposableStore();\n\t\t\t\tconst out = this._map(item, store);\n\t\t\t\tentry = { out, store };\n\t\t\t\tthis._cache.set(key, entry);\n\t\t\t}\n\t\t\tnewItems.push(entry.out);\n\t\t}\n\n\t\tfor (const item of itemsToRemove) {\n\t\t\tconst entry = this._cache.get(item)!;\n\t\t\tentry.store.dispose();\n\t\t\tthis._cache.delete(item);\n\t\t}\n\n\t\tthis._items = newItems;\n\t}\n\n\tpublic getItems(): TOut[] {\n\t\treturn this._items;\n\t}\n}\n\nexport class ValueWithChangeEventFromObservable<T>\n\timplements IValueWithChangeEvent<T>\n{\n\tconstructor(public readonly observable: IObservable<T>) {}\n\n\tget onDidChange(): Event<void> {\n\t\treturn Event.fromObservableLight(this.observable);\n\t}\n\n\tget value(): T {\n\t\treturn this.observable.get();\n\t}\n}\n\nexport function observableFromValueWithChangeEvent<T>(\n\towner: DebugOwner,\n\tvalue: IValueWithChangeEvent<T>,\n): IObservable<T> {\n\tif (value instanceof ValueWithChangeEventFromObservable) {\n\t\treturn value.observable;\n\t}\n\treturn observableFromEvent(owner, value.onDidChange, () => value.value);\n}\n\n/**\n * Creates an observable that has the latest changed value of the given observables.\n * Initially (and when not observed), it has the value of the last observable.\n * When observed and any of the observables change, it has the value of the last changed observable.\n * If multiple observables change in the same transaction, the last observable wins.\n */\nexport function latestChangedValue<T extends IObservable<any>[]>(\n\towner: DebugOwner,\n\tobservables: T,\n): IObservable<ReturnType<T[number][\"get\"]>> {\n\tif (observables.length === 0) {\n\t\tthrow new BugIndicatingError();\n\t}\n\n\tlet hasLastChangedValue = false;\n\tlet lastChangedValue: any;\n\n\tconst result = observableFromEvent<any, void>(\n\t\towner,\n\t\t(cb) => {\n\t\t\tconst store = new DisposableStore();\n\t\t\tfor (const o of observables) {\n\t\t\t\tstore.add(\n\t\t\t\t\tautorunOpts(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdebugName: () =>\n\t\t\t\t\t\t\t\tgetDebugName(\n\t\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\t\tnew DebugNameData(\n\t\t\t\t\t\t\t\t\t\towner,\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t) + \".updateLastChangedValue\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(reader) => {\n\t\t\t\t\t\t\thasLastChangedValue = true;\n\t\t\t\t\t\t\tlastChangedValue = o.read(reader);\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t\tstore.add({\n\t\t\t\tdispose() {\n\t\t\t\t\thasLastChangedValue = false;\n\t\t\t\t\tlastChangedValue = undefined;\n\t\t\t\t},\n\t\t\t});\n\t\t\treturn store;\n\t\t},\n\t\t() => {\n\t\t\tif (hasLastChangedValue) {\n\t\t\t\treturn lastChangedValue;\n\t\t\t} else {\n\t\t\t\treturn observables[observables.length - 1].get();\n\t\t\t}\n\t\t},\n\t);\n\treturn result;\n}\n\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n */\nexport function derivedConstOnceDefined<T>(\n\towner: DebugOwner,\n\tfn: (reader: IReader) => T,\n): IObservable<T | undefined> {\n\treturn derivedObservableWithCache<T | undefined>(\n\t\towner,\n\t\t(reader, lastValue) => lastValue ?? fn(reader),\n\t);\n}\n\ntype RemoveUndefined<T> = T extends undefined ? never : T;\n\nexport function runOnChange<T, TChange>(\n\tobservable: IObservable<T, TChange>,\n\tcb: (\n\t\tvalue: T,\n\t\tpreviousValue: undefined | T,\n\t\tdeltas: RemoveUndefined<TChange>[],\n\t) => void,\n): IDisposable {\n\tlet _previousValue: T | undefined;\n\treturn autorunWithStoreHandleChanges(\n\t\t{\n\t\t\tcreateEmptyChangeSummary: () => ({\n\t\t\t\tdeltas: [] as RemoveUndefined<TChange>[],\n\t\t\t\tdidChange: false,\n\t\t\t}),\n\t\t\thandleChange: (context, changeSummary) => {\n\t\t\t\tif (context.didChange(observable)) {\n\t\t\t\t\tconst e = context.change;\n\t\t\t\t\tif (e !== undefined) {\n\t\t\t\t\t\tchangeSummary.deltas.push(\n\t\t\t\t\t\t\te as RemoveUndefined<TChange>,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tchangeSummary.didChange = true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\t},\n\t\t(reader, changeSummary) => {\n\t\t\tconst value = observable.read(reader);\n\t\t\tconst previousValue = _previousValue;\n\t\t\tif (changeSummary.didChange) {\n\t\t\t\t_previousValue = value;\n\t\t\t\tcb(value, previousValue, changeSummary.deltas);\n\t\t\t}\n\t\t},\n\t);\n}\n\nexport function runOnChangeWithStore<T, TChange>(\n\tobservable: IObservable<T, TChange>,\n\tcb: (\n\t\tvalue: T,\n\t\tpreviousValue: undefined | T,\n\t\tdeltas: RemoveUndefined<TChange>[],\n\t\tstore: DisposableStore,\n\t) => void,\n): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = runOnChange(\n\t\tobservable,\n\t\t(value, previousValue: undefined | T, deltas) => {\n\t\t\tstore.clear();\n\t\t\tcb(value, previousValue, deltas, store);\n\t\t},\n\t);\n\treturn {\n\t\tdispose() {\n\t\t\tdisposable.dispose();\n\t\t\tstore.dispose();\n\t\t},\n\t};\n}\n"],
  "mappings": "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",
  "names": ["observableFromEvent", "tx", "debouncedObservable"]
}
