import{assertFn as m}from"../../../../vs/base/common/assert.js";import{strictEquals as s}from"../../../../vs/base/common/equals.js";import{DisposableStore as l}from"../../../../vs/base/common/lifecycle.js";import{_setDerivedOpts as p,BaseObservable as b}from"../../../../vs/base/common/observableInternal/base.js";import{DebugNameData as o}from"../../../../vs/base/common/observableInternal/debugName.js";import{getLogger as v}from"../../../../vs/base/common/observableInternal/logging.js";function H(n,r){return r!==void 0?new u(new o(n,void 0,r),r,void 0,void 0,void 0,s):new u(new o(void 0,void 0,n),n,void 0,void 0,void 0,s)}function F(n,r,e){return new g(new o(n,void 0,r),r,void 0,void 0,void 0,s,e)}function c(n,r){return new u(new o(n.owner,n.debugName,n.debugReferenceFn),r,void 0,void 0,n.onLastObserverRemoved,n.equalsFn??s)}p(c);function M(n,r){return new u(new o(n.owner,n.debugName,void 0),r,n.createEmptyChangeSummary,n.handleChange,void 0,n.equalityComparer??s)}function W(n,r){let e,t;r===void 0?(e=n,t=void 0):(t=n,e=r);const a=new l;return new u(new o(t,void 0,e),i=>(a.clear(),e(i,a)),void 0,void 0,()=>a.dispose(),s)}function P(n,r){let e,t;r===void 0?(e=n,t=void 0):(t=n,e=r);let a;return new u(new o(t,void 0,e),i=>{a?a.clear():a=new l;const d=e(i);return d&&a.add(d),d},void 0,void 0,()=>{a&&(a.dispose(),a=void 0)},s)}var f=(a=>(a[a.initial=0]="initial",a[a.dependenciesMightHaveChanged=1]="dependenciesMightHaveChanged",a[a.stale=2]="stale",a[a.upToDate=3]="upToDate",a))(f||{});class u extends b{constructor(e,t,a,i,d=void 0,h){super();this._debugNameData=e;this._computeFn=t;this.createChangeSummary=a;this._handleChange=i;this._handleLastObserverRemoved=d;this._equalityComparator=h;this.changeSummary=this.createChangeSummary?.(),v()?.handleDerivedCreated(this)}state=0;value=void 0;updateCount=0;dependencies=new Set;dependenciesToBeRemoved=new Set;changeSummary=void 0;get debugName(){return this._debugNameData.getDebugName(this)??"(anonymous)"}onLastObserverRemoved(){this.state=0,this.value=void 0;for(const e of this.dependencies)e.removeObserver(this);this.dependencies.clear(),this._handleLastObserverRemoved?.()}get(){if(this.observers.size===0){const e=this._computeFn(this,this.createChangeSummary?.());return this.onLastObserverRemoved(),e}else{do{if(this.state===1){for(const e of this.dependencies)if(e.reportChanges(),this.state===2)break}this.state===1&&(this.state=3),this._recomputeIfNeeded()}while(this.state!==3);return this.value}}_recomputeIfNeeded(){if(this.state===3)return;const e=this.dependenciesToBeRemoved;this.dependenciesToBeRemoved=this.dependencies,this.dependencies=e;const t=this.state!==0,a=this.value;this.state=3;const i=this.changeSummary;this.changeSummary=this.createChangeSummary?.();try{this.value=this._computeFn(this,i)}finally{for(const h of this.dependenciesToBeRemoved)h.removeObserver(this);this.dependenciesToBeRemoved.clear()}const d=t&&!this._equalityComparator(a,this.value);if(v()?.handleDerivedRecomputed(this,{oldValue:a,newValue:this.value,change:void 0,didChange:d,hadValue:t}),d)for(const h of this.observers)h.handleChange(this,void 0)}toString(){return`LazyDerived<${this.debugName}>`}beginUpdate(e){this.updateCount++;const t=this.updateCount===1;if(this.state===3&&(this.state=1,!t))for(const a of this.observers)a.handlePossibleChange(this);if(t)for(const a of this.observers)a.beginUpdate(this)}endUpdate(e){if(this.updateCount--,this.updateCount===0){const t=[...this.observers];for(const a of t)a.endUpdate(this)}m(()=>this.updateCount>=0)}handlePossibleChange(e){if(this.state===3&&this.dependencies.has(e)&&!this.dependenciesToBeRemoved.has(e)){this.state=1;for(const t of this.observers)t.handlePossibleChange(this)}}handleChange(e,t){if(this.dependencies.has(e)&&!this.dependenciesToBeRemoved.has(e)){const a=this._handleChange?this._handleChange({changedObservable:e,change:t,didChange:d=>d===e},this.changeSummary):!0,i=this.state===3;if(a&&(this.state===1||i)&&(this.state=2,i))for(const d of this.observers)d.handlePossibleChange(this)}}readObservable(e){e.addObserver(this);const t=e.get();return this.dependencies.add(e),this.dependenciesToBeRemoved.delete(e),t}addObserver(e){const t=!this.observers.has(e)&&this.updateCount>0;super.addObserver(e),t&&e.beginUpdate(this)}removeObserver(e){const t=this.observers.has(e)&&this.updateCount>0;super.removeObserver(e),t&&e.endUpdate(this)}}class g extends u{constructor(e,t,a,i,d=void 0,h,T){super(e,t,a,i,d,h);this.set=T}}export{u as Derived,g as DerivedWithSetter,H as derived,P as derivedDisposable,M as derivedHandleChanges,c as derivedOpts,F as derivedWithSetter,W as derivedWithStore};
