{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/observableInternal/autorun.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChangeContext, IObservable, IObserver, IReader } from './base.js';\nimport { DebugNameData, IDebugNameData } from './debugName.js';\nimport { assertFn, DisposableStore, IDisposable, markAsDisposed, onBugIndicatingError, toDisposable, trackDisposable } from './commonFacade/deps.js';\nimport { getLogger } from './logging.js';\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn: (reader: IReader) => void): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(undefined, undefined, fn),\n\t\tfn,\n\t\tundefined,\n\t\tundefined\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options: IDebugNameData & {}, fn: (reader: IReader) => void): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\tundefined,\n\t\tundefined\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary?: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary) => void\n): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\toptions.createEmptyChangeSummary,\n\t\toptions.handleChange\n\t);\n}\n\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary?: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary, store: DisposableStore) => void\n): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunHandleChanges(\n\t\t{\n\t\t\towner: options.owner,\n\t\t\tdebugName: options.debugName,\n\t\t\tdebugReferenceFn: options.debugReferenceFn ?? fn,\n\t\t\tcreateEmptyChangeSummary: options.createEmptyChangeSummary,\n\t\t\thandleChange: options.handleChange,\n\t\t},\n\t\t(reader, changeSummary) => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, changeSummary, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStore(fn: (reader: IReader, store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunOpts(\n\t\t{\n\t\t\towner: undefined,\n\t\t\tdebugName: undefined,\n\t\t\tdebugReferenceFn: fn,\n\t\t},\n\t\treader => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\nexport function autorunDelta<T>(\n\tobservable: IObservable<T>,\n\thandler: (args: { lastValue: T | undefined; newValue: T }) => void\n): IDisposable {\n\tlet _lastValue: T | undefined;\n\treturn autorunOpts({ debugReferenceFn: handler }, (reader) => {\n\t\tconst newValue = observable.read(reader);\n\t\tconst lastValue = _lastValue;\n\t\t_lastValue = newValue;\n\t\thandler({ lastValue, newValue });\n\t});\n}\n\n\nconst enum AutorunState {\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t */\n\tstale = 2,\n\tupToDate = 3,\n}\n\nexport class AutorunObserver<TChangeSummary = any> implements IObserver, IReader, IDisposable {\n\tprivate state = AutorunState.stale;\n\tprivate updateCount = 0;\n\tprivate disposed = false;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined;\n\n\tpublic get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tpublic readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _runFn: (reader: IReader, changeSummary: TChangeSummary) => void,\n\t\tprivate readonly createChangeSummary: (() => TChangeSummary) | undefined,\n\t\tprivate readonly _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t) {\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleAutorunCreated(this);\n\t\tthis._runIfNeeded();\n\n\t\ttrackDisposable(this);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.disposed = true;\n\t\tfor (const o of this.dependencies) {\n\t\t\to.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\n\t\tmarkAsDisposed(this);\n\t}\n\n\tprivate _runIfNeeded() {\n\t\tif (this.state === AutorunState.upToDate) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tthis.state = AutorunState.upToDate;\n\n\t\tconst isDisposed = this.disposed;\n\t\ttry {\n\t\t\tif (!isDisposed) {\n\t\t\t\tgetLogger()?.handleAutorunTriggered(this);\n\t\t\t\tconst changeSummary = this.changeSummary!;\n\t\t\t\ttry {\n\t\t\t\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\t\t\t\tthis._runFn(this, changeSummary);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonBugIndicatingError(e);\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif (!isDisposed) {\n\t\t\t\tgetLogger()?.handleAutorunFinished(this);\n\t\t\t}\n\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\to.removeObserver(this);\n\t\t\t}\n\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t}\n\t}\n\n\tpublic toString(): string {\n\t\treturn `Autorun<${this.debugName}>`;\n\t}\n\n\t// IObserver implementation\n\tpublic beginUpdate(): void {\n\t\tif (this.state === AutorunState.upToDate) {\n\t\t\tthis.state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t\tthis.updateCount++;\n\t}\n\n\tpublic endUpdate(): void {\n\t\ttry {\n\t\t\tif (this.updateCount === 1) {\n\t\t\t\tdo {\n\t\t\t\t\tif (this.state === AutorunState.dependenciesMightHaveChanged) {\n\t\t\t\t\t\tthis.state = AutorunState.upToDate;\n\t\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\t\td.reportChanges();\n\t\t\t\t\t\t\tif (this.state as AutorunState === AutorunState.stale) {\n\t\t\t\t\t\t\t\t// The other dependencies will refresh on demand\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._runIfNeeded();\n\t\t\t\t} while (this.state !== AutorunState.upToDate);\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.updateCount--;\n\t\t}\n\n\t\tassertFn(() => this.updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange(observable: IObservable<any>): void {\n\t\tif (this.state === AutorunState.upToDate && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis.state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\tif (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\ttry {\n\t\t\t\tconst shouldReact = this._handleChange ? this._handleChange({\n\t\t\t\t\tchangedObservable: observable,\n\t\t\t\t\tchange,\n\t\t\t\t\tdidChange: (o): this is any => o === observable as any,\n\t\t\t\t}, this.changeSummary!) : true;\n\t\t\t\tif (shouldReact) {\n\t\t\t\t\tthis.state = AutorunState.stale;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonBugIndicatingError(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader implementation\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\t// In case the run action disposes the autorun\n\t\tif (this.disposed) {\n\t\t\treturn observable.get();\n\t\t}\n\n\t\tobservable.addObserver(this);\n\t\tconst value = observable.get();\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n}\n\nexport namespace autorun {\n\texport const Observer = AutorunObserver;\n}\n"],
  "mappings": ";;AAKA,SAAS,gBAAgB,aAAa,WAAW,eAAe;AAChE,SAAS,eAAe,sBAAsB;AAC9C,SAAS,UAAU,iBAAiB,aAAa,gBAAgB,sBAAsB,cAAc,uBAAuB;AAC5H,SAAS,iBAAiB;AAMnB,SAAS,QAAQ,IAA4C;AACnE,SAAO,IAAI;AAAA,IACV,IAAI,cAAc,QAAW,QAAW,EAAE;AAAA,IAC1C;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;AAPgB;AAaT,SAAS,YAAY,SAA8B,IAA4C;AACrG,SAAO,IAAI;AAAA,IACV,IAAI,cAAc,QAAQ,OAAO,QAAQ,WAAW,QAAQ,oBAAoB,EAAE;AAAA,IAClF;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;AAPgB;AAoBT,SAAS,qBACf,SAIA,IACc;AACd,SAAO,IAAI;AAAA,IACV,IAAI,cAAc,QAAQ,OAAO,QAAQ,WAAW,QAAQ,oBAAoB,EAAE;AAAA,IAClF;AAAA,IACA,QAAQ;AAAA,IACR,QAAQ;AAAA,EACT;AACD;AAbgB;AAkBT,SAAS,8BACf,SAIA,IACc;AACd,QAAM,QAAQ,IAAI,gBAAgB;AAClC,QAAM,aAAa;AAAA,IAClB;AAAA,MACC,OAAO,QAAQ;AAAA,MACf,WAAW,QAAQ;AAAA,MACnB,kBAAkB,QAAQ,oBAAoB;AAAA,MAC9C,0BAA0B,QAAQ;AAAA,MAClC,cAAc,QAAQ;AAAA,IACvB;AAAA,IACA,CAAC,QAAQ,kBAAkB;AAC1B,YAAM,MAAM;AACZ,SAAG,QAAQ,eAAe,KAAK;AAAA,IAChC;AAAA,EACD;AACA,SAAO,aAAa,MAAM;AACzB,eAAW,QAAQ;AACnB,UAAM,QAAQ;AAAA,EACf,CAAC;AACF;AAzBgB;AA8BT,SAAS,iBAAiB,IAAoE;AACpG,QAAM,QAAQ,IAAI,gBAAgB;AAClC,QAAM,aAAa;AAAA,IAClB;AAAA,MACC,OAAO;AAAA,MACP,WAAW;AAAA,MACX,kBAAkB;AAAA,IACnB;AAAA,IACA,YAAU;AACT,YAAM,MAAM;AACZ,SAAG,QAAQ,KAAK;AAAA,IACjB;AAAA,EACD;AACA,SAAO,aAAa,MAAM;AACzB,eAAW,QAAQ;AACnB,UAAM,QAAQ;AAAA,EACf,CAAC;AACF;AAjBgB;AAmBT,SAAS,aACf,YACA,SACc;AACd,MAAI;AACJ,SAAO,YAAY,EAAE,kBAAkB,QAAQ,GAAG,CAAC,WAAW;AAC7D,UAAM,WAAW,WAAW,KAAK,MAAM;AACvC,UAAM,YAAY;AAClB,iBAAa;AACb,YAAQ,EAAE,WAAW,SAAS,CAAC;AAAA,EAChC,CAAC;AACF;AAXgB;AAchB,IAAW,eAAX,kBAAWA,kBAAX;AAKC,EAAAA,4BAAA,kCAA+B,KAA/B;AAKA,EAAAA,4BAAA,WAAQ,KAAR;AACA,EAAAA,4BAAA,cAAW,KAAX;AAXU,SAAAA;AAAA,GAAA;AAcJ,MAAM,gBAAiF;AAAA,EAY7F,YACiB,gBACA,QACC,qBACA,eAChB;AAJe;AACA;AACC;AACA;AAEjB,SAAK,gBAAgB,KAAK,sBAAsB;AAChD,cAAU,GAAG,qBAAqB,IAAI;AACtC,SAAK,aAAa;AAElB,oBAAgB,IAAI;AAAA,EACrB;AAAA,EArKD,OA8I8F;AAAA;AAAA;AAAA,EACrF,QAAQ;AAAA,EACR,cAAc;AAAA,EACd,WAAW;AAAA,EACX,eAAe,oBAAI,IAAsB;AAAA,EACzC,0BAA0B,oBAAI,IAAsB;AAAA,EACpD;AAAA,EAER,IAAW,YAAoB;AAC9B,WAAO,KAAK,eAAe,aAAa,IAAI,KAAK;AAAA,EAClD;AAAA,EAeO,UAAgB;AACtB,SAAK,WAAW;AAChB,eAAW,KAAK,KAAK,cAAc;AAClC,QAAE,eAAe,IAAI;AAAA,IACtB;AACA,SAAK,aAAa,MAAM;AAExB,mBAAe,IAAI;AAAA,EACpB;AAAA,EAEQ,eAAe;AACtB,QAAI,KAAK,UAAU,kBAAuB;AACzC;AAAA,IACD;AAEA,UAAM,WAAW,KAAK;AACtB,SAAK,0BAA0B,KAAK;AACpC,SAAK,eAAe;AAEpB,SAAK,QAAQ;AAEb,UAAM,aAAa,KAAK;AACxB,QAAI;AACH,UAAI,CAAC,YAAY;AAChB,kBAAU,GAAG,uBAAuB,IAAI;AACxC,cAAM,gBAAgB,KAAK;AAC3B,YAAI;AACH,eAAK,gBAAgB,KAAK,sBAAsB;AAChD,eAAK,OAAO,MAAM,aAAa;AAAA,QAChC,SAAS,GAAG;AACX,+BAAqB,CAAC;AAAA,QACvB;AAAA,MACD;AAAA,IACD,UAAE;AACD,UAAI,CAAC,YAAY;AAChB,kBAAU,GAAG,sBAAsB,IAAI;AAAA,MACxC;AAGA,iBAAW,KAAK,KAAK,yBAAyB;AAC7C,UAAE,eAAe,IAAI;AAAA,MACtB;AACA,WAAK,wBAAwB,MAAM;AAAA,IACpC;AAAA,EACD;AAAA,EAEO,WAAmB;AACzB,WAAO,WAAW,KAAK,SAAS;AAAA,EACjC;AAAA;AAAA,EAGO,cAAoB;AAC1B,QAAI,KAAK,UAAU,kBAAuB;AACzC,WAAK,QAAQ;AAAA,IACd;AACA,SAAK;AAAA,EACN;AAAA,EAEO,YAAkB;AACxB,QAAI;AACH,UAAI,KAAK,gBAAgB,GAAG;AAC3B,WAAG;AACF,cAAI,KAAK,UAAU,sCAA2C;AAC7D,iBAAK,QAAQ;AACb,uBAAW,KAAK,KAAK,cAAc;AAClC,gBAAE,cAAc;AAChB,kBAAI,KAAK,UAA0B,eAAoB;AAEtD;AAAA,cACD;AAAA,YACD;AAAA,UACD;AAEA,eAAK,aAAa;AAAA,QACnB,SAAS,KAAK,UAAU;AAAA,MACzB;AAAA,IACD,UAAE;AACD,WAAK;AAAA,IACN;AAEA,aAAS,MAAM,KAAK,eAAe,CAAC;AAAA,EACrC;AAAA,EAEO,qBAAqB,YAAoC;AAC/D,QAAI,KAAK,UAAU,oBAAyB,KAAK,aAAa,IAAI,UAAU,KAAK,CAAC,KAAK,wBAAwB,IAAI,UAAU,GAAG;AAC/H,WAAK,QAAQ;AAAA,IACd;AAAA,EACD;AAAA,EAEO,aAAyB,YAAqC,QAAuB;AAC3F,QAAI,KAAK,aAAa,IAAI,UAAU,KAAK,CAAC,KAAK,wBAAwB,IAAI,UAAU,GAAG;AACvF,UAAI;AACH,cAAM,cAAc,KAAK,gBAAgB,KAAK,cAAc;AAAA,UAC3D,mBAAmB;AAAA,UACnB;AAAA,UACA,WAAW,wBAAC,MAAmB,MAAM,YAA1B;AAAA,QACZ,GAAG,KAAK,aAAc,IAAI;AAC1B,YAAI,aAAa;AAChB,eAAK,QAAQ;AAAA,QACd;AAAA,MACD,SAAS,GAAG;AACX,6BAAqB,CAAC;AAAA,MACvB;AAAA,IACD;AAAA,EACD;AAAA;AAAA,EAGO,eAAkB,YAA+B;AAEvD,QAAI,KAAK,UAAU;AAClB,aAAO,WAAW,IAAI;AAAA,IACvB;AAEA,eAAW,YAAY,IAAI;AAC3B,UAAM,QAAQ,WAAW,IAAI;AAC7B,SAAK,aAAa,IAAI,UAAU;AAChC,SAAK,wBAAwB,OAAO,UAAU;AAC9C,WAAO;AAAA,EACR;AACD;AAAA,CAEO,CAAUC,aAAV;AACC,EAAMA,SAAA,WAAW;AAAA,GADR;",
  "names": ["AutorunState", "autorun"]
}
