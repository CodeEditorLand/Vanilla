{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/observableInternal/autorun.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type {\n\tIChangeContext,\n\tIObservable,\n\tIObserver,\n\tIReader,\n} from \"./base.js\";\nimport {\n\tDisposableStore,\n\ttype IDisposable,\n\tassertFn,\n\tmarkAsDisposed,\n\tonBugIndicatingError,\n\ttoDisposable,\n\ttrackDisposable,\n} from \"./commonFacade/deps.js\";\nimport { DebugNameData, type IDebugNameData } from \"./debugName.js\";\nimport { getLogger } from \"./logging.js\";\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn: (reader: IReader) => void): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(undefined, undefined, fn),\n\t\tfn,\n\t\tundefined,\n\t\tundefined,\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(\n\toptions: IDebugNameData & {},\n\tfn: (reader: IReader) => void,\n): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(\n\t\t\toptions.owner,\n\t\t\toptions.debugName,\n\t\t\toptions.debugReferenceFn ?? fn,\n\t\t),\n\t\tfn,\n\t\tundefined,\n\t\tundefined,\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary?: () => TChangeSummary;\n\t\thandleChange: (\n\t\t\tcontext: IChangeContext,\n\t\t\tchangeSummary: TChangeSummary,\n\t\t) => boolean;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary) => void,\n): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(\n\t\t\toptions.owner,\n\t\t\toptions.debugName,\n\t\t\toptions.debugReferenceFn ?? fn,\n\t\t),\n\t\tfn,\n\t\toptions.createEmptyChangeSummary,\n\t\toptions.handleChange,\n\t);\n}\n\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary?: () => TChangeSummary;\n\t\thandleChange: (\n\t\t\tcontext: IChangeContext,\n\t\t\tchangeSummary: TChangeSummary,\n\t\t) => boolean;\n\t},\n\tfn: (\n\t\treader: IReader,\n\t\tchangeSummary: TChangeSummary,\n\t\tstore: DisposableStore,\n\t) => void,\n): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunHandleChanges(\n\t\t{\n\t\t\towner: options.owner,\n\t\t\tdebugName: options.debugName,\n\t\t\tdebugReferenceFn: options.debugReferenceFn ?? fn,\n\t\t\tcreateEmptyChangeSummary: options.createEmptyChangeSummary,\n\t\t\thandleChange: options.handleChange,\n\t\t},\n\t\t(reader, changeSummary) => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, changeSummary, store);\n\t\t},\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStore(\n\tfn: (reader: IReader, store: DisposableStore) => void,\n): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunOpts(\n\t\t{\n\t\t\towner: undefined,\n\t\t\tdebugName: undefined,\n\t\t\tdebugReferenceFn: fn,\n\t\t},\n\t\t(reader) => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, store);\n\t\t},\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\nexport function autorunDelta<T>(\n\tobservable: IObservable<T>,\n\thandler: (args: { lastValue: T | undefined; newValue: T }) => void,\n): IDisposable {\n\tlet _lastValue: T | undefined;\n\treturn autorunOpts({ debugReferenceFn: handler }, (reader) => {\n\t\tconst newValue = observable.read(reader);\n\t\tconst lastValue = _lastValue;\n\t\t_lastValue = newValue;\n\t\thandler({ lastValue, newValue });\n\t});\n}\n\nenum AutorunState {\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t */\n\tstale = 2,\n\tupToDate = 3,\n}\n\nexport class AutorunObserver<TChangeSummary = any>\n\timplements IObserver, IReader, IDisposable\n{\n\tprivate state = AutorunState.stale;\n\tprivate updateCount = 0;\n\tprivate disposed = false;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined;\n\n\tpublic get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? \"(anonymous)\";\n\t}\n\n\tconstructor(\n\t\tpublic readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _runFn: (\n\t\t\treader: IReader,\n\t\t\tchangeSummary: TChangeSummary,\n\t\t) => void,\n\t\tprivate readonly createChangeSummary:\n\t\t\t| (() => TChangeSummary)\n\t\t\t| undefined,\n\t\tprivate readonly _handleChange:\n\t\t\t| ((context: IChangeContext, summary: TChangeSummary) => boolean)\n\t\t\t| undefined,\n\t) {\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleAutorunCreated(this);\n\t\tthis._runIfNeeded();\n\n\t\ttrackDisposable(this);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.disposed = true;\n\t\tfor (const o of this.dependencies) {\n\t\t\to.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\n\t\tmarkAsDisposed(this);\n\t}\n\n\tprivate _runIfNeeded() {\n\t\tif (this.state === AutorunState.upToDate) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tthis.state = AutorunState.upToDate;\n\n\t\tconst isDisposed = this.disposed;\n\t\ttry {\n\t\t\tif (!isDisposed) {\n\t\t\t\tgetLogger()?.handleAutorunTriggered(this);\n\t\t\t\tconst changeSummary = this.changeSummary!;\n\t\t\t\ttry {\n\t\t\t\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\t\t\t\tthis._runFn(this, changeSummary);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonBugIndicatingError(e);\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif (!isDisposed) {\n\t\t\t\tgetLogger()?.handleAutorunFinished(this);\n\t\t\t}\n\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\to.removeObserver(this);\n\t\t\t}\n\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t}\n\t}\n\n\tpublic toString(): string {\n\t\treturn `Autorun<${this.debugName}>`;\n\t}\n\n\t// IObserver implementation\n\tpublic beginUpdate(): void {\n\t\tif (this.state === AutorunState.upToDate) {\n\t\t\tthis.state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t\tthis.updateCount++;\n\t}\n\n\tpublic endUpdate(): void {\n\t\ttry {\n\t\t\tif (this.updateCount === 1) {\n\t\t\t\tdo {\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.state === AutorunState.dependenciesMightHaveChanged\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.state = AutorunState.upToDate;\n\t\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\t\td.reportChanges();\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(this.state as AutorunState) ===\n\t\t\t\t\t\t\t\tAutorunState.stale\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t// The other dependencies will refresh on demand\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._runIfNeeded();\n\t\t\t\t} while (this.state !== AutorunState.upToDate);\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.updateCount--;\n\t\t}\n\n\t\tassertFn(() => this.updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange(observable: IObservable<any>): void {\n\t\tif (\n\t\t\tthis.state === AutorunState.upToDate &&\n\t\t\tthis.dependencies.has(observable) &&\n\t\t\t!this.dependenciesToBeRemoved.has(observable)\n\t\t) {\n\t\t\tthis.state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(\n\t\tobservable: IObservable<T, TChange>,\n\t\tchange: TChange,\n\t): void {\n\t\tif (\n\t\t\tthis.dependencies.has(observable) &&\n\t\t\t!this.dependenciesToBeRemoved.has(observable)\n\t\t) {\n\t\t\ttry {\n\t\t\t\tconst shouldReact = this._handleChange\n\t\t\t\t\t? this._handleChange(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tchangedObservable: observable,\n\t\t\t\t\t\t\t\tchange,\n\t\t\t\t\t\t\t\tdidChange: (o): this is any =>\n\t\t\t\t\t\t\t\t\to === (observable as any),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tthis.changeSummary!,\n\t\t\t\t\t\t)\n\t\t\t\t\t: true;\n\t\t\t\tif (shouldReact) {\n\t\t\t\t\tthis.state = AutorunState.stale;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonBugIndicatingError(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader implementation\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\t// In case the run action disposes the autorun\n\t\tif (this.disposed) {\n\t\t\treturn observable.get();\n\t\t}\n\n\t\tobservable.addObserver(this);\n\t\tconst value = observable.get();\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n}\n\nexport namespace autorun {\n\texport const Observer = AutorunObserver;\n}\n"],
  "mappings": ";;AAWA;AAAA,EACC;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACM;AACP,SAAS,qBAA0C;AACnD,SAAS,iBAAiB;AAMnB,SAAS,QAAQ,IAA4C;AACnE,SAAO,IAAI;AAAA,IACV,IAAI,cAAc,QAAW,QAAW,EAAE;AAAA,IAC1C;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;AAPgB;AAaT,SAAS,YACf,SACA,IACc;AACd,SAAO,IAAI;AAAA,IACV,IAAI;AAAA,MACH,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,QAAQ,oBAAoB;AAAA,IAC7B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;AAdgB;AA2BT,SAAS,qBACf,SAOA,IACc;AACd,SAAO,IAAI;AAAA,IACV,IAAI;AAAA,MACH,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,QAAQ,oBAAoB;AAAA,IAC7B;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR,QAAQ;AAAA,EACT;AACD;AApBgB;AAyBT,SAAS,8BACf,SAOA,IAKc;AACd,QAAM,QAAQ,IAAI,gBAAgB;AAClC,QAAM,aAAa;AAAA,IAClB;AAAA,MACC,OAAO,QAAQ;AAAA,MACf,WAAW,QAAQ;AAAA,MACnB,kBAAkB,QAAQ,oBAAoB;AAAA,MAC9C,0BAA0B,QAAQ;AAAA,MAClC,cAAc,QAAQ;AAAA,IACvB;AAAA,IACA,CAAC,QAAQ,kBAAkB;AAC1B,YAAM,MAAM;AACZ,SAAG,QAAQ,eAAe,KAAK;AAAA,IAChC;AAAA,EACD;AACA,SAAO,aAAa,MAAM;AACzB,eAAW,QAAQ;AACnB,UAAM,QAAQ;AAAA,EACf,CAAC;AACF;AAhCgB;AAqCT,SAAS,iBACf,IACc;AACd,QAAM,QAAQ,IAAI,gBAAgB;AAClC,QAAM,aAAa;AAAA,IAClB;AAAA,MACC,OAAO;AAAA,MACP,WAAW;AAAA,MACX,kBAAkB;AAAA,IACnB;AAAA,IACA,CAAC,WAAW;AACX,YAAM,MAAM;AACZ,SAAG,QAAQ,KAAK;AAAA,IACjB;AAAA,EACD;AACA,SAAO,aAAa,MAAM;AACzB,eAAW,QAAQ;AACnB,UAAM,QAAQ;AAAA,EACf,CAAC;AACF;AAnBgB;AAqBT,SAAS,aACf,YACA,SACc;AACd,MAAI;AACJ,SAAO,YAAY,EAAE,kBAAkB,QAAQ,GAAG,CAAC,WAAW;AAC7D,UAAM,WAAW,WAAW,KAAK,MAAM;AACvC,UAAM,YAAY;AAClB,iBAAa;AACb,YAAQ,EAAE,WAAW,SAAS,CAAC;AAAA,EAChC,CAAC;AACF;AAXgB;AAahB,IAAK,eAAL,kBAAKA,kBAAL;AAKC,EAAAA,4BAAA,kCAA+B,KAA/B;AAKA,EAAAA,4BAAA,WAAQ,KAAR;AACA,EAAAA,4BAAA,cAAW,KAAX;AAXI,SAAAA;AAAA,GAAA;AAcE,MAAM,gBAEb;AAAA,EAYC,YACiB,gBACA,QAIC,qBAGA,eAGhB;AAXe;AACA;AAIC;AAGA;AAIjB,SAAK,gBAAgB,KAAK,sBAAsB;AAChD,cAAU,GAAG,qBAAqB,IAAI;AACtC,SAAK,aAAa;AAElB,oBAAgB,IAAI;AAAA,EACrB;AAAA,EAjND,OAmLA;AAAA;AAAA;AAAA,EACS,QAAQ;AAAA,EACR,cAAc;AAAA,EACd,WAAW;AAAA,EACX,eAAe,oBAAI,IAAsB;AAAA,EACzC,0BAA0B,oBAAI,IAAsB;AAAA,EACpD;AAAA,EAER,IAAW,YAAoB;AAC9B,WAAO,KAAK,eAAe,aAAa,IAAI,KAAK;AAAA,EAClD;AAAA,EAsBO,UAAgB;AACtB,SAAK,WAAW;AAChB,eAAW,KAAK,KAAK,cAAc;AAClC,QAAE,eAAe,IAAI;AAAA,IACtB;AACA,SAAK,aAAa,MAAM;AAExB,mBAAe,IAAI;AAAA,EACpB;AAAA,EAEQ,eAAe;AACtB,QAAI,KAAK,UAAU,kBAAuB;AACzC;AAAA,IACD;AAEA,UAAM,WAAW,KAAK;AACtB,SAAK,0BAA0B,KAAK;AACpC,SAAK,eAAe;AAEpB,SAAK,QAAQ;AAEb,UAAM,aAAa,KAAK;AACxB,QAAI;AACH,UAAI,CAAC,YAAY;AAChB,kBAAU,GAAG,uBAAuB,IAAI;AACxC,cAAM,gBAAgB,KAAK;AAC3B,YAAI;AACH,eAAK,gBAAgB,KAAK,sBAAsB;AAChD,eAAK,OAAO,MAAM,aAAa;AAAA,QAChC,SAAS,GAAG;AACX,+BAAqB,CAAC;AAAA,QACvB;AAAA,MACD;AAAA,IACD,UAAE;AACD,UAAI,CAAC,YAAY;AAChB,kBAAU,GAAG,sBAAsB,IAAI;AAAA,MACxC;AAGA,iBAAW,KAAK,KAAK,yBAAyB;AAC7C,UAAE,eAAe,IAAI;AAAA,MACtB;AACA,WAAK,wBAAwB,MAAM;AAAA,IACpC;AAAA,EACD;AAAA,EAEO,WAAmB;AACzB,WAAO,WAAW,KAAK,SAAS;AAAA,EACjC;AAAA;AAAA,EAGO,cAAoB;AAC1B,QAAI,KAAK,UAAU,kBAAuB;AACzC,WAAK,QAAQ;AAAA,IACd;AACA,SAAK;AAAA,EACN;AAAA,EAEO,YAAkB;AACxB,QAAI;AACH,UAAI,KAAK,gBAAgB,GAAG;AAC3B,WAAG;AACF,cACC,KAAK,UAAU,sCACd;AACD,iBAAK,QAAQ;AACb,uBAAW,KAAK,KAAK,cAAc;AAClC,gBAAE,cAAc;AAChB,kBACE,KAAK,UACN,eACC;AAED;AAAA,cACD;AAAA,YACD;AAAA,UACD;AAEA,eAAK,aAAa;AAAA,QACnB,SAAS,KAAK,UAAU;AAAA,MACzB;AAAA,IACD,UAAE;AACD,WAAK;AAAA,IACN;AAEA,aAAS,MAAM,KAAK,eAAe,CAAC;AAAA,EACrC;AAAA,EAEO,qBAAqB,YAAoC;AAC/D,QACC,KAAK,UAAU,oBACf,KAAK,aAAa,IAAI,UAAU,KAChC,CAAC,KAAK,wBAAwB,IAAI,UAAU,GAC3C;AACD,WAAK,QAAQ;AAAA,IACd;AAAA,EACD;AAAA,EAEO,aACN,YACA,QACO;AACP,QACC,KAAK,aAAa,IAAI,UAAU,KAChC,CAAC,KAAK,wBAAwB,IAAI,UAAU,GAC3C;AACD,UAAI;AACH,cAAM,cAAc,KAAK,gBACtB,KAAK;AAAA,UACL;AAAA,YACC,mBAAmB;AAAA,YACnB;AAAA,YACA,WAAW,wBAAC,MACX,MAAO,YADG;AAAA,UAEZ;AAAA,UACA,KAAK;AAAA,QACN,IACC;AACH,YAAI,aAAa;AAChB,eAAK,QAAQ;AAAA,QACd;AAAA,MACD,SAAS,GAAG;AACX,6BAAqB,CAAC;AAAA,MACvB;AAAA,IACD;AAAA,EACD;AAAA;AAAA,EAGO,eAAkB,YAA+B;AAEvD,QAAI,KAAK,UAAU;AAClB,aAAO,WAAW,IAAI;AAAA,IACvB;AAEA,eAAW,YAAY,IAAI;AAC3B,UAAM,QAAQ,WAAW,IAAI;AAC7B,SAAK,aAAa,IAAI,UAAU;AAChC,SAAK,wBAAwB,OAAO,UAAU;AAC9C,WAAO;AAAA,EACR;AACD;AAAA,CAEO,CAAUC,aAAV;AACC,EAAMA,SAAA,WAAW;AAAA,GADR;",
  "names": ["AutorunState", "autorun"]
}
