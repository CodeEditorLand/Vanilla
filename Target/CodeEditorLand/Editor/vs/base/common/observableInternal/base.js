import{strictEquals as p}from"./commonFacade/deps.js";import{DebugNameData as o,getFunctionName as T}from"./debugName.js";import{getLogger as l}from"./logging.js";let g;function w(t){g=t}let h;function x(t){h=t}let v;function _(t){v=t}class f{get TChange(){return null}reportChanges(){this.get()}read(e){return e?e.readObservable(this):this.get()}map(e,a){const n=a===void 0?void 0:e,r=a===void 0?e:a;return v({owner:n,debugName:()=>{const s=T(r);if(s!==void 0)return s;const i=/^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/.exec(r.toString());if(i)return`${this.debugName}.${i[2]}`;if(!n)return`${this.debugName} (mapped)`},debugReferenceFn:r},s=>r(this.read(s),s))}flatten(){return v({owner:void 0,debugName:()=>`${this.debugName} (flattened)`},e=>this.read(e).read(e))}recomputeInitiallyAndOnChange(e,a){return e.add(g(this,a)),this}keepObserved(e){return e.add(h(this)),this}get debugValue(){return this.get()}}class I extends f{observers=new Set;addObserver(e){const a=this.observers.size;this.observers.add(e),a===0&&this.onFirstObserverAdded()}removeObserver(e){this.observers.delete(e)&&this.observers.size===0&&this.onLastObserverRemoved()}onFirstObserverAdded(){}onLastObserverRemoved(){}}function O(t,e){const a=new d(t,e);try{t(a)}finally{a.finish()}}let b;function D(t){if(b)t(b);else{const e=new d(t,void 0);b=e;try{t(e)}finally{e.finish(),b=void 0}}}async function S(t,e){const a=new d(t,e);try{await t(a)}finally{a.finish()}}function V(t,e,a){t?e(t):O(e,a)}class d{constructor(e,a){this._fn=e;this._getDebugName=a;l()?.handleBeginTransaction(this)}updatingObservers=[];getDebugName(){return this._getDebugName?this._getDebugName():T(this._fn)}updateObserver(e,a){this.updatingObservers.push({observer:e,observable:a}),e.beginUpdate(a)}finish(){const e=this.updatingObservers;for(let a=0;a<e.length;a++){const{observer:n,observable:r}=e[a];n.endUpdate(r)}this.updatingObservers=null,l()?.handleEndTransaction()}}function R(t,e){let a;return typeof t=="string"?a=new o(void 0,t,void 0):a=new o(t,void 0,void 0),new c(a,e,p)}class c extends I{constructor(a,n,r){super();this._debugNameData=a;this._equalityComparator=r;this._value=n}_value;get debugName(){return this._debugNameData.getDebugName(this)??"ObservableValue"}get(){return this._value}set(a,n,r){if(r===void 0&&this._equalityComparator(this._value,a))return;let s;n||(n=s=new d(()=>{},()=>`Setting ${this.debugName}`));try{const u=this._value;this._setValue(a),l()?.handleObservableChanged(this,{oldValue:u,newValue:a,change:r,didChange:!0,hadValue:!0});for(const i of this.observers)n.updateObserver(i,this),i.handleChange(this,r)}finally{s&&s.finish()}}toString(){return`${this.debugName}: ${this._value}`}_setValue(a){this._value=a}}function A(t,e){let a;return typeof t=="string"?a=new o(void 0,t,void 0):a=new o(t,void 0,void 0),new m(a,e,p)}class m extends c{_setValue(e){this._value!==e&&(this._value&&this._value.dispose(),this._value=e)}dispose(){this._value?.dispose()}}export{I as BaseObservable,f as ConvenientObservable,m as DisposableObservableValue,c as ObservableValue,d as TransactionImpl,_ as _setDerivedOpts,x as _setKeepObserved,w as _setRecomputeInitiallyAndOnChange,S as asyncTransaction,A as disposableObservableValue,D as globalTransaction,R as observableValue,V as subtransaction,O as transaction};
