import{BaseObservable as i,TransactionImpl as o}from"./base.js";class C extends i{constructor(e,t,a){super();this._debugNameData=e;this._equalityComparator=a;this._value=t}_value;_isUpToDate=!0;_deltas=[];get debugName(){return this._debugNameData.getDebugName(this)??"LazyObservableValue"}get(){return this._update(),this._value}_update(){if(!this._isUpToDate)if(this._isUpToDate=!0,this._deltas.length>0){for(const e of this.observers)for(const t of this._deltas)e.handleChange(this,t);this._deltas.length=0}else for(const e of this.observers)e.handleChange(this,void 0)}_updateCounter=0;_beginUpdate(){if(this._updateCounter++,this._updateCounter===1)for(const e of this.observers)e.beginUpdate(this)}_endUpdate(){if(this._updateCounter--,this._updateCounter===0){this._update();const e=[...this.observers];for(const t of e)t.endUpdate(this)}}addObserver(e){const t=!this.observers.has(e)&&this._updateCounter>0;super.addObserver(e),t&&e.beginUpdate(this)}removeObserver(e){const t=this.observers.has(e)&&this._updateCounter>0;super.removeObserver(e),t&&e.endUpdate(this)}set(e,t,a){if(a===void 0&&this._equalityComparator(this._value,e))return;let s;t||(t=s=new o(()=>{},()=>`Setting ${this.debugName}`));try{if(this._isUpToDate=!1,this._setValue(e),a!==void 0&&this._deltas.push(a),t.updateObserver({beginUpdate:()=>this._beginUpdate(),endUpdate:()=>this._endUpdate(),handleChange:(r,h)=>{},handlePossibleChange:r=>{}},this),this._updateCounter>1)for(const r of this.observers)r.handlePossibleChange(this)}finally{s&&s.finish()}}toString(){return`${this.debugName}: ${this._value}`}_setValue(e){this._value=e}}export{C as LazyObservableValue};
