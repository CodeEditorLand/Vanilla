import{autorun as w}from"./autorun.js";import{observableValue as b,transaction as p}from"./base.js";import{Derived as k,derived as P}from"./derived.js";import{CancellationTokenSource as y}from"../cancellation.js";import{DebugNameData as C}from"./debugName.js";import{strictEquals as I}from"../equals.js";import{CancellationError as f}from"../errors.js";class R{constructor(e){this._computeValue=e}_value=b(this,void 0);get cachedValue(){return this._value}getValue(){let e=this._value.get();return e||(e=this._computeValue(),this._value.set(e,void 0)),e}}class u{static fromFn(e){return new u(e())}_value=b(this,void 0);promise;promiseResult=this._value;constructor(e){this.promise=e.then(n=>(p(o=>{this._value.set(new m(n,void 0),o)}),n),n=>{throw p(o=>{this._value.set(new m(void 0,n),o)}),n})}}class m{constructor(e,n){this.data=e;this.error=n}getDataOrThrow(){if(this.error)throw this.error;return this.data}}class W{constructor(e){this._computePromise=e}_lazyValue=new R(()=>new u(this._computePromise()));cachedPromiseResult=P(this,e=>this._lazyValue.cachedValue.read(e)?.promiseResult.read(e));getPromise(){return this._lazyValue.getValue().promise}}function L(a,e,n,o){return e||(e=t=>t!=null),new Promise((t,i)=>{let d=!0,c=!1;const v=a.map(r=>({isFinished:e(r),error:n?n(r):!1,state:r})),l=w(r=>{const{isFinished:h,error:s,state:T}=v.read(r);(h||s)&&(d?c=!0:l.dispose(),s?i(s===!0?T:s):t(T))});if(o){const r=o.onCancellationRequested(()=>{l.dispose(),r.dispose(),i(new f)});if(o.isCancellationRequested){l.dispose(),r.dispose(),i(new f);return}}d=!1,c&&l.dispose()})}function N(a,e){let n,o;e===void 0?(n=a,o=void 0):(o=a,n=e);let t;return new k(new C(o,void 0,n),i=>(t&&t.dispose(!0),t=new y,n(i,t.token)),void 0,void 0,()=>t?.dispose(),I)}export{R as ObservableLazy,W as ObservableLazyPromise,u as ObservablePromise,m as PromiseResult,N as derivedWithCancellationToken,L as waitForState};
