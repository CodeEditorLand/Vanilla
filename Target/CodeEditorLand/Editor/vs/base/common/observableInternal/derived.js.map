{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/observableInternal/derived.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\tBaseObservable,\n\ttype IChangeContext,\n\ttype IObservable,\n\ttype IObserver,\n\ttype IReader,\n\ttype ISettableObservable,\n\ttype ITransaction,\n\t_setDerivedOpts,\n} from \"./base.js\";\nimport {\n\tDisposableStore,\n\ttype EqualityComparer,\n\ttype IDisposable,\n\tassertFn,\n\tonBugIndicatingError,\n\tstrictEquals,\n} from \"./commonFacade/deps.js\";\nimport {\n\tDebugNameData,\n\ttype DebugOwner,\n\ttype IDebugNameData,\n} from \"./debugName.js\";\nimport { getLogger } from \"./logging.js\";\n\n/**\n * Creates an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n */\nexport function derived<T>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derived<T>(\n\towner: DebugOwner,\n\tcomputeFn: (reader: IReader) => T,\n): IObservable<T>;\nexport function derived<T>(\n\tcomputeFnOrOwner: ((reader: IReader) => T) | DebugOwner,\n\tcomputeFn?: ((reader: IReader) => T) | undefined,\n): IObservable<T> {\n\tif (computeFn !== undefined) {\n\t\treturn new Derived(\n\t\t\tnew DebugNameData(computeFnOrOwner, undefined, computeFn),\n\t\t\tcomputeFn,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tstrictEquals,\n\t\t);\n\t}\n\treturn new Derived(\n\t\tnew DebugNameData(undefined, undefined, computeFnOrOwner as any),\n\t\tcomputeFnOrOwner as any,\n\t\tundefined,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals,\n\t);\n}\n\nexport function derivedWithSetter<T>(\n\towner: DebugOwner | undefined,\n\tcomputeFn: (reader: IReader) => T,\n\tsetter: (value: T, transaction: ITransaction | undefined) => void,\n): ISettableObservable<T> {\n\treturn new DerivedWithSetter(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals,\n\t\tsetter,\n\t);\n}\n\nexport function derivedOpts<T>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t\tonLastObserverRemoved?: () => void;\n\t},\n\tcomputeFn: (reader: IReader) => T,\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(\n\t\t\toptions.owner,\n\t\t\toptions.debugName,\n\t\t\toptions.debugReferenceFn,\n\t\t),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\toptions.onLastObserverRemoved,\n\t\toptions.equalsFn ?? strictEquals,\n\t);\n}\n\n_setDerivedOpts(derivedOpts);\n\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges<T, TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary: () => TChangeSummary;\n\t\thandleChange: (\n\t\t\tcontext: IChangeContext,\n\t\t\tchangeSummary: TChangeSummary,\n\t\t) => boolean;\n\t\tequalityComparer?: EqualityComparer<T>;\n\t},\n\tcomputeFn: (reader: IReader, changeSummary: TChangeSummary) => T,\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\tcomputeFn,\n\t\toptions.createEmptyChangeSummary,\n\t\toptions.handleChange,\n\t\tundefined,\n\t\toptions.equalityComparer ?? strictEquals,\n\t);\n}\n\nexport function derivedWithStore<T>(\n\tcomputeFn: (reader: IReader, store: DisposableStore) => T,\n): IObservable<T>;\nexport function derivedWithStore<T>(\n\towner: object,\n\tcomputeFn: (reader: IReader, store: DisposableStore) => T,\n): IObservable<T>;\nexport function derivedWithStore<T>(\n\tcomputeFnOrOwner: ((reader: IReader, store: DisposableStore) => T) | object,\n\tcomputeFnOrUndefined?: (reader: IReader, store: DisposableStore) => T,\n): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: DisposableStore) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tconst store = new DisposableStore();\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\t(r) => {\n\t\t\tstore.clear();\n\t\t\treturn computeFn(r, store);\n\t\t},\n\t\tundefined,\n\t\tundefined,\n\t\t() => store.dispose(),\n\t\tstrictEquals,\n\t);\n}\n\nexport function derivedDisposable<T extends IDisposable | undefined>(\n\tcomputeFn: (reader: IReader) => T,\n): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(\n\towner: DebugOwner,\n\tcomputeFn: (reader: IReader) => T,\n): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(\n\tcomputeFnOrOwner: ((reader: IReader) => T) | DebugOwner,\n\tcomputeFnOrUndefined?: (reader: IReader) => T,\n): IObservable<T> {\n\tlet computeFn: (reader: IReader) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet store: DisposableStore | undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\t(r) => {\n\t\t\tif (store) {\n\t\t\t\tstore.clear();\n\t\t\t} else {\n\t\t\t\tstore = new DisposableStore();\n\t\t\t}\n\t\t\tconst result = computeFn(r);\n\t\t\tif (result) {\n\t\t\t\tstore.add(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tundefined,\n\t\tundefined,\n\t\t() => {\n\t\t\tif (store) {\n\t\t\t\tstore.dispose();\n\t\t\t\tstore = undefined;\n\t\t\t}\n\t\t},\n\t\tstrictEquals,\n\t);\n}\n\nenum DerivedState {\n\t/** Initial state, no previous value, recomputation needed */\n\tinitial = 0,\n\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t * After recomputation, we need to check the previous value to see if we changed as well.\n\t */\n\tstale = 2,\n\n\t/**\n\t * No change reported, our cached value is up to date.\n\t */\n\tupToDate = 3,\n}\n\nexport class Derived<T, TChangeSummary = any>\n\textends BaseObservable<T, void>\n\timplements IReader, IObserver\n{\n\tprivate state = DerivedState.initial;\n\tprivate value: T | undefined = undefined;\n\tprivate updateCount = 0;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined = undefined;\n\n\tpublic override get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? \"(anonymous)\";\n\t}\n\n\tconstructor(\n\t\tpublic readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _computeFn: (\n\t\t\treader: IReader,\n\t\t\tchangeSummary: TChangeSummary,\n\t\t) => T,\n\t\tprivate readonly createChangeSummary:\n\t\t\t| (() => TChangeSummary)\n\t\t\t| undefined,\n\t\tprivate readonly _handleChange:\n\t\t\t| ((context: IChangeContext, summary: TChangeSummary) => boolean)\n\t\t\t| undefined,\n\t\tprivate readonly _handleLastObserverRemoved:\n\t\t\t| (() => void)\n\t\t\t| undefined = undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t) {\n\t\tsuper();\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleDerivedCreated(this);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\t/**\n\t\t * We are not tracking changes anymore, thus we have to assume\n\t\t * that our cache is invalid.\n\t\t */\n\t\tthis.state = DerivedState.initial;\n\t\tthis.value = undefined;\n\t\tfor (const d of this.dependencies) {\n\t\t\td.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\n\t\tthis._handleLastObserverRemoved?.();\n\t}\n\n\tpublic override get(): T {\n\t\tif (this.observers.size === 0) {\n\t\t\t// Without observers, we don't know when to clean up stuff.\n\t\t\t// Thus, we don't cache anything to prevent memory leaks.\n\t\t\tconst result = this._computeFn(this, this.createChangeSummary?.()!);\n\t\t\t// Clear new dependencies\n\t\t\tthis.onLastObserverRemoved();\n\t\t\treturn result;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t// We might not get a notification for a dependency that changed while it is updating,\n\t\t\t\t// thus we also have to ask all our depedencies if they changed in this case.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\t/** might call {@link handleChange} indirectly, which could make us stale */\n\t\t\t\t\t\td.reportChanges();\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(this.state as DerivedState) === DerivedState.stale\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand, so early break\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We called report changes of all dependencies.\n\t\t\t\t// If we are still not stale, we can assume to be up to date again.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis.state = DerivedState.upToDate;\n\t\t\t\t}\n\n\t\t\t\tthis._recomputeIfNeeded();\n\t\t\t\t// In case recomputation changed one of our dependencies, we need to recompute again.\n\t\t\t} while (this.state !== DerivedState.upToDate);\n\t\t\treturn this.value!;\n\t\t}\n\t}\n\n\tprivate _recomputeIfNeeded() {\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\treturn;\n\t\t}\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tconst hadValue = this.state !== DerivedState.initial;\n\t\tconst oldValue = this.value;\n\t\tthis.state = DerivedState.upToDate;\n\n\t\tlet didChange = false;\n\n\t\ttry {\n\t\t\tconst changeSummary = this.changeSummary!;\n\t\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\t\ttry {\n\t\t\t\t/** might call {@link handleChange} indirectly, which could invalidate us */\n\t\t\t\tthis.value = this._computeFn(this, changeSummary);\n\t\t\t} finally {\n\t\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\t\to.removeObserver(this);\n\t\t\t\t}\n\t\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t\t}\n\n\t\t\tdidChange =\n\t\t\t\thadValue && !this._equalityComparator(oldValue!, this.value);\n\n\t\t\tgetLogger()?.handleDerivedRecomputed(this, {\n\t\t\t\toldValue,\n\t\t\t\tnewValue: this.value,\n\t\t\t\tchange: undefined,\n\t\t\t\tdidChange,\n\t\t\t\thadValue,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tonBugIndicatingError(e);\n\t\t}\n\n\t\tif (didChange) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handleChange(this, undefined);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `LazyDerived<${this.debugName}>`;\n\t}\n\n\t// IObserver Implementation\n\tpublic beginUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount++;\n\t\tconst propagateBeginUpdate = this.updateCount === 1;\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\t// If we propagate begin update, that will already signal a possible change.\n\t\t\tif (!propagateBeginUpdate) {\n\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (propagateBeginUpdate) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.beginUpdate(this); // This signals a possible change\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic endUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount--;\n\t\tif (this.updateCount === 0) {\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this.observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t}\n\t\tassertFn(() => this.updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange<T>(observable: IObservable<T, unknown>): void {\n\t\t// In all other states, observers already know that we might have changed.\n\t\tif (\n\t\t\tthis.state === DerivedState.upToDate &&\n\t\t\tthis.dependencies.has(observable) &&\n\t\t\t!this.dependenciesToBeRemoved.has(observable)\n\t\t) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handlePossibleChange(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(\n\t\tobservable: IObservable<T, TChange>,\n\t\tchange: TChange,\n\t): void {\n\t\tif (\n\t\t\tthis.dependencies.has(observable) &&\n\t\t\t!this.dependenciesToBeRemoved.has(observable)\n\t\t) {\n\t\t\tlet shouldReact = false;\n\t\t\ttry {\n\t\t\t\tshouldReact = this._handleChange\n\t\t\t\t\t? this._handleChange(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tchangedObservable: observable,\n\t\t\t\t\t\t\t\tchange,\n\t\t\t\t\t\t\t\tdidChange: (o): this is any =>\n\t\t\t\t\t\t\t\t\to === (observable as any),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tthis.changeSummary!,\n\t\t\t\t\t\t)\n\t\t\t\t\t: true;\n\t\t\t} catch (e) {\n\t\t\t\tonBugIndicatingError(e);\n\t\t\t}\n\n\t\t\tconst wasUpToDate = this.state === DerivedState.upToDate;\n\t\t\tif (\n\t\t\t\tshouldReact &&\n\t\t\t\t(this.state === DerivedState.dependenciesMightHaveChanged ||\n\t\t\t\t\twasUpToDate)\n\t\t\t) {\n\t\t\t\tthis.state = DerivedState.stale;\n\t\t\t\tif (wasUpToDate) {\n\t\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader Implementation\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\t// Subscribe before getting the value to enable caching\n\t\tobservable.addObserver(this);\n\t\t/** This might call {@link handleChange} indirectly, which could invalidate us */\n\t\tconst value = observable.get();\n\t\t// Which is why we only add the observable to the dependencies now.\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate =\n\t\t\t!this.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tobserver.beginUpdate(this);\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tconst shouldCallEndUpdate =\n\t\t\tthis.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.removeObserver(observer);\n\n\t\tif (shouldCallEndUpdate) {\n\t\t\t// Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n\t\t\tobserver.endUpdate(this);\n\t\t}\n\t}\n}\n\nexport class DerivedWithSetter<T, TChangeSummary = any>\n\textends Derived<T, TChangeSummary>\n\timplements ISettableObservable<T>\n{\n\tconstructor(\n\t\tdebugNameData: DebugNameData,\n\t\tcomputeFn: (reader: IReader, changeSummary: TChangeSummary) => T,\n\t\tcreateChangeSummary: (() => TChangeSummary) | undefined,\n\t\thandleChange:\n\t\t\t| ((context: IChangeContext, summary: TChangeSummary) => boolean)\n\t\t\t| undefined,\n\t\thandleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tequalityComparator: EqualityComparer<T>,\n\t\tpublic readonly set: (value: T, tx: ITransaction | undefined) => void,\n\t) {\n\t\tsuper(\n\t\t\tdebugNameData,\n\t\t\tcomputeFn,\n\t\t\tcreateChangeSummary,\n\t\t\thandleChange,\n\t\t\thandleLastObserverRemoved,\n\t\t\tequalityComparator,\n\t\t);\n\t}\n}\n"],
  "mappings": ";;AAKA;AAAA,EACC;AAAA,EAOA;AAAA,OACM;AACP;AAAA,EACC;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,OACM;AACP;AAAA,EACC;AAAA,OAGM;AACP,SAAS,iBAAiB;AAanB,SAAS,QACf,kBACA,WACiB;AACjB,MAAI,cAAc,QAAW;AAC5B,WAAO,IAAI;AAAA,MACV,IAAI,cAAc,kBAAkB,QAAW,SAAS;AAAA,MACxD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,EACD;AACA,SAAO,IAAI;AAAA,IACV,IAAI,cAAc,QAAW,QAAW,gBAAuB;AAAA,IAC/D;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;AAtBgB;AAwBT,SAAS,kBACf,OACA,WACA,QACyB;AACzB,SAAO,IAAI;AAAA,IACV,IAAI,cAAc,OAAO,QAAW,SAAS;AAAA,IAC7C;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;AAdgB;AAgBT,SAAS,YACf,SAIA,WACiB;AACjB,SAAO,IAAI;AAAA,IACV,IAAI;AAAA,MACH,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,QAAQ;AAAA,IACT;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR,QAAQ,YAAY;AAAA,EACrB;AACD;AAnBgB;AAqBhB,gBAAgB,WAAW;AAepB,SAAS,qBACf,SAQA,WACiB;AACjB,SAAO,IAAI;AAAA,IACV,IAAI,cAAc,QAAQ,OAAO,QAAQ,WAAW,MAAS;AAAA,IAC7D;AAAA,IACA,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR;AAAA,IACA,QAAQ,oBAAoB;AAAA,EAC7B;AACD;AAnBgB;AA4BT,SAAS,iBACf,kBACA,sBACiB;AACjB,MAAI;AACJ,MAAI;AACJ,MAAI,yBAAyB,QAAW;AACvC,gBAAY;AACZ,YAAQ;AAAA,EACT,OAAO;AACN,YAAQ;AACR,gBAAY;AAAA,EACb;AAEA,QAAM,QAAQ,IAAI,gBAAgB;AAClC,SAAO,IAAI;AAAA,IACV,IAAI,cAAc,OAAO,QAAW,SAAS;AAAA,IAC7C,CAAC,MAAM;AACN,YAAM,MAAM;AACZ,aAAO,UAAU,GAAG,KAAK;AAAA,IAC1B;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM,MAAM,QAAQ;AAAA,IACpB;AAAA,EACD;AACD;AA1BgB;AAmCT,SAAS,kBACf,kBACA,sBACiB;AACjB,MAAI;AACJ,MAAI;AACJ,MAAI,yBAAyB,QAAW;AACvC,gBAAY;AACZ,YAAQ;AAAA,EACT,OAAO;AACN,YAAQ;AACR,gBAAY;AAAA,EACb;AAEA,MAAI;AACJ,SAAO,IAAI;AAAA,IACV,IAAI,cAAc,OAAO,QAAW,SAAS;AAAA,IAC7C,CAAC,MAAM;AACN,UAAI,OAAO;AACV,cAAM,MAAM;AAAA,MACb,OAAO;AACN,gBAAQ,IAAI,gBAAgB;AAAA,MAC7B;AACA,YAAM,SAAS,UAAU,CAAC;AAC1B,UAAI,QAAQ;AACX,cAAM,IAAI,MAAM;AAAA,MACjB;AACA,aAAO;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM;AACL,UAAI,OAAO;AACV,cAAM,QAAQ;AACd,gBAAQ;AAAA,MACT;AAAA,IACD;AAAA,IACA;AAAA,EACD;AACD;AAvCgB;AAyChB,IAAK,eAAL,kBAAKA,kBAAL;AAEC,EAAAA,4BAAA,aAAU,KAAV;AAMA,EAAAA,4BAAA,kCAA+B,KAA/B;AAMA,EAAAA,4BAAA,WAAQ,KAAR;AAKA,EAAAA,4BAAA,cAAW,KAAX;AAnBI,SAAAA;AAAA,GAAA;AAsBE,MAAM,gBACJ,eAET;AAAA,EAYC,YACiB,gBACA,YAIC,qBAGA,eAGA,6BAEF,QACE,qBAChB;AACD,UAAM;AAhBU;AACA;AAIC;AAGA;AAGA;AAGA;AAGjB,SAAK,gBAAgB,KAAK,sBAAsB;AAChD,cAAU,GAAG,qBAAqB,IAAI;AAAA,EACvC;AAAA,EAtRD,OAsPA;AAAA;AAAA;AAAA,EACS,QAAQ;AAAA,EACR,QAAuB;AAAA,EACvB,cAAc;AAAA,EACd,eAAe,oBAAI,IAAsB;AAAA,EACzC,0BAA0B,oBAAI,IAAsB;AAAA,EACpD,gBAA4C;AAAA,EAEpD,IAAoB,YAAoB;AACvC,WAAO,KAAK,eAAe,aAAa,IAAI,KAAK;AAAA,EAClD;AAAA,EAwBmB,wBAA8B;AAKhD,SAAK,QAAQ;AACb,SAAK,QAAQ;AACb,eAAW,KAAK,KAAK,cAAc;AAClC,QAAE,eAAe,IAAI;AAAA,IACtB;AACA,SAAK,aAAa,MAAM;AAExB,SAAK,6BAA6B;AAAA,EACnC;AAAA,EAEgB,MAAS;AACxB,QAAI,KAAK,UAAU,SAAS,GAAG;AAG9B,YAAM,SAAS,KAAK,WAAW,MAAM,KAAK,sBAAsB,CAAE;AAElE,WAAK,sBAAsB;AAC3B,aAAO;AAAA,IACR,OAAO;AACN,SAAG;AAGF,YAAI,KAAK,UAAU,sCAA2C;AAC7D,qBAAW,KAAK,KAAK,cAAc;AAElC,cAAE,cAAc;AAEhB,gBACE,KAAK,UAA2B,eAChC;AAED;AAAA,YACD;AAAA,UACD;AAAA,QACD;AAIA,YAAI,KAAK,UAAU,sCAA2C;AAC7D,eAAK,QAAQ;AAAA,QACd;AAEA,aAAK,mBAAmB;AAAA,MAEzB,SAAS,KAAK,UAAU;AACxB,aAAO,KAAK;AAAA,IACb;AAAA,EACD;AAAA,EAEQ,qBAAqB;AAC5B,QAAI,KAAK,UAAU,kBAAuB;AACzC;AAAA,IACD;AACA,UAAM,WAAW,KAAK;AACtB,SAAK,0BAA0B,KAAK;AACpC,SAAK,eAAe;AAEpB,UAAM,WAAW,KAAK,UAAU;AAChC,UAAM,WAAW,KAAK;AACtB,SAAK,QAAQ;AAEb,QAAI,YAAY;AAEhB,QAAI;AACH,YAAM,gBAAgB,KAAK;AAC3B,WAAK,gBAAgB,KAAK,sBAAsB;AAChD,UAAI;AAEH,aAAK,QAAQ,KAAK,WAAW,MAAM,aAAa;AAAA,MACjD,UAAE;AAGD,mBAAW,KAAK,KAAK,yBAAyB;AAC7C,YAAE,eAAe,IAAI;AAAA,QACtB;AACA,aAAK,wBAAwB,MAAM;AAAA,MACpC;AAEA,kBACC,YAAY,CAAC,KAAK,oBAAoB,UAAW,KAAK,KAAK;AAE5D,gBAAU,GAAG,wBAAwB,MAAM;AAAA,QAC1C;AAAA,QACA,UAAU,KAAK;AAAA,QACf,QAAQ;AAAA,QACR;AAAA,QACA;AAAA,MACD,CAAC;AAAA,IACF,SAAS,GAAG;AACX,2BAAqB,CAAC;AAAA,IACvB;AAEA,QAAI,WAAW;AACd,iBAAW,KAAK,KAAK,WAAW;AAC/B,UAAE,aAAa,MAAM,MAAS;AAAA,MAC/B;AAAA,IACD;AAAA,EACD;AAAA,EAEgB,WAAmB;AAClC,WAAO,eAAe,KAAK,SAAS;AAAA,EACrC;AAAA;AAAA,EAGO,YAAe,aAAmC;AACxD,SAAK;AACL,UAAM,uBAAuB,KAAK,gBAAgB;AAClD,QAAI,KAAK,UAAU,kBAAuB;AACzC,WAAK,QAAQ;AAEb,UAAI,CAAC,sBAAsB;AAC1B,mBAAW,KAAK,KAAK,WAAW;AAC/B,YAAE,qBAAqB,IAAI;AAAA,QAC5B;AAAA,MACD;AAAA,IACD;AACA,QAAI,sBAAsB;AACzB,iBAAW,KAAK,KAAK,WAAW;AAC/B,UAAE,YAAY,IAAI;AAAA,MACnB;AAAA,IACD;AAAA,EACD;AAAA,EAEO,UAAa,aAAmC;AACtD,SAAK;AACL,QAAI,KAAK,gBAAgB,GAAG;AAE3B,YAAM,YAAY,CAAC,GAAG,KAAK,SAAS;AACpC,iBAAW,KAAK,WAAW;AAC1B,UAAE,UAAU,IAAI;AAAA,MACjB;AAAA,IACD;AACA,aAAS,MAAM,KAAK,eAAe,CAAC;AAAA,EACrC;AAAA,EAEO,qBAAwB,YAA2C;AAEzE,QACC,KAAK,UAAU,oBACf,KAAK,aAAa,IAAI,UAAU,KAChC,CAAC,KAAK,wBAAwB,IAAI,UAAU,GAC3C;AACD,WAAK,QAAQ;AACb,iBAAW,KAAK,KAAK,WAAW;AAC/B,UAAE,qBAAqB,IAAI;AAAA,MAC5B;AAAA,IACD;AAAA,EACD;AAAA,EAEO,aACN,YACA,QACO;AACP,QACC,KAAK,aAAa,IAAI,UAAU,KAChC,CAAC,KAAK,wBAAwB,IAAI,UAAU,GAC3C;AACD,UAAI,cAAc;AAClB,UAAI;AACH,sBAAc,KAAK,gBAChB,KAAK;AAAA,UACL;AAAA,YACC,mBAAmB;AAAA,YACnB;AAAA,YACA,WAAW,wBAAC,MACX,MAAO,YADG;AAAA,UAEZ;AAAA,UACA,KAAK;AAAA,QACN,IACC;AAAA,MACJ,SAAS,GAAG;AACX,6BAAqB,CAAC;AAAA,MACvB;AAEA,YAAM,cAAc,KAAK,UAAU;AACnC,UACC,gBACC,KAAK,UAAU,wCACf,cACA;AACD,aAAK,QAAQ;AACb,YAAI,aAAa;AAChB,qBAAW,KAAK,KAAK,WAAW;AAC/B,cAAE,qBAAqB,IAAI;AAAA,UAC5B;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAAA;AAAA,EAGO,eAAkB,YAA+B;AAEvD,eAAW,YAAY,IAAI;AAE3B,UAAM,QAAQ,WAAW,IAAI;AAE7B,SAAK,aAAa,IAAI,UAAU;AAChC,SAAK,wBAAwB,OAAO,UAAU;AAC9C,WAAO;AAAA,EACR;AAAA,EAEgB,YAAY,UAA2B;AACtD,UAAM,wBACL,CAAC,KAAK,UAAU,IAAI,QAAQ,KAAK,KAAK,cAAc;AACrD,UAAM,YAAY,QAAQ;AAE1B,QAAI,uBAAuB;AAC1B,eAAS,YAAY,IAAI;AAAA,IAC1B;AAAA,EACD;AAAA,EAEgB,eAAe,UAA2B;AACzD,UAAM,sBACL,KAAK,UAAU,IAAI,QAAQ,KAAK,KAAK,cAAc;AACpD,UAAM,eAAe,QAAQ;AAE7B,QAAI,qBAAqB;AAExB,eAAS,UAAU,IAAI;AAAA,IACxB;AAAA,EACD;AACD;AAEO,MAAM,0BACJ,QAET;AAAA,EACC,YACC,eACA,WACA,qBACA,cAGA,4BAAsD,QACtD,oBACgB,KACf;AACD;AAAA,MACC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AATgB;AAAA,EAUjB;AAAA,EAphBD,OAggBA;AAAA;AAAA;AAqBA;",
  "names": ["DerivedState"]
}
