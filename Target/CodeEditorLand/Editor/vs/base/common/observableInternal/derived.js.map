{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/observableInternal/derived.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BaseObservable, IChangeContext, IObservable, IObserver, IReader, ISettableObservable, ITransaction, _setDerivedOpts, } from './base.js';\nimport { DebugNameData, DebugOwner, IDebugNameData } from './debugName.js';\nimport { DisposableStore, EqualityComparer, IDisposable, assertFn, onBugIndicatingError, strictEquals } from './commonFacade/deps.js';\nimport { getLogger } from './logging.js';\n\n/**\n * Creates an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n */\nexport function derived<T>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derived<T>(owner: DebugOwner, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derived<T>(computeFnOrOwner: ((reader: IReader) => T) | DebugOwner, computeFn?: ((reader: IReader) => T) | undefined): IObservable<T> {\n\tif (computeFn !== undefined) {\n\t\treturn new Derived(\n\t\t\tnew DebugNameData(computeFnOrOwner, undefined, computeFn),\n\t\t\tcomputeFn,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tstrictEquals\n\t\t);\n\t}\n\treturn new Derived(\n\t\tnew DebugNameData(undefined, undefined, computeFnOrOwner as any),\n\t\tcomputeFnOrOwner as any,\n\t\tundefined,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals\n\t);\n}\n\nexport function derivedWithSetter<T>(owner: DebugOwner | undefined, computeFn: (reader: IReader) => T, setter: (value: T, transaction: ITransaction | undefined) => void): ISettableObservable<T> {\n\treturn new DerivedWithSetter(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals,\n\t\tsetter,\n\t);\n}\n\nexport function derivedOpts<T>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t\tonLastObserverRemoved?: (() => void);\n\t},\n\tcomputeFn: (reader: IReader) => T\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\toptions.onLastObserverRemoved,\n\t\toptions.equalsFn ?? strictEquals\n\t);\n}\n\n_setDerivedOpts(derivedOpts);\n\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges<T, TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t\tequalityComparer?: EqualityComparer<T>;\n\t},\n\tcomputeFn: (reader: IReader, changeSummary: TChangeSummary) => T\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\tcomputeFn,\n\t\toptions.createEmptyChangeSummary,\n\t\toptions.handleChange,\n\t\tundefined,\n\t\toptions.equalityComparer ?? strictEquals\n\t);\n}\n\nexport function derivedWithStore<T>(computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;\nexport function derivedWithStore<T>(owner: object, computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;\nexport function derivedWithStore<T>(computeFnOrOwner: ((reader: IReader, store: DisposableStore) => T) | object, computeFnOrUndefined?: ((reader: IReader, store: DisposableStore) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: DisposableStore) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tconst store = new DisposableStore();\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tstore.clear();\n\t\t\treturn computeFn(r, store);\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => store.dispose(),\n\t\tstrictEquals\n\t);\n}\n\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(owner: DebugOwner, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFnOrOwner: ((reader: IReader) => T) | DebugOwner, computeFnOrUndefined?: ((reader: IReader) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet store: DisposableStore | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (!store) {\n\t\t\t\tstore = new DisposableStore();\n\t\t\t} else {\n\t\t\t\tstore.clear();\n\t\t\t}\n\t\t\tconst result = computeFn(r);\n\t\t\tif (result) {\n\t\t\t\tstore.add(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => {\n\t\t\tif (store) {\n\t\t\t\tstore.dispose();\n\t\t\t\tstore = undefined;\n\t\t\t}\n\t\t},\n\t\tstrictEquals\n\t);\n}\n\nconst enum DerivedState {\n\t/** Initial state, no previous value, recomputation needed */\n\tinitial = 0,\n\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t * After recomputation, we need to check the previous value to see if we changed as well.\n\t */\n\tstale = 2,\n\n\t/**\n\t * No change reported, our cached value is up to date.\n\t */\n\tupToDate = 3,\n}\n\nexport class Derived<T, TChangeSummary = any> extends BaseObservable<T, void> implements IReader, IObserver {\n\tprivate state = DerivedState.initial;\n\tprivate value: T | undefined = undefined;\n\tprivate updateCount = 0;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined = undefined;\n\n\tpublic override get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tpublic readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _computeFn: (reader: IReader, changeSummary: TChangeSummary) => T,\n\t\tprivate readonly createChangeSummary: (() => TChangeSummary) | undefined,\n\t\tprivate readonly _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t\tprivate readonly _handleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t) {\n\t\tsuper();\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleDerivedCreated(this);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\t/**\n\t\t * We are not tracking changes anymore, thus we have to assume\n\t\t * that our cache is invalid.\n\t\t */\n\t\tthis.state = DerivedState.initial;\n\t\tthis.value = undefined;\n\t\tfor (const d of this.dependencies) {\n\t\t\td.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\n\t\tthis._handleLastObserverRemoved?.();\n\t}\n\n\tpublic override get(): T {\n\t\tif (this.observers.size === 0) {\n\t\t\t// Without observers, we don't know when to clean up stuff.\n\t\t\t// Thus, we don't cache anything to prevent memory leaks.\n\t\t\tconst result = this._computeFn(this, this.createChangeSummary?.()!);\n\t\t\t// Clear new dependencies\n\t\t\tthis.onLastObserverRemoved();\n\t\t\treturn result;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t// We might not get a notification for a dependency that changed while it is updating,\n\t\t\t\t// thus we also have to ask all our depedencies if they changed in this case.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\t/** might call {@link handleChange} indirectly, which could make us stale */\n\t\t\t\t\t\td.reportChanges();\n\n\t\t\t\t\t\tif (this.state as DerivedState === DerivedState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand, so early break\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We called report changes of all dependencies.\n\t\t\t\t// If we are still not stale, we can assume to be up to date again.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis.state = DerivedState.upToDate;\n\t\t\t\t}\n\n\t\t\t\tthis._recomputeIfNeeded();\n\t\t\t\t// In case recomputation changed one of our dependencies, we need to recompute again.\n\t\t\t} while (this.state !== DerivedState.upToDate);\n\t\t\treturn this.value!;\n\t\t}\n\t}\n\n\tprivate _recomputeIfNeeded() {\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\treturn;\n\t\t}\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tconst hadValue = this.state !== DerivedState.initial;\n\t\tconst oldValue = this.value;\n\t\tthis.state = DerivedState.upToDate;\n\n\t\tlet didChange = false;\n\n\t\ttry {\n\t\t\tconst changeSummary = this.changeSummary!;\n\t\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\t\ttry {\n\t\t\t\t/** might call {@link handleChange} indirectly, which could invalidate us */\n\t\t\t\tthis.value = this._computeFn(this, changeSummary);\n\t\t\t} finally {\n\t\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\t\to.removeObserver(this);\n\t\t\t\t}\n\t\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t\t}\n\n\t\t\tdidChange = hadValue && !(this._equalityComparator(oldValue!, this.value));\n\n\t\t\tgetLogger()?.handleDerivedRecomputed(this, {\n\t\t\t\toldValue,\n\t\t\t\tnewValue: this.value,\n\t\t\t\tchange: undefined,\n\t\t\t\tdidChange,\n\t\t\t\thadValue,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tonBugIndicatingError(e);\n\t\t}\n\n\t\tif (didChange) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handleChange(this, undefined);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `LazyDerived<${this.debugName}>`;\n\t}\n\n\t// IObserver Implementation\n\tpublic beginUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount++;\n\t\tconst propagateBeginUpdate = this.updateCount === 1;\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\t// If we propagate begin update, that will already signal a possible change.\n\t\t\tif (!propagateBeginUpdate) {\n\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (propagateBeginUpdate) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.beginUpdate(this); // This signals a possible change\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic endUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount--;\n\t\tif (this.updateCount === 0) {\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this.observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t}\n\t\tassertFn(() => this.updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange<T>(observable: IObservable<T, unknown>): void {\n\t\t// In all other states, observers already know that we might have changed.\n\t\tif (this.state === DerivedState.upToDate && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handlePossibleChange(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\tif (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tlet shouldReact = false;\n\t\t\ttry {\n\t\t\t\tshouldReact = this._handleChange ? this._handleChange({\n\t\t\t\t\tchangedObservable: observable,\n\t\t\t\t\tchange,\n\t\t\t\t\tdidChange: (o): this is any => o === observable as any,\n\t\t\t\t}, this.changeSummary!) : true;\n\t\t\t} catch (e) {\n\t\t\t\tonBugIndicatingError(e);\n\t\t\t}\n\n\t\t\tconst wasUpToDate = this.state === DerivedState.upToDate;\n\t\t\tif (shouldReact && (this.state === DerivedState.dependenciesMightHaveChanged || wasUpToDate)) {\n\t\t\t\tthis.state = DerivedState.stale;\n\t\t\t\tif (wasUpToDate) {\n\t\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader Implementation\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\t// Subscribe before getting the value to enable caching\n\t\tobservable.addObserver(this);\n\t\t/** This might call {@link handleChange} indirectly, which could invalidate us */\n\t\tconst value = observable.get();\n\t\t// Which is why we only add the observable to the dependencies now.\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tobserver.beginUpdate(this);\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tconst shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.removeObserver(observer);\n\n\t\tif (shouldCallEndUpdate) {\n\t\t\t// Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n\t\t\tobserver.endUpdate(this);\n\t\t}\n\t}\n}\n\n\nexport class DerivedWithSetter<T, TChangeSummary = any> extends Derived<T, TChangeSummary> implements ISettableObservable<T> {\n\tconstructor(\n\t\tdebugNameData: DebugNameData,\n\t\tcomputeFn: (reader: IReader, changeSummary: TChangeSummary) => T,\n\t\tcreateChangeSummary: (() => TChangeSummary) | undefined,\n\t\thandleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t\thandleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tequalityComparator: EqualityComparer<T>,\n\t\tpublic readonly set: (value: T, tx: ITransaction | undefined) => void,\n\t) {\n\t\tsuper(\n\t\t\tdebugNameData,\n\t\t\tcomputeFn,\n\t\t\tcreateChangeSummary,\n\t\t\thandleChange,\n\t\t\thandleLastObserverRemoved,\n\t\t\tequalityComparator,\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["DerivedState"]
}
