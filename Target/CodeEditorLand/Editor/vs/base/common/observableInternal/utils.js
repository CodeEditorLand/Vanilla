import{Event as D}from"../event.js";import{DisposableStore as v,toDisposable as T}from"../lifecycle.js";import{autorun as f,autorunOpts as w,autorunWithStoreHandleChanges as E}from"./autorun.js";import{BaseObservable as c,ConvenientObservable as _,_setKeepObserved as V,_setRecomputeInitiallyAndOnChange as x,observableValue as g,subtransaction as S,transaction as h}from"./base.js";import{DebugNameData as b,getDebugName as R}from"./debugName.js";import{derived as N,derivedOpts as p}from"./derived.js";import{getLogger as m}from"./logging.js";import{BugIndicatingError as A}from"../errors.js";import{strictEquals as O}from"../equals.js";function ie(t){return new F(t)}class F extends _{constructor(e){super();this.value=e}get debugName(){return this.toString()}get(){return this.value}addObserver(e){}removeObserver(e){}toString(){return`Const: ${this.value}`}}function oe(t){const n=g("promiseValue",{});return t.then(e=>{n.set({value:e},void 0)}),n}function l(...t){let n,e,r;return t.length===3?[n,e,r]=t:[e,r]=t,new u(new b(n,void 0,r),e,r,()=>u.globalTransaction,O)}function de(t,n,e){return new u(new b(t.owner,t.debugName,t.debugReferenceFn??e),n,e,()=>u.globalTransaction,t.equalsFn??O)}class u extends c{constructor(e,r,a,s,i){super();this._debugNameData=e;this.event=r;this._getValue=a;this._getTransaction=s;this._equalityComparator=i}static globalTransaction;value;hasValue=!1;subscription;getDebugName(){return this._debugNameData.getDebugName(this)}get debugName(){const e=this.getDebugName();return"From Event"+(e?`: ${e}`:"")}onFirstObserverAdded(){this.subscription=this.event(this.handleEvent)}handleEvent=e=>{const r=this._getValue(e),a=this.value,s=!this.hasValue||!this._equalityComparator(a,r);let i=!1;s&&(this.value=r,this.hasValue&&(i=!0,S(this._getTransaction(),o=>{m()?.handleFromEventObservableTriggered(this,{oldValue:a,newValue:r,change:void 0,didChange:s,hadValue:this.hasValue});for(const d of this.observers)o.updateObserver(d,this),d.handleChange(this,void 0)},()=>{const o=this.getDebugName();return"Event fired"+(o?`: ${o}`:"")})),this.hasValue=!0),i||m()?.handleFromEventObservableTriggered(this,{oldValue:a,newValue:r,change:void 0,didChange:s,hadValue:this.hasValue})};onLastObserverRemoved(){this.subscription.dispose(),this.subscription=void 0,this.hasValue=!1,this.value=void 0}get(){return this.subscription?(this.hasValue||this.handleEvent(void 0),this.value):this._getValue(void 0)}}(e=>{e.Observer=u;function n(r,a){let s=!1;u.globalTransaction===void 0&&(u.globalTransaction=r,s=!0);try{a()}finally{s&&(u.globalTransaction=void 0)}}e.batchEventsGlobally=n})(l||={});function ue(t,n){return new W(t,n)}class W extends c{constructor(e,r){super();this.debugName=e;this.event=r}subscription;onFirstObserverAdded(){this.subscription=this.event(this.handleEvent)}handleEvent=()=>{h(e=>{for(const r of this.observers)e.updateObserver(r,this),r.handleChange(this,void 0)},()=>this.debugName)};onLastObserverRemoved(){this.subscription.dispose(),this.subscription=void 0}get(){}}function k(t){return typeof t=="string"?new I(t):new I(void 0,t)}class I extends c{constructor(e,r){super();this._debugName=e;this._owner=r}get debugName(){return new b(this._owner,this._debugName,void 0).getDebugName(this)??"Observable Signal"}toString(){return this.debugName}trigger(e,r){if(!e){h(a=>{this.trigger(a,r)},()=>`Trigger signal ${this.debugName}`);return}for(const a of this.observers)e.updateObserver(a,this),a.handleChange(this,r)}get(){}}function le(t,n,e){const r=g("debounced",void 0);let a;return e.add(f(s=>{const i=t.read(s);a&&clearTimeout(a),a=setTimeout(()=>{h(o=>{r.set(i,o)})},n)})),r}function be(t,n){let e=!1,r,a;return l(s=>{const i=f(o=>{const d=t.read(o);e?(a&&clearTimeout(a),a=setTimeout(()=>{r=d,s()},n)):(e=!0,r=d)});return{dispose(){i.dispose(),e=!1,r=void 0}}},()=>e?r:t.get())}function ve(t,n,e){const r=g("triggeredRecently",!1);let a;return e.add(t(()=>{r.set(!0,void 0),a&&clearTimeout(a),a=setTimeout(()=>{r.set(!1,void 0)},n)})),r}function q(t){const n=new y(!1,void 0);return t.addObserver(n),T(()=>{t.removeObserver(n)})}V(q);function K(t,n){const e=new y(!0,n);return t.addObserver(e),n?n(t.get()):t.reportChanges(),T(()=>{t.removeObserver(e)})}x(K);class y{constructor(n,e){this._forceRecompute=n;this._handleValue=e}_counter=0;beginUpdate(n){this._counter++}endUpdate(n){this._counter--,this._counter===0&&this._forceRecompute&&(this._handleValue?this._handleValue(n.get()):n.reportChanges())}handlePossibleChange(n){}handleChange(n,e){}}function L(t,n){let e;return p({owner:t,debugReferenceFn:n},a=>(e=n(a,e),e))}function ce(t,n){let e;const r=k("derivedObservableWithWritableCache"),a=N(t,s=>(r.read(s),e=n(s,e),e));return Object.assign(a,{clearCache:s=>{e=void 0,r.trigger(s)},setCache:(s,i)=>{e=s,r.trigger(i)}})}function ge(t,n,e,r){let a=new C(e,r);return p({debugReferenceFn:e,owner:t,onLastObserverRemoved:()=>{a.dispose(),a=new C(e)}},i=>(a.setItems(n.read(i)),a.getItems()))}class C{constructor(n,e){this._map=n;this._keySelector=e}_cache=new Map;_items=[];dispose(){this._cache.forEach(n=>n.store.dispose()),this._cache.clear()}setItems(n){const e=[],r=new Set(this._cache.keys());for(const a of n){const s=this._keySelector?this._keySelector(a):a;let i=this._cache.get(s);if(i)r.delete(s);else{const o=new v;i={out:this._map(a,o),store:o},this._cache.set(s,i)}e.push(i.out)}for(const a of r)this._cache.get(a).store.dispose(),this._cache.delete(a);this._items=e}getItems(){return this._items}}class U{constructor(n){this.observable=n}get onDidChange(){return D.fromObservableLight(this.observable)}get value(){return this.observable.get()}}function he(t,n){return n instanceof U?n.observable:l(t,n.onDidChange,()=>n.value)}function Te(t,n){if(n.length===0)throw new A;let e=!1,r;const a=l(t,s=>{const i=new v;for(const o of n)i.add(w({debugName:()=>R(a,new b(t,void 0,void 0))+".updateLastChangedValue"},d=>{e=!0,r=o.read(d),s()}));return i.add({dispose(){e=!1,r=void 0}}),i},()=>e?r:n[n.length-1].get());return a}function fe(t,n){return L(t,(e,r)=>r??n(e))}function j(t,n){return E({createEmptyChangeSummary:()=>({deltas:[],didChange:!1}),handleChange:(e,r)=>{if(e.didChange(t)){const a=e.change;a!==void 0&&r.deltas.push(a),r.didChange=!0}return!0}},(e,r)=>{const a=t.read(e);r.didChange&&n(a,r.deltas)})}function pe(t,n){const e=new v,r=j(t,(a,s)=>{e.clear(),n(a,s,e)});return{dispose(){r.dispose(),e.dispose()}}}export{u as FromEventObservable,y as KeepAliveObserver,U as ValueWithChangeEventFromObservable,ie as constObservable,le as debouncedObservable,be as debouncedObservable2,fe as derivedConstOnceDefined,L as derivedObservableWithCache,ce as derivedObservableWithWritableCache,q as keepObserved,Te as latestChangedValue,ge as mapObservableArrayCached,l as observableFromEvent,de as observableFromEventOpts,oe as observableFromPromise,he as observableFromValueWithChangeEvent,k as observableSignal,ue as observableSignalFromEvent,K as recomputeInitiallyAndOnChange,j as runOnChange,pe as runOnChangeWithStore,ve as wasEventTriggeredRecently};
