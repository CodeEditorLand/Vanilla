import{autorun as f,autorunOpts as D,autorunWithStoreHandleChanges as w}from"./autorun.js";import{BaseObservable as v,ConvenientObservable as V,_setKeepObserved as _,_setRecomputeInitiallyAndOnChange as E,observableValue as c,subtransaction as x,transaction as g}from"./base.js";import{DebugNameData as b,getDebugName as S}from"./debugName.js";import{BugIndicatingError as R,DisposableStore as h,Event as N,strictEquals as p,toDisposable as m}from"./commonFacade/deps.js";import{derived as A,derivedOpts as T}from"./derived.js";import{getLogger as O}from"./logging.js";function re(t){return new F(t)}class F extends V{constructor(e){super();this.value=e}get debugName(){return this.toString()}get(){return this.value}addObserver(e){}removeObserver(e){}toString(){return`Const: ${this.value}`}}function ae(t){const n=c("promiseValue",{});return t.then(e=>{n.set({value:e},void 0)}),n}function l(...t){let n,e,r;return t.length===3?[n,e,r]=t:[e,r]=t,new u(new b(n,void 0,r),e,r,()=>u.globalTransaction,p)}function se(t,n,e){return new u(new b(t.owner,t.debugName,t.debugReferenceFn??e),n,e,()=>u.globalTransaction,t.equalsFn??p)}class u extends v{constructor(e,r,a,s,i){super();this._debugNameData=e;this.event=r;this._getValue=a;this._getTransaction=s;this._equalityComparator=i}static globalTransaction;value;hasValue=!1;subscription;getDebugName(){return this._debugNameData.getDebugName(this)}get debugName(){const e=this.getDebugName();return"From Event"+(e?`: ${e}`:"")}onFirstObserverAdded(){this.subscription=this.event(this.handleEvent)}handleEvent=e=>{const r=this._getValue(e),a=this.value,s=!this.hasValue||!this._equalityComparator(a,r);let i=!1;s&&(this.value=r,this.hasValue&&(i=!0,x(this._getTransaction(),o=>{O()?.handleFromEventObservableTriggered(this,{oldValue:a,newValue:r,change:void 0,didChange:s,hadValue:this.hasValue});for(const d of this.observers)o.updateObserver(d,this),d.handleChange(this,void 0)},()=>{const o=this.getDebugName();return"Event fired"+(o?`: ${o}`:"")})),this.hasValue=!0),i||O()?.handleFromEventObservableTriggered(this,{oldValue:a,newValue:r,change:void 0,didChange:s,hadValue:this.hasValue})};onLastObserverRemoved(){this.subscription.dispose(),this.subscription=void 0,this.hasValue=!1,this.value=void 0}get(){return this.subscription?(this.hasValue||this.handleEvent(void 0),this.value):this._getValue(void 0)}}(e=>{e.Observer=u;function n(r,a){let s=!1;u.globalTransaction===void 0&&(u.globalTransaction=r,s=!0);try{a()}finally{s&&(u.globalTransaction=void 0)}}e.batchEventsGlobally=n})(l||={});function ie(t,n){return new W(t,n)}class W extends v{constructor(e,r){super();this.debugName=e;this.event=r}subscription;onFirstObserverAdded(){this.subscription=this.event(this.handleEvent)}handleEvent=()=>{g(e=>{for(const r of this.observers)e.updateObserver(r,this),r.handleChange(this,void 0)},()=>this.debugName)};onLastObserverRemoved(){this.subscription.dispose(),this.subscription=void 0}get(){}}function k(t){return typeof t=="string"?new I(t):new I(void 0,t)}class I extends v{constructor(e,r){super();this._debugName=e;this._owner=r}get debugName(){return new b(this._owner,this._debugName,void 0).getDebugName(this)??"Observable Signal"}toString(){return this.debugName}trigger(e,r){if(!e){g(a=>{this.trigger(a,r)},()=>`Trigger signal ${this.debugName}`);return}for(const a of this.observers)e.updateObserver(a,this),a.handleChange(this,r)}get(){}}function oe(t,n){return T({owner:t,equalsFn:()=>!1},e=>{n.read(e)})}function de(t,n,e){const r=c("debounced",void 0);let a;return e.add(f(s=>{const i=t.read(s);a&&clearTimeout(a),a=setTimeout(()=>{g(o=>{r.set(i,o)})},n)})),r}function ue(t,n){let e=!1,r,a;return l(s=>{const i=f(o=>{const d=t.read(o);e?(a&&clearTimeout(a),a=setTimeout(()=>{r=d,s()},n)):(e=!0,r=d)});return{dispose(){i.dispose(),e=!1,r=void 0}}},()=>e?r:t.get())}function le(t,n,e){const r=c("triggeredRecently",!1);let a;return e.add(t(()=>{r.set(!0,void 0),a&&clearTimeout(a),a=setTimeout(()=>{r.set(!1,void 0)},n)})),r}function q(t){const n=new y(!1,void 0);return t.addObserver(n),m(()=>{t.removeObserver(n)})}_(q);function K(t,n){const e=new y(!0,n);return t.addObserver(e),n?n(t.get()):t.reportChanges(),m(()=>{t.removeObserver(e)})}E(K);class y{constructor(n,e){this._forceRecompute=n;this._handleValue=e}_counter=0;beginUpdate(n){this._counter++}endUpdate(n){this._counter--,this._counter===0&&this._forceRecompute&&(this._handleValue?this._handleValue(n.get()):n.reportChanges())}handlePossibleChange(n){}handleChange(n,e){}}function L(t,n){let e;return T({owner:t,debugReferenceFn:n},a=>(e=n(a,e),e))}function be(t,n){let e;const r=k("derivedObservableWithWritableCache"),a=A(t,s=>(r.read(s),e=n(s,e),e));return Object.assign(a,{clearCache:s=>{e=void 0,r.trigger(s)},setCache:(s,i)=>{e=s,r.trigger(i)}})}function ve(t,n,e,r){let a=new C(e,r);return T({debugReferenceFn:e,owner:t,onLastObserverRemoved:()=>{a.dispose(),a=new C(e)}},i=>(a.setItems(n.read(i)),a.getItems()))}class C{constructor(n,e){this._map=n;this._keySelector=e}_cache=new Map;_items=[];dispose(){this._cache.forEach(n=>n.store.dispose()),this._cache.clear()}setItems(n){const e=[],r=new Set(this._cache.keys());for(const a of n){const s=this._keySelector?this._keySelector(a):a;let i=this._cache.get(s);if(i)r.delete(s);else{const o=new h;i={out:this._map(a,o),store:o},this._cache.set(s,i)}e.push(i.out)}for(const a of r)this._cache.get(a).store.dispose(),this._cache.delete(a);this._items=e}getItems(){return this._items}}class U{constructor(n){this.observable=n}get onDidChange(){return N.fromObservableLight(this.observable)}get value(){return this.observable.get()}}function ce(t,n){return n instanceof U?n.observable:l(t,n.onDidChange,()=>n.value)}function ge(t,n){if(n.length===0)throw new R;let e=!1,r;const a=l(t,s=>{const i=new h;for(const o of n)i.add(D({debugName:()=>S(a,new b(t,void 0,void 0))+".updateLastChangedValue"},d=>{e=!0,r=o.read(d),s()}));return i.add({dispose(){e=!1,r=void 0}}),i},()=>e?r:n[n.length-1].get());return a}function he(t,n){return L(t,(e,r)=>r??n(e))}function j(t,n){let e;return w({createEmptyChangeSummary:()=>({deltas:[],didChange:!1}),handleChange:(r,a)=>{if(r.didChange(t)){const s=r.change;s!==void 0&&a.deltas.push(s),a.didChange=!0}return!0}},(r,a)=>{const s=t.read(r),i=e;a.didChange&&(e=s,n(s,i,a.deltas))})}function Te(t,n){const e=new h,r=j(t,(a,s,i)=>{e.clear(),n(a,s,i,e)});return{dispose(){r.dispose(),e.dispose()}}}export{u as FromEventObservable,y as KeepAliveObserver,U as ValueWithChangeEventFromObservable,re as constObservable,de as debouncedObservable,ue as debouncedObservable2,he as derivedConstOnceDefined,L as derivedObservableWithCache,be as derivedObservableWithWritableCache,q as keepObserved,ge as latestChangedValue,ve as mapObservableArrayCached,l as observableFromEvent,se as observableFromEventOpts,ae as observableFromPromise,ce as observableFromValueWithChangeEvent,k as observableSignal,ie as observableSignalFromEvent,K as recomputeInitiallyAndOnChange,j as runOnChange,Te as runOnChangeWithStore,oe as signalFromObservable,le as wasEventTriggeredRecently};
