{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/observableInternal/utilsCancellation.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IReader, IObservable } from './base.js';\nimport { DebugOwner, DebugNameData } from './debugName.js';\nimport { CancellationError, CancellationToken, CancellationTokenSource } from './commonFacade/cancellation.js';\nimport { Derived } from './derived.js';\nimport { strictEquals } from './commonFacade/deps.js';\nimport { autorun } from './autorun.js';\n\n/**\n * Resolves the promise when the observables state matches the predicate.\n */\nexport function waitForState<T>(observable: IObservable<T | null | undefined>): Promise<T>;\nexport function waitForState<T, TState extends T>(observable: IObservable<T>, predicate: (state: T) => state is TState, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<TState>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<T>;\nexport function waitForState<T>(observable: IObservable<T>, predicate?: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<T> {\n\tif (!predicate) {\n\t\tpredicate = state => state !== null && state !== undefined;\n\t}\n\treturn new Promise((resolve, reject) => {\n\t\tlet isImmediateRun = true;\n\t\tlet shouldDispose = false;\n\t\tconst stateObs = observable.map(state => {\n\t\t\t/** @description waitForState.state */\n\t\t\treturn {\n\t\t\t\tisFinished: predicate(state),\n\t\t\t\terror: isError ? isError(state) : false,\n\t\t\t\tstate\n\t\t\t};\n\t\t});\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description waitForState */\n\t\t\tconst { isFinished, error, state } = stateObs.read(reader);\n\t\t\tif (isFinished || error) {\n\t\t\t\tif (isImmediateRun) {\n\t\t\t\t\t// The variable `d` is not initialized yet\n\t\t\t\t\tshouldDispose = true;\n\t\t\t\t} else {\n\t\t\t\t\td.dispose();\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error === true ? state : error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(state);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (cancellationToken) {\n\t\t\tconst dc = cancellationToken.onCancellationRequested(() => {\n\t\t\t\td.dispose();\n\t\t\t\tdc.dispose();\n\t\t\t\treject(new CancellationError());\n\t\t\t});\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\td.dispose();\n\t\t\t\tdc.dispose();\n\t\t\t\treject(new CancellationError());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tisImmediateRun = false;\n\t\tif (shouldDispose) {\n\t\t\td.dispose();\n\t\t}\n\t});\n}\n\nexport function derivedWithCancellationToken<T>(computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(owner: object, computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(computeFnOrOwner: ((reader: IReader, cancellationToken: CancellationToken) => T) | object, computeFnOrUndefined?: ((reader: IReader, cancellationToken: CancellationToken) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: CancellationToken) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet cancellationTokenSource: CancellationTokenSource | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (cancellationTokenSource) {\n\t\t\t\tcancellationTokenSource.dispose(true);\n\t\t\t}\n\t\t\tcancellationTokenSource = new CancellationTokenSource();\n\t\t\treturn computeFn(r, cancellationTokenSource.token);\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => cancellationTokenSource?.dispose(),\n\t\tstrictEquals\n\t);\n}\n"],
  "mappings": ";;AAKA,SAAS,SAAS,mBAAmB;AACrC,SAAS,YAAY,qBAAqB;AAC1C,SAAS,mBAAmB,mBAAmB,+BAA+B;AAC9E,SAAS,eAAe;AACxB,SAAS,oBAAoB;AAC7B,SAAS,eAAe;AAQjB,SAAS,aAAgB,YAA4B,WAAmC,SAAuD,mBAAmD;AACxM,MAAI,CAAC,WAAW;AACf,gBAAY,kCAAS,UAAU,QAAQ,UAAU,QAArC;AAAA,EACb;AACA,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,QAAI,iBAAiB;AACrB,QAAI,gBAAgB;AACpB,UAAM,WAAW,WAAW,IAAI,WAAS;AAExC,aAAO;AAAA,QACN,YAAY,UAAU,KAAK;AAAA,QAC3B,OAAO,UAAU,QAAQ,KAAK,IAAI;AAAA,QAClC;AAAA,MACD;AAAA,IACD,CAAC;AACD,UAAM,IAAI,QAAQ,YAAU;AAE3B,YAAM,EAAE,YAAY,OAAO,MAAM,IAAI,SAAS,KAAK,MAAM;AACzD,UAAI,cAAc,OAAO;AACxB,YAAI,gBAAgB;AAEnB,0BAAgB;AAAA,QACjB,OAAO;AACN,YAAE,QAAQ;AAAA,QACX;AACA,YAAI,OAAO;AACV,iBAAO,UAAU,OAAO,QAAQ,KAAK;AAAA,QACtC,OAAO;AACN,kBAAQ,KAAK;AAAA,QACd;AAAA,MACD;AAAA,IACD,CAAC;AACD,QAAI,mBAAmB;AACtB,YAAM,KAAK,kBAAkB,wBAAwB,MAAM;AAC1D,UAAE,QAAQ;AACV,WAAG,QAAQ;AACX,eAAO,IAAI,kBAAkB,CAAC;AAAA,MAC/B,CAAC;AACD,UAAI,kBAAkB,yBAAyB;AAC9C,UAAE,QAAQ;AACV,WAAG,QAAQ;AACX,eAAO,IAAI,kBAAkB,CAAC;AAC9B;AAAA,MACD;AAAA,IACD;AACA,qBAAiB;AACjB,QAAI,eAAe;AAClB,QAAE,QAAQ;AAAA,IACX;AAAA,EACD,CAAC;AACF;AAlDgB;AAsDT,SAAS,6BAAgC,kBAA2F,sBAAuG;AACjP,MAAI;AACJ,MAAI;AACJ,MAAI,yBAAyB,QAAW;AACvC,gBAAY;AACZ,YAAQ;AAAA,EACT,OAAO;AACN,YAAQ;AACR,gBAAY;AAAA,EACb;AAEA,MAAI,0BAA+D;AACnE,SAAO,IAAI;AAAA,IACV,IAAI,cAAc,OAAO,QAAW,SAAS;AAAA,IAC7C,OAAK;AACJ,UAAI,yBAAyB;AAC5B,gCAAwB,QAAQ,IAAI;AAAA,MACrC;AACA,gCAA0B,IAAI,wBAAwB;AACtD,aAAO,UAAU,GAAG,wBAAwB,KAAK;AAAA,IAClD;AAAA,IAAG;AAAA,IACH;AAAA,IACA,MAAM,yBAAyB,QAAQ;AAAA,IACvC;AAAA,EACD;AACD;AAzBgB;",
  "names": []
}
