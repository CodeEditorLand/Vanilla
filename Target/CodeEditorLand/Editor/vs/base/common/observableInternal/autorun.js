import{DisposableStore as o,assertFn as p,markAsDisposed as l,onBugIndicatingError as h,toDisposable as m,trackDisposable as b}from"./commonFacade/deps.js";import{DebugNameData as i}from"./debugName.js";import{getLogger as u}from"./logging.js";function c(a){return new s(new i(void 0,void 0,a),a,void 0,void 0)}function g(a,e){return new s(new i(a.owner,a.debugName,a.debugReferenceFn??e),e,void 0,void 0)}function y(a,e){return new s(new i(a.owner,a.debugName,a.debugReferenceFn??e),e,a.createEmptyChangeSummary,a.handleChange)}function T(a,e){const n=new o,t=y({owner:a.owner,debugName:a.debugName,debugReferenceFn:a.debugReferenceFn??e,createEmptyChangeSummary:a.createEmptyChangeSummary,handleChange:a.handleChange},(r,d)=>{n.clear(),e(r,d,n)});return m(()=>{t.dispose(),n.dispose()})}function D(a){const e=new o,n=g({owner:void 0,debugName:void 0,debugReferenceFn:a},t=>{e.clear(),a(t,e)});return m(()=>{n.dispose(),e.dispose()})}function I(a,e){let n;return g({debugReferenceFn:e},t=>{const r=a.read(t),d=n;n=r,e({lastValue:d,newValue:r})})}var C=(t=>(t[t.dependenciesMightHaveChanged=1]="dependenciesMightHaveChanged",t[t.stale=2]="stale",t[t.upToDate=3]="upToDate",t))(C||{});class s{constructor(e,n,t,r){this._debugNameData=e;this._runFn=n;this.createChangeSummary=t;this._handleChange=r;this.changeSummary=this.createChangeSummary?.(),u()?.handleAutorunCreated(this),this._runIfNeeded(),b(this)}state=2;updateCount=0;disposed=!1;dependencies=new Set;dependenciesToBeRemoved=new Set;changeSummary;get debugName(){return this._debugNameData.getDebugName(this)??"(anonymous)"}dispose(){this.disposed=!0;for(const e of this.dependencies)e.removeObserver(this);this.dependencies.clear(),l(this)}_runIfNeeded(){if(this.state===3)return;const e=this.dependenciesToBeRemoved;this.dependenciesToBeRemoved=this.dependencies,this.dependencies=e,this.state=3;const n=this.disposed;try{if(!n){u()?.handleAutorunTriggered(this);const t=this.changeSummary;try{this.changeSummary=this.createChangeSummary?.(),this._runFn(this,t)}catch(r){h(r)}}}finally{n||u()?.handleAutorunFinished(this);for(const t of this.dependenciesToBeRemoved)t.removeObserver(this);this.dependenciesToBeRemoved.clear()}}toString(){return`Autorun<${this.debugName}>`}beginUpdate(){this.state===3&&(this.state=1),this.updateCount++}endUpdate(){try{if(this.updateCount===1)do{if(this.state===1){this.state=3;for(const e of this.dependencies)if(e.reportChanges(),this.state===2)break}this._runIfNeeded()}while(this.state!==3)}finally{this.updateCount--}p(()=>this.updateCount>=0)}handlePossibleChange(e){this.state===3&&this.dependencies.has(e)&&!this.dependenciesToBeRemoved.has(e)&&(this.state=1)}handleChange(e,n){if(this.dependencies.has(e)&&!this.dependenciesToBeRemoved.has(e))try{(this._handleChange?this._handleChange({changedObservable:e,change:n,didChange:r=>r===e},this.changeSummary):!0)&&(this.state=2)}catch(t){h(t)}}readObservable(e){if(this.disposed)return e.get();e.addObserver(this);const n=e.get();return this.dependencies.add(e),this.dependenciesToBeRemoved.delete(e),n}}(e=>e.Observer=s)(c||={});export{s as AutorunObserver,c as autorun,I as autorunDelta,y as autorunHandleChanges,g as autorunOpts,D as autorunWithStore,T as autorunWithStoreHandleChanges};
