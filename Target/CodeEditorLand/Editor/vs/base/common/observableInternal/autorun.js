import{assertFn as p}from"../../../../vs/base/common/assert.js";import{DisposableStore as o,markAsDisposed as c,toDisposable as h,trackDisposable as l}from"../../../../vs/base/common/lifecycle.js";import"../../../../vs/base/common/observableInternal/base.js";import{DebugNameData as i}from"../../../../vs/base/common/observableInternal/debugName.js";import{getLogger as u}from"../../../../vs/base/common/observableInternal/logging.js";function g(a){return new s(new i(void 0,void 0,a),a,void 0,void 0)}function m(a,e){return new s(new i(a.owner,a.debugName,a.debugReferenceFn??e),e,void 0,void 0)}function b(a,e){return new s(new i(a.owner,a.debugName,a.debugReferenceFn??e),e,a.createEmptyChangeSummary,a.handleChange)}function x(a,e){const n=new o,t=b({owner:a.owner,debugName:a.debugName,debugReferenceFn:a.debugReferenceFn??e,createEmptyChangeSummary:a.createEmptyChangeSummary,handleChange:a.handleChange},(r,d)=>{n.clear(),e(r,d,n)});return h(()=>{t.dispose(),n.dispose()})}function A(a){const e=new o,n=m({owner:void 0,debugName:void 0,debugReferenceFn:a},t=>{e.clear(),a(t,e)});return h(()=>{n.dispose(),e.dispose()})}function _(a,e){let n;return m({debugReferenceFn:e},t=>{const r=a.read(t),d=n;n=r,e({lastValue:d,newValue:r})})}var C=(t=>(t[t.dependenciesMightHaveChanged=1]="dependenciesMightHaveChanged",t[t.stale=2]="stale",t[t.upToDate=3]="upToDate",t))(C||{});class s{constructor(e,n,t,r){this._debugNameData=e;this._runFn=n;this.createChangeSummary=t;this._handleChange=r;this.changeSummary=this.createChangeSummary?.(),u()?.handleAutorunCreated(this),this._runIfNeeded(),l(this)}state=2;updateCount=0;disposed=!1;dependencies=new Set;dependenciesToBeRemoved=new Set;changeSummary;get debugName(){return this._debugNameData.getDebugName(this)??"(anonymous)"}dispose(){this.disposed=!0;for(const e of this.dependencies)e.removeObserver(this);this.dependencies.clear(),c(this)}_runIfNeeded(){if(this.state===3)return;const e=this.dependenciesToBeRemoved;this.dependenciesToBeRemoved=this.dependencies,this.dependencies=e,this.state=3;const n=this.disposed;try{if(!n){u()?.handleAutorunTriggered(this);const t=this.changeSummary;this.changeSummary=this.createChangeSummary?.(),this._runFn(this,t)}}finally{n||u()?.handleAutorunFinished(this);for(const t of this.dependenciesToBeRemoved)t.removeObserver(this);this.dependenciesToBeRemoved.clear()}}toString(){return`Autorun<${this.debugName}>`}beginUpdate(){this.state===3&&(this.state=1),this.updateCount++}endUpdate(){if(this.updateCount===1)do{if(this.state===1){this.state=3;for(const e of this.dependencies)if(e.reportChanges(),this.state===2)break}this._runIfNeeded()}while(this.state!==3);this.updateCount--,p(()=>this.updateCount>=0)}handlePossibleChange(e){this.state===3&&this.dependencies.has(e)&&!this.dependenciesToBeRemoved.has(e)&&(this.state=1)}handleChange(e,n){this.dependencies.has(e)&&!this.dependenciesToBeRemoved.has(e)&&(!this._handleChange||this._handleChange({changedObservable:e,change:n,didChange:r=>r===e},this.changeSummary))&&(this.state=2)}readObservable(e){if(this.disposed)return e.get();e.addObserver(this);const n=e.get();return this.dependencies.add(e),this.dependenciesToBeRemoved.delete(e),n}}(e=>e.Observer=s)(g||={});export{s as AutorunObserver,g as autorun,_ as autorunDelta,b as autorunHandleChanges,m as autorunOpts,A as autorunWithStore,x as autorunWithStoreHandleChanges};
