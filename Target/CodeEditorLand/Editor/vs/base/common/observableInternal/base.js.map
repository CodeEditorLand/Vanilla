{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/observableInternal/base.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DebugNameData, DebugOwner, getFunctionName } from './debugName.js';\nimport { DisposableStore, EqualityComparer, IDisposable, strictEquals } from './commonFacade/deps.js';\nimport type { derivedOpts } from './derived.js';\nimport { getLogger } from './logging.js';\nimport { keepObserved, recomputeInitiallyAndOnChange } from './utils.js';\n\n/**\n * Represents an observable value.\n *\n * @template T The type of the values the observable can hold.\n * @template TChange The type used to describe value changes\n * (usually `void` and only used in advanced scenarios).\n * While observers can miss temporary values of an observable,\n * they will receive all change values (as long as they are subscribed)!\n */\nexport interface IObservable<T, TChange = unknown> {\n\t/**\n\t * Returns the current value.\n\t *\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\tget(): T;\n\n\t/**\n\t * Forces the observable to check for changes and report them.\n\t *\n\t * Has the same effect as calling {@link IObservable.get}, but does not force the observable\n\t * to actually construct the value, e.g. if change deltas are used.\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\treportChanges(): void;\n\n\t/**\n\t * Adds the observer to the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\taddObserver(observer: IObserver): void;\n\n\t/**\n\t * Removes the observer from the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\tremoveObserver(observer: IObserver): void;\n\n\t/**\n\t * Reads the current value and subscribes the reader to this observable.\n\t *\n\t * Calls {@link IReader.readObservable} if a reader is given, otherwise {@link IObservable.get}\n\t * (see {@link ConvenientObservable.read} for the implementation).\n\t */\n\tread(reader: IReader | undefined): T;\n\n\t/**\n\t * Creates a derived observable that depends on this observable.\n\t * Use the reader to read other observables\n\t * (see {@link ConvenientObservable.map} for the implementation).\n\t */\n\tmap<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tmap<TNew>(owner: object, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\n\tflatten<TNew>(this: IObservable<IObservable<TNew>>): IObservable<TNew>;\n\n\t/**\n\t * Makes sure this value is computed eagerly.\n\t */\n\trecomputeInitiallyAndOnChange(store: DisposableStore, handleValue?: (value: T) => void): IObservable<T>;\n\n\t/**\n\t * Makes sure this value is cached.\n\t */\n\tkeepObserved(store: DisposableStore): IObservable<T>;\n\n\t/**\n\t * A human-readable name for debugging purposes.\n\t */\n\treadonly debugName: string;\n\n\t/**\n\t * This property captures the type of the change object. Do not use it at runtime!\n\t */\n\treadonly TChange: TChange;\n}\n\nexport interface IReader {\n\t/**\n\t * Reads the value of an observable and subscribes to it.\n\t */\n\treadObservable<T>(observable: IObservable<T, any>): T;\n}\n\n/**\n * Represents an observer that can be subscribed to an observable.\n *\n * If an observer is subscribed to an observable and that observable didn't signal\n * a change through one of the observer methods, the observer can assume that the\n * observable didn't change.\n * If an observable reported a possible change, {@link IObservable.reportChanges} forces\n * the observable to report an actual change if there was one.\n */\nexport interface IObserver {\n\t/**\n\t * Signals that the given observable might have changed and a transaction potentially modifying that observable started.\n\t * Before the given observable can call this method again, is must call {@link IObserver.endUpdate}.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t */\n\tbeginUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the transaction that potentially modified the given observable ended.\n\t * This is a good place to react to (potential) changes.\n\t */\n\tendUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given observable might have changed.\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t */\n\thandlePossibleChange<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given {@link observable} changed.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t *\n\t * @param change Indicates how or why the value changed.\n\t */\n\thandleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;\n}\n\nexport interface ISettable<T, TChange = void> {\n\t/**\n\t * Sets the value of the observable.\n\t * Use a transaction to batch multiple changes (with a transaction, observers only react at the end of the transaction).\n\t *\n\t * @param transaction When given, value changes are handled on demand or when the transaction ends.\n\t * @param change Describes how or why the value changed.\n\t */\n\tset(value: T, transaction: ITransaction | undefined, change: TChange): void;\n}\n\nexport interface ITransaction {\n\t/**\n\t * Calls {@link Observer.beginUpdate} immediately\n\t * and {@link Observer.endUpdate} when the transaction ends.\n\t */\n\tupdateObserver(observer: IObserver, observable: IObservable<any, any>): void;\n}\n\nlet _recomputeInitiallyAndOnChange: typeof recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange: typeof _recomputeInitiallyAndOnChange) {\n\t_recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\n\nlet _keepObserved: typeof keepObserved;\nexport function _setKeepObserved(keepObserved: typeof _keepObserved) {\n\t_keepObserved = keepObserved;\n}\n\n\nlet _derived: typeof derivedOpts;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived: typeof _derived) {\n\t_derived = derived;\n}\n\nexport abstract class ConvenientObservable<T, TChange> implements IObservable<T, TChange> {\n\tget TChange(): TChange { return null!; }\n\n\tpublic abstract get(): T;\n\n\tpublic reportChanges(): void {\n\t\tthis.get();\n\t}\n\n\tpublic abstract addObserver(observer: IObserver): void;\n\tpublic abstract removeObserver(observer: IObserver): void;\n\n\t/** @sealed */\n\tpublic read(reader: IReader | undefined): T {\n\t\tif (reader) {\n\t\t\treturn reader.readObservable(this);\n\t\t} else {\n\t\t\treturn this.get();\n\t\t}\n\t}\n\n\t/** @sealed */\n\tpublic map<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(owner: DebugOwner, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(fnOrOwner: DebugOwner | ((value: T, reader: IReader) => TNew), fnOrUndefined?: (value: T, reader: IReader) => TNew): IObservable<TNew> {\n\t\tconst owner = fnOrUndefined === undefined ? undefined : fnOrOwner as DebugOwner;\n\t\tconst fn = fnOrUndefined === undefined ? fnOrOwner as (value: T, reader: IReader) => TNew : fnOrUndefined;\n\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner,\n\t\t\t\tdebugName: () => {\n\t\t\t\t\tconst name = getFunctionName(fn);\n\t\t\t\t\tif (name !== undefined) {\n\t\t\t\t\t\treturn name;\n\t\t\t\t\t}\n\n\t\t\t\t\t// regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n\t\t\t\t\tconst regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n\t\t\t\t\tconst match = regexp.exec(fn.toString());\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\treturn `${this.debugName}.${match[2]}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (!owner) {\n\t\t\t\t\t\treturn `${this.debugName} (mapped)`;\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t\tdebugReferenceFn: fn,\n\t\t\t},\n\t\t\t(reader) => fn(this.read(reader), reader),\n\t\t);\n\t}\n\n\t/**\n\t * @sealed\n\t * Converts an observable of an observable value into a direct observable of the value.\n\t*/\n\tpublic flatten<TNew>(this: IObservable<IObservable<TNew, any>>): IObservable<TNew, unknown> {\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner: undefined,\n\t\t\t\tdebugName: () => `${this.debugName} (flattened)`,\n\t\t\t},\n\t\t\t(reader) => this.read(reader).read(reader),\n\t\t);\n\t}\n\n\tpublic recomputeInitiallyAndOnChange(store: DisposableStore, handleValue?: (value: T) => void): IObservable<T> {\n\t\tstore.add(_recomputeInitiallyAndOnChange!(this, handleValue));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ensures that this observable is observed. This keeps the cache alive.\n\t * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).\n\t * Use `recomputeInitiallyAndOnChange` for eager evaluation.\n\t */\n\tpublic keepObserved(store: DisposableStore): IObservable<T> {\n\t\tstore.add(_keepObserved!(this));\n\t\treturn this;\n\t}\n\n\tpublic abstract get debugName(): string;\n\n\tprotected get debugValue() {\n\t\treturn this.get();\n\t}\n}\n\nexport abstract class BaseObservable<T, TChange = void> extends ConvenientObservable<T, TChange> {\n\tprotected readonly observers = new Set<IObserver>();\n\n\tpublic addObserver(observer: IObserver): void {\n\t\tconst len = this.observers.size;\n\t\tthis.observers.add(observer);\n\t\tif (len === 0) {\n\t\t\tthis.onFirstObserverAdded();\n\t\t}\n\t}\n\n\tpublic removeObserver(observer: IObserver): void {\n\t\tconst deleted = this.observers.delete(observer);\n\t\tif (deleted && this.observers.size === 0) {\n\t\t\tthis.onLastObserverRemoved();\n\t\t}\n\t}\n\n\tprotected onFirstObserverAdded(): void { }\n\tprotected onLastObserverRemoved(): void { }\n}\n\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\n\nexport function transaction(fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tfn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\n\nlet _globalTransaction: ITransaction | undefined = undefined;\n\nexport function globalTransaction(fn: (tx: ITransaction) => void) {\n\tif (_globalTransaction) {\n\t\tfn(_globalTransaction);\n\t} else {\n\t\tconst tx = new TransactionImpl(fn, undefined);\n\t\t_globalTransaction = tx;\n\t\ttry {\n\t\t\tfn(tx);\n\t\t} finally {\n\t\t\ttx.finish(); // During finish, more actions might be added to the transaction.\n\t\t\t// Which is why we only clear the global transaction after finish.\n\t\t\t_globalTransaction = undefined;\n\t\t}\n\t}\n}\n\nexport async function asyncTransaction(fn: (tx: ITransaction) => Promise<void>, getDebugName?: () => string): Promise<void> {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tawait fn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\n\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx: ITransaction | undefined, fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tif (!tx) {\n\t\ttransaction(fn, getDebugName);\n\t} else {\n\t\tfn(tx);\n\t}\n}\n\nexport class TransactionImpl implements ITransaction {\n\tprivate updatingObservers: { observer: IObserver; observable: IObservable<any> }[] | null = [];\n\n\tconstructor(public readonly _fn: Function, private readonly _getDebugName?: () => string) {\n\t\tgetLogger()?.handleBeginTransaction(this);\n\t}\n\n\tpublic getDebugName(): string | undefined {\n\t\tif (this._getDebugName) {\n\t\t\treturn this._getDebugName();\n\t\t}\n\t\treturn getFunctionName(this._fn);\n\t}\n\n\tpublic updateObserver(observer: IObserver, observable: IObservable<any>): void {\n\t\t// When this gets called while finish is active, they will still get considered\n\t\tthis.updatingObservers!.push({ observer, observable });\n\t\tobserver.beginUpdate(observable);\n\t}\n\n\tpublic finish(): void {\n\t\tconst updatingObservers = this.updatingObservers!;\n\t\tfor (let i = 0; i < updatingObservers.length; i++) {\n\t\t\tconst { observer, observable } = updatingObservers[i];\n\t\t\tobserver.endUpdate(observable);\n\t\t}\n\t\t// Prevent anyone from updating observers from now on.\n\t\tthis.updatingObservers = null;\n\t\tgetLogger()?.handleEndTransaction();\n\t}\n}\n\n/**\n * A settable observable.\n */\nexport interface ISettableObservable<T, TChange = void> extends IObservable<T, TChange>, ISettable<T, TChange> {\n}\n\n/**\n * Creates an observable value.\n * Observers get informed when the value changes.\n * @template TChange An arbitrary type to describe how or why the value changed. Defaults to `void`.\n * Observers will receive every single change value.\n */\nexport function observableValue<T, TChange = void>(name: string, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(owner: object, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(nameOrOwner: string | object, initialValue: T): ISettableObservable<T, TChange> {\n\tlet debugNameData: DebugNameData;\n\tif (typeof nameOrOwner === 'string') {\n\t\tdebugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n\t} else {\n\t\tdebugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n\t}\n\treturn new ObservableValue(debugNameData, initialValue, strictEquals);\n}\n\nexport class ObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange> {\n\tprotected _value: T;\n\n\tget debugName() {\n\t\treturn this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tinitialValue: T,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t) {\n\t\tsuper();\n\t\tthis._value = initialValue;\n\t}\n\tpublic override get(): T {\n\t\treturn this._value;\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (change === undefined && this._equalityComparator(this._value, value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n\t\t}\n\t\ttry {\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._setValue(value);\n\t\t\tgetLogger()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n\n\t\t\tfor (const observer of this.observers) {\n\t\t\t\ttx.updateObserver(observer, this);\n\t\t\t\tobserver.handleChange(this, change);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n}\n\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue<T extends IDisposable | undefined, TChange = void>(nameOrOwner: string | object, initialValue: T): ISettableObservable<T, TChange> & IDisposable {\n\tlet debugNameData: DebugNameData;\n\tif (typeof nameOrOwner === 'string') {\n\t\tdebugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n\t} else {\n\t\tdebugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n\t}\n\treturn new DisposableObservableValue(debugNameData, initialValue, strictEquals);\n}\n\nexport class DisposableObservableValue<T extends IDisposable | undefined, TChange = void> extends ObservableValue<T, TChange> implements IDisposable {\n\tprotected override _setValue(newValue: T): void {\n\t\tif (this._value === newValue) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tthis._value = newValue;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._value?.dispose();\n\t}\n}\n\nexport interface IChangeTracker {\n\t/**\n\t * Returns if this change should cause an invalidation.\n\t * Implementations can record changes.\n\t*/\n\thandleChange(context: IChangeContext): boolean;\n}\n\nexport interface IChangeContext {\n\treadonly changedObservable: IObservable<any, any>;\n\treadonly change: unknown;\n\n\t/**\n\t * Returns if the given observable caused the change.\n\t */\n\tdidChange<T, TChange>(observable: IObservable<T, TChange>): this is { change: TChange };\n}\n"],
  "mappings": "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",
  "names": ["recomputeInitiallyAndOnChange", "keepObserved"]
}
