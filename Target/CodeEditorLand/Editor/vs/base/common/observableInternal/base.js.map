{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/observableInternal/base.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport {\n\ttype DisposableStore,\n\ttype EqualityComparer,\n\ttype IDisposable,\n\tstrictEquals,\n} from \"./commonFacade/deps.js\";\nimport {\n\tDebugNameData,\n\ttype DebugOwner,\n\tgetFunctionName,\n} from \"./debugName.js\";\nimport type { derivedOpts } from \"./derived.js\";\nimport { getLogger } from \"./logging.js\";\nimport type { keepObserved, recomputeInitiallyAndOnChange } from \"./utils.js\";\n\n/**\n * Represents an observable value.\n *\n * @template T The type of the values the observable can hold.\n * @template TChange The type used to describe value changes\n * (usually `void` and only used in advanced scenarios).\n * While observers can miss temporary values of an observable,\n * they will receive all change values (as long as they are subscribed)!\n */\nexport interface IObservable<T, TChange = unknown> {\n\t/**\n\t * Returns the current value.\n\t *\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\tget(): T;\n\n\t/**\n\t * Forces the observable to check for changes and report them.\n\t *\n\t * Has the same effect as calling {@link IObservable.get}, but does not force the observable\n\t * to actually construct the value, e.g. if change deltas are used.\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\treportChanges(): void;\n\n\t/**\n\t * Adds the observer to the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\taddObserver(observer: IObserver): void;\n\n\t/**\n\t * Removes the observer from the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\tremoveObserver(observer: IObserver): void;\n\n\t/**\n\t * Reads the current value and subscribes the reader to this observable.\n\t *\n\t * Calls {@link IReader.readObservable} if a reader is given, otherwise {@link IObservable.get}\n\t * (see {@link ConvenientObservable.read} for the implementation).\n\t */\n\tread(reader: IReader | undefined): T;\n\n\t/**\n\t * Creates a derived observable that depends on this observable.\n\t * Use the reader to read other observables\n\t * (see {@link ConvenientObservable.map} for the implementation).\n\t */\n\tmap<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tmap<TNew>(\n\t\towner: object,\n\t\tfn: (value: T, reader: IReader) => TNew,\n\t): IObservable<TNew>;\n\n\tflatten<TNew>(this: IObservable<IObservable<TNew>>): IObservable<TNew>;\n\n\t/**\n\t * Makes sure this value is computed eagerly.\n\t */\n\trecomputeInitiallyAndOnChange(\n\t\tstore: DisposableStore,\n\t\thandleValue?: (value: T) => void,\n\t): IObservable<T>;\n\n\t/**\n\t * Makes sure this value is cached.\n\t */\n\tkeepObserved(store: DisposableStore): IObservable<T>;\n\n\t/**\n\t * A human-readable name for debugging purposes.\n\t */\n\treadonly debugName: string;\n\n\t/**\n\t * This property captures the type of the change object. Do not use it at runtime!\n\t */\n\treadonly TChange: TChange;\n}\n\nexport interface IReader {\n\t/**\n\t * Reads the value of an observable and subscribes to it.\n\t */\n\treadObservable<T>(observable: IObservable<T, any>): T;\n}\n\n/**\n * Represents an observer that can be subscribed to an observable.\n *\n * If an observer is subscribed to an observable and that observable didn't signal\n * a change through one of the observer methods, the observer can assume that the\n * observable didn't change.\n * If an observable reported a possible change, {@link IObservable.reportChanges} forces\n * the observable to report an actual change if there was one.\n */\nexport interface IObserver {\n\t/**\n\t * Signals that the given observable might have changed and a transaction potentially modifying that observable started.\n\t * Before the given observable can call this method again, is must call {@link IObserver.endUpdate}.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t */\n\tbeginUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the transaction that potentially modified the given observable ended.\n\t * This is a good place to react to (potential) changes.\n\t */\n\tendUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given observable might have changed.\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t */\n\thandlePossibleChange<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given {@link observable} changed.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t *\n\t * @param change Indicates how or why the value changed.\n\t */\n\thandleChange<T, TChange>(\n\t\tobservable: IObservable<T, TChange>,\n\t\tchange: TChange,\n\t): void;\n}\n\nexport interface ISettable<T, TChange = void> {\n\t/**\n\t * Sets the value of the observable.\n\t * Use a transaction to batch multiple changes (with a transaction, observers only react at the end of the transaction).\n\t *\n\t * @param transaction When given, value changes are handled on demand or when the transaction ends.\n\t * @param change Describes how or why the value changed.\n\t */\n\tset(value: T, transaction: ITransaction | undefined, change: TChange): void;\n}\n\nexport interface ITransaction {\n\t/**\n\t * Calls {@link Observer.beginUpdate} immediately\n\t * and {@link Observer.endUpdate} when the transaction ends.\n\t */\n\tupdateObserver(\n\t\tobserver: IObserver,\n\t\tobservable: IObservable<any, any>,\n\t): void;\n}\n\nlet _recomputeInitiallyAndOnChange: typeof recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(\n\trecomputeInitiallyAndOnChange: typeof _recomputeInitiallyAndOnChange,\n) {\n\t_recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\n\nlet _keepObserved: typeof keepObserved;\nexport function _setKeepObserved(keepObserved: typeof _keepObserved) {\n\t_keepObserved = keepObserved;\n}\n\nlet _derived: typeof derivedOpts;\n/**\n * @internal\n * This is to allow splitting files.\n */\nexport function _setDerivedOpts(derived: typeof _derived) {\n\t_derived = derived;\n}\n\nexport abstract class ConvenientObservable<T, TChange>\n\timplements IObservable<T, TChange>\n{\n\tget TChange(): TChange {\n\t\treturn null!;\n\t}\n\n\tpublic abstract get(): T;\n\n\tpublic reportChanges(): void {\n\t\tthis.get();\n\t}\n\n\tpublic abstract addObserver(observer: IObserver): void;\n\tpublic abstract removeObserver(observer: IObserver): void;\n\n\t/** @sealed */\n\tpublic read(reader: IReader | undefined): T {\n\t\tif (reader) {\n\t\t\treturn reader.readObservable(this);\n\t\t} else {\n\t\t\treturn this.get();\n\t\t}\n\t}\n\n\t/** @sealed */\n\tpublic map<TNew>(\n\t\tfn: (value: T, reader: IReader) => TNew,\n\t): IObservable<TNew>;\n\tpublic map<TNew>(\n\t\towner: DebugOwner,\n\t\tfn: (value: T, reader: IReader) => TNew,\n\t): IObservable<TNew>;\n\tpublic map<TNew>(\n\t\tfnOrOwner: DebugOwner | ((value: T, reader: IReader) => TNew),\n\t\tfnOrUndefined?: (value: T, reader: IReader) => TNew,\n\t): IObservable<TNew> {\n\t\tconst owner =\n\t\t\tfnOrUndefined === undefined ? undefined : (fnOrOwner as DebugOwner);\n\t\tconst fn =\n\t\t\tfnOrUndefined === undefined\n\t\t\t\t? (fnOrOwner as (value: T, reader: IReader) => TNew)\n\t\t\t\t: fnOrUndefined;\n\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner,\n\t\t\t\tdebugName: () => {\n\t\t\t\t\tconst name = getFunctionName(fn);\n\t\t\t\t\tif (name !== undefined) {\n\t\t\t\t\t\treturn name;\n\t\t\t\t\t}\n\n\t\t\t\t\t// regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n\t\t\t\t\tconst regexp =\n\t\t\t\t\t\t/^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n\t\t\t\t\tconst match = regexp.exec(fn.toString());\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\treturn `${this.debugName}.${match[2]}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (!owner) {\n\t\t\t\t\t\treturn `${this.debugName} (mapped)`;\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t\tdebugReferenceFn: fn,\n\t\t\t},\n\t\t\t(reader) => fn(this.read(reader), reader),\n\t\t);\n\t}\n\n\t/**\n\t * @sealed\n\t * Converts an observable of an observable value into a direct observable of the value.\n\t */\n\tpublic flatten<TNew>(\n\t\tthis: IObservable<IObservable<TNew, any>>,\n\t): IObservable<TNew, unknown> {\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner: undefined,\n\t\t\t\tdebugName: () => `${this.debugName} (flattened)`,\n\t\t\t},\n\t\t\t(reader) => this.read(reader).read(reader),\n\t\t);\n\t}\n\n\tpublic recomputeInitiallyAndOnChange(\n\t\tstore: DisposableStore,\n\t\thandleValue?: (value: T) => void,\n\t): IObservable<T> {\n\t\tstore.add(_recomputeInitiallyAndOnChange!(this, handleValue));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ensures that this observable is observed. This keeps the cache alive.\n\t * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).\n\t * Use `recomputeInitiallyAndOnChange` for eager evaluation.\n\t */\n\tpublic keepObserved(store: DisposableStore): IObservable<T> {\n\t\tstore.add(_keepObserved!(this));\n\t\treturn this;\n\t}\n\n\tpublic abstract get debugName(): string;\n\n\tprotected get debugValue() {\n\t\treturn this.get();\n\t}\n}\n\nexport abstract class BaseObservable<\n\tT,\n\tTChange = void,\n> extends ConvenientObservable<T, TChange> {\n\tprotected readonly observers = new Set<IObserver>();\n\n\tpublic addObserver(observer: IObserver): void {\n\t\tconst len = this.observers.size;\n\t\tthis.observers.add(observer);\n\t\tif (len === 0) {\n\t\t\tthis.onFirstObserverAdded();\n\t\t}\n\t}\n\n\tpublic removeObserver(observer: IObserver): void {\n\t\tconst deleted = this.observers.delete(observer);\n\t\tif (deleted && this.observers.size === 0) {\n\t\t\tthis.onLastObserverRemoved();\n\t\t}\n\t}\n\n\tprotected onFirstObserverAdded(): void {}\n\tprotected onLastObserverRemoved(): void {}\n}\n\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\n\nexport function transaction(\n\tfn: (tx: ITransaction) => void,\n\tgetDebugName?: () => string,\n): void {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tfn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\n\nlet _globalTransaction: ITransaction | undefined;\n\nexport function globalTransaction(fn: (tx: ITransaction) => void) {\n\tif (_globalTransaction) {\n\t\tfn(_globalTransaction);\n\t} else {\n\t\tconst tx = new TransactionImpl(fn, undefined);\n\t\t_globalTransaction = tx;\n\t\ttry {\n\t\t\tfn(tx);\n\t\t} finally {\n\t\t\ttx.finish(); // During finish, more actions might be added to the transaction.\n\t\t\t// Which is why we only clear the global transaction after finish.\n\t\t\t_globalTransaction = undefined;\n\t\t}\n\t}\n}\n\nexport async function asyncTransaction(\n\tfn: (tx: ITransaction) => Promise<void>,\n\tgetDebugName?: () => string,\n): Promise<void> {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tawait fn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\n\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(\n\ttx: ITransaction | undefined,\n\tfn: (tx: ITransaction) => void,\n\tgetDebugName?: () => string,\n): void {\n\tif (tx) {\n\t\tfn(tx);\n\t} else {\n\t\ttransaction(fn, getDebugName);\n\t}\n}\n\nexport class TransactionImpl implements ITransaction {\n\tprivate updatingObservers:\n\t\t| { observer: IObserver; observable: IObservable<any> }[]\n\t\t| null = [];\n\n\tconstructor(\n\t\tpublic readonly _fn: Function,\n\t\tprivate readonly _getDebugName?: () => string,\n\t) {\n\t\tgetLogger()?.handleBeginTransaction(this);\n\t}\n\n\tpublic getDebugName(): string | undefined {\n\t\tif (this._getDebugName) {\n\t\t\treturn this._getDebugName();\n\t\t}\n\t\treturn getFunctionName(this._fn);\n\t}\n\n\tpublic updateObserver(\n\t\tobserver: IObserver,\n\t\tobservable: IObservable<any>,\n\t): void {\n\t\t// When this gets called while finish is active, they will still get considered\n\t\tthis.updatingObservers!.push({ observer, observable });\n\t\tobserver.beginUpdate(observable);\n\t}\n\n\tpublic finish(): void {\n\t\tconst updatingObservers = this.updatingObservers!;\n\t\tfor (let i = 0; i < updatingObservers.length; i++) {\n\t\t\tconst { observer, observable } = updatingObservers[i];\n\t\t\tobserver.endUpdate(observable);\n\t\t}\n\t\t// Prevent anyone from updating observers from now on.\n\t\tthis.updatingObservers = null;\n\t\tgetLogger()?.handleEndTransaction();\n\t}\n}\n\n/**\n * A settable observable.\n */\nexport interface ISettableObservable<T, TChange = void>\n\textends IObservable<T, TChange>,\n\t\tISettable<T, TChange> {}\n\n/**\n * Creates an observable value.\n * Observers get informed when the value changes.\n * @template TChange An arbitrary type to describe how or why the value changed. Defaults to `void`.\n * Observers will receive every single change value.\n */\nexport function observableValue<T, TChange = void>(\n\tname: string,\n\tinitialValue: T,\n): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(\n\towner: object,\n\tinitialValue: T,\n): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(\n\tnameOrOwner: string | object,\n\tinitialValue: T,\n): ISettableObservable<T, TChange> {\n\tlet debugNameData: DebugNameData;\n\tif (typeof nameOrOwner === \"string\") {\n\t\tdebugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n\t} else {\n\t\tdebugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n\t}\n\treturn new ObservableValue(debugNameData, initialValue, strictEquals);\n}\n\nexport class ObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange>\n{\n\tprotected _value: T;\n\n\tget debugName() {\n\t\treturn this._debugNameData.getDebugName(this) ?? \"ObservableValue\";\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tinitialValue: T,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t) {\n\t\tsuper();\n\t\tthis._value = initialValue;\n\t}\n\tpublic override get(): T {\n\t\treturn this._value;\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (\n\t\t\tchange === undefined &&\n\t\t\tthis._equalityComparator(this._value, value)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(\n\t\t\t\t() => {},\n\t\t\t\t() => `Setting ${this.debugName}`,\n\t\t\t);\n\t\t}\n\t\ttry {\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._setValue(value);\n\t\t\tgetLogger()?.handleObservableChanged(this, {\n\t\t\t\toldValue,\n\t\t\t\tnewValue: value,\n\t\t\t\tchange,\n\t\t\t\tdidChange: true,\n\t\t\t\thadValue: true,\n\t\t\t});\n\n\t\t\tfor (const observer of this.observers) {\n\t\t\t\ttx.updateObserver(observer, this);\n\t\t\t\tobserver.handleChange(this, change);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n}\n\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue<\n\tT extends IDisposable | undefined,\n\tTChange = void,\n>(\n\tnameOrOwner: string | object,\n\tinitialValue: T,\n): ISettableObservable<T, TChange> & IDisposable {\n\tlet debugNameData: DebugNameData;\n\tif (typeof nameOrOwner === \"string\") {\n\t\tdebugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n\t} else {\n\t\tdebugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n\t}\n\treturn new DisposableObservableValue(\n\t\tdebugNameData,\n\t\tinitialValue,\n\t\tstrictEquals,\n\t);\n}\n\nexport class DisposableObservableValue<\n\t\tT extends IDisposable | undefined,\n\t\tTChange = void,\n\t>\n\textends ObservableValue<T, TChange>\n\timplements IDisposable\n{\n\tprotected override _setValue(newValue: T): void {\n\t\tif (this._value === newValue) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tthis._value = newValue;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._value?.dispose();\n\t}\n}\n\nexport interface IChangeTracker {\n\t/**\n\t * Returns if this change should cause an invalidation.\n\t * Implementations can record changes.\n\t */\n\thandleChange(context: IChangeContext): boolean;\n}\n\nexport interface IChangeContext {\n\treadonly changedObservable: IObservable<any, any>;\n\treadonly change: unknown;\n\n\t/**\n\t * Returns if the given observable caused the change.\n\t */\n\tdidChange<T, TChange>(\n\t\tobservable: IObservable<T, TChange>,\n\t): this is { change: TChange };\n}\n"],
  "mappings": "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",
  "names": []
}
