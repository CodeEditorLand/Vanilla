import{isTypedArray as y,isObject as f,isUndefinedOrNull as l}from"./types.js";function p(t){if(!t||typeof t!="object"||t instanceof RegExp)return t;const e=Array.isArray(t)?[]:{};return Object.entries(t).forEach(([n,r])=>{e[n]=r&&typeof r=="object"?p(r):r}),e}function h(t){if(!t||typeof t!="object")return t;const e=[t];for(;e.length>0;){const n=e.shift();Object.freeze(n);for(const r in n)if(u.call(n,r)){const s=n[r];typeof s=="object"&&!Object.isFrozen(s)&&!y(s)&&e.push(s)}}return t}const u=Object.prototype.hasOwnProperty;function x(t,e){return c(t,e,new Set)}function c(t,e,n){if(l(t))return t;const r=e(t);if(typeof r<"u")return r;if(Array.isArray(t)){const s=[];for(const i of t)s.push(c(i,e,n));return s}if(f(t)){if(n.has(t))throw new Error("Cannot clone recursive data-structure");n.add(t);const s={};for(const i in t)u.call(t,i)&&(s[i]=c(t[i],e,n));return n.delete(t),s}return t}function g(t,e,n=!0){return f(t)?(f(e)&&Object.keys(e).forEach(r=>{r in t?n&&(f(t[r])&&f(e[r])?g(t[r],e[r],n):t[r]=e[r]):t[r]=e[r]}),t):e}function o(t,e){if(t===e)return!0;if(t==null||e===null||e===void 0||typeof t!=typeof e||typeof t!="object"||Array.isArray(t)!==Array.isArray(e))return!1;let n,r;if(Array.isArray(t)){if(t.length!==e.length)return!1;for(n=0;n<t.length;n++)if(!o(t[n],e[n]))return!1}else{const s=[];for(r in t)s.push(r);s.sort();const i=[];for(r in e)i.push(r);if(i.sort(),!o(s,i))return!1;for(n=0;n<s.length;n++)if(!o(t[s[n]],e[s[n]]))return!1}return!0}function A(t){const e=new Set;return JSON.stringify(t,(n,r)=>{if(f(r)||Array.isArray(r)){if(e.has(r))return"[Circular]";e.add(r)}return typeof r=="bigint"?`[BigInt ${r.toString()}]`:r})}function T(t,e){const n=Object.create(null);return!t||!e||Object.keys(e).forEach(s=>{const i=t[s],a=e[s];o(i,a)||(n[s]=a)}),n}function w(t,e){const n=e.toLowerCase(),r=Object.keys(t).find(s=>s.toLowerCase()===n);return r?t[r]:t[e]}function m(t,e){const n=Object.create(null);for(const[r,s]of Object.entries(t))e(r,s)&&(n[r]=s);return n}function d(t){let e=[];for(;Object.prototype!==t;)e=e.concat(Object.getOwnPropertyNames(t)),t=Object.getPrototypeOf(t);return e}function b(t){const e=[];for(const n of d(t))typeof t[n]=="function"&&e.push(n);return e}function k(t,e){const n=s=>function(){const i=Array.prototype.slice.call(arguments,0);return e(s,i)},r={};for(const s of t)r[s]=n(s);return r}function C(t,e){const n={};for(const[r,s]of Object.entries(t))n[r]=e(s,r);return n}export{x as cloneAndChange,k as createProxyObject,p as deepClone,h as deepFreeze,T as distinct,o as equals,m as filter,b as getAllMethodNames,d as getAllPropertyNames,w as getCaseInsensitive,C as mapValues,g as mixin,A as safeStringify};
