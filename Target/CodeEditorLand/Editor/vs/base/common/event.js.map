{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/event.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { CancellationToken } from \"./cancellation.js\";\nimport { diffSets } from \"./collections.js\";\nimport { onUnexpectedError } from \"./errors.js\";\nimport { createSingleCallFunction } from \"./functional.js\";\nimport {\n\tDisposable,\n\tDisposableMap,\n\tDisposableStore,\n\ttype IDisposable,\n\tcombinedDisposable,\n\ttoDisposable,\n} from \"./lifecycle.js\";\nimport { LinkedList } from \"./linkedList.js\";\nimport type { IObservable, IObserver } from \"./observable.js\";\nimport { StopWatch } from \"./stopwatch.js\";\nimport type { MicrotaskDelay } from \"./symbols.js\";\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableListenerGCedWarning = false;\n// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\n// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\n/**\n * An event with zero or one parameters that can be subscribed to. The event is a function itself.\n */\nexport interface Event<T> {\n\t(\n\t\tlistener: (e: T) => any,\n\t\tthisArgs?: any,\n\t\tdisposables?: IDisposable[] | DisposableStore,\n\t): IDisposable;\n}\n\nexport namespace Event {\n\texport const None: Event<any> = () => Disposable.None;\n\n\tfunction _addLeakageTraceLogic(options: EmitterOptions) {\n\t\tif (_enableSnapshotPotentialLeakWarning) {\n\t\t\tconst { onDidAddListener: origListenerDidAdd } = options;\n\t\t\tconst stack = Stacktrace.create();\n\t\t\tlet count = 0;\n\t\t\toptions.onDidAddListener = () => {\n\t\t\t\tif (++count === 2) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\"snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here\",\n\t\t\t\t\t);\n\t\t\t\t\tstack.print();\n\t\t\t\t}\n\t\t\t\torigListenerDidAdd?.();\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n\t * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n\t * result of merging events and to try prevent race conditions that could arise when using related deferred and\n\t * non-deferred events.\n\t *\n\t * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n\t * (eg. latency of keypress to text rendered).\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function defer(\n\t\tevent: Event<unknown>,\n\t\tdisposable?: DisposableStore,\n\t): Event<void> {\n\t\treturn debounce<unknown, void>(\n\t\t\tevent,\n\t\t\t() => void 0,\n\t\t\t0,\n\t\t\tundefined,\n\t\t\ttrue,\n\t\t\tundefined,\n\t\t\tdisposable,\n\t\t);\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable | undefined;\n\t\t\tresult = event(\n\t\t\t\t(e) => {\n\t\t\t\t\tif (didFire) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else if (result) {\n\t\t\t\t\t\tresult.dispose();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdidFire = true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t\t},\n\t\t\t\tnull,\n\t\t\t\tdisposables,\n\t\t\t);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once, and only when the condition is met.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function onceIf<T>(\n\t\tevent: Event<T>,\n\t\tcondition: (e: T) => boolean,\n\t): Event<T> {\n\t\treturn Event.once(Event.filter(event, condition));\n\t}\n\n\t/**\n\t * Maps an event of one type into an event of another type using a mapping function, similar to how\n\t * `Array.prototype.map` works.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param map The mapping function.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function map<I, O>(\n\t\tevent: Event<I>,\n\t\tmap: (i: I) => O,\n\t\tdisposable?: DisposableStore,\n\t): Event<O> {\n\t\treturn snapshot(\n\t\t\t(listener, thisArgs = null, disposables?) =>\n\t\t\t\tevent(\n\t\t\t\t\t(i) => listener.call(thisArgs, map(i)),\n\t\t\t\t\tnull,\n\t\t\t\t\tdisposables,\n\t\t\t\t),\n\t\t\tdisposable,\n\t\t);\n\t}\n\n\t/**\n\t * Wraps an event in another event that performs some function on the event object before firing.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param each The function to perform on the event object.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function forEach<I>(\n\t\tevent: Event<I>,\n\t\teach: (i: I) => void,\n\t\tdisposable?: DisposableStore,\n\t): Event<I> {\n\t\treturn snapshot(\n\t\t\t(listener, thisArgs = null, disposables?) =>\n\t\t\t\tevent(\n\t\t\t\t\t(i) => {\n\t\t\t\t\t\teach(i);\n\t\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t\t},\n\t\t\t\t\tnull,\n\t\t\t\t\tdisposables,\n\t\t\t\t),\n\t\t\tdisposable,\n\t\t);\n\t}\n\n\t/**\n\t * Wraps an event in another event that fires only when some condition is met.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param filter The filter function that defines the condition. The event will fire for the object if this function\n\t * returns true.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function filter<T, U>(\n\t\tevent: Event<T | U>,\n\t\tfilter: (e: T | U) => e is T,\n\t\tdisposable?: DisposableStore,\n\t): Event<T>;\n\texport function filter<T>(\n\t\tevent: Event<T>,\n\t\tfilter: (e: T) => boolean,\n\t\tdisposable?: DisposableStore,\n\t): Event<T>;\n\texport function filter<T, R>(\n\t\tevent: Event<T | R>,\n\t\tfilter: (e: T | R) => e is R,\n\t\tdisposable?: DisposableStore,\n\t): Event<R>;\n\texport function filter<T>(\n\t\tevent: Event<T>,\n\t\tfilter: (e: T) => boolean,\n\t\tdisposable?: DisposableStore,\n\t): Event<T> {\n\t\treturn snapshot(\n\t\t\t(listener, thisArgs = null, disposables?) =>\n\t\t\t\tevent(\n\t\t\t\t\t(e) => filter(e) && listener.call(thisArgs, e),\n\t\t\t\t\tnull,\n\t\t\t\t\tdisposables,\n\t\t\t\t),\n\t\t\tdisposable,\n\t\t);\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T>;\n\texport function any(...events: Event<any>[]): Event<void>;\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\tconst disposable = combinedDisposable(\n\t\t\t\t...events.map((event) =>\n\t\t\t\t\tevent((e) => listener.call(thisArgs, e)),\n\t\t\t\t),\n\t\t\t);\n\t\t\treturn addAndReturnDisposable(disposable, disposables);\n\t\t};\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function reduce<I, O>(\n\t\tevent: Event<I>,\n\t\tmerge: (last: O | undefined, event: I) => O,\n\t\tinitial?: O,\n\t\tdisposable?: DisposableStore,\n\t): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(\n\t\t\tevent,\n\t\t\t(e) => {\n\t\t\t\toutput = merge(output, e);\n\t\t\t\treturn output;\n\t\t\t},\n\t\t\tdisposable,\n\t\t);\n\t}\n\n\tfunction snapshot<T>(\n\t\tevent: Event<T>,\n\t\tdisposable: DisposableStore | undefined,\n\t): Event<T> {\n\t\tlet listener: IDisposable | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tlistener?.dispose();\n\t\t\t},\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<T>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Adds the IDisposable to the store if it's set, and returns it. Useful to\n\t * Event function implementation.\n\t */\n\tfunction addAndReturnDisposable<T extends IDisposable>(\n\t\td: T,\n\t\tstore: DisposableStore | IDisposable[] | undefined,\n\t): T {\n\t\tif (store instanceof Array) {\n\t\t\tstore.push(d);\n\t\t} else if (store) {\n\t\t\tstore.add(d);\n\t\t}\n\t\treturn d;\n\t}\n\n\t/**\n\t * Given an event, creates a new emitter that event that will debounce events based on {@link delay} and give an\n\t * array event object of all events that fired.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The original event to debounce.\n\t * @param merge A function that reduces all events into a single event.\n\t * @param delay The number of milliseconds to debounce.\n\t * @param leading Whether to fire a leading event without debouncing.\n\t * @param flushOnListenerRemove Whether to fire all debounced events when a listener is removed. If this is not\n\t * specified, some events could go missing. Use this if it's important that all events are processed, even if the\n\t * listener gets disposed before the debounced event fires.\n\t * @param leakWarningThreshold See {@link EmitterOptions.leakWarningThreshold}.\n\t * @param disposable A disposable store to register the debounce emitter to.\n\t */\n\texport function debounce<T>(\n\t\tevent: Event<T>,\n\t\tmerge: (last: T | undefined, event: T) => T,\n\t\tdelay?: number | typeof MicrotaskDelay,\n\t\tleading?: boolean,\n\t\tflushOnListenerRemove?: boolean,\n\t\tleakWarningThreshold?: number,\n\t\tdisposable?: DisposableStore,\n\t): Event<T>;\n\texport function debounce<I, O>(\n\t\tevent: Event<I>,\n\t\tmerge: (last: O | undefined, event: I) => O,\n\t\tdelay?: number | typeof MicrotaskDelay,\n\t\tleading?: boolean,\n\t\tflushOnListenerRemove?: boolean,\n\t\tleakWarningThreshold?: number,\n\t\tdisposable?: DisposableStore,\n\t): Event<O>;\n\texport function debounce<I, O>(\n\t\tevent: Event<I>,\n\t\tmerge: (last: O | undefined, event: I) => O,\n\t\tdelay: number | typeof MicrotaskDelay = 100,\n\t\tleading = false,\n\t\tflushOnListenerRemove = false,\n\t\tleakWarningThreshold?: number,\n\t\tdisposable?: DisposableStore,\n\t): Event<O> {\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined;\n\t\tlet handle: any;\n\t\tlet numDebouncedCalls = 0;\n\t\tlet doFire: (() => void) | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tleakWarningThreshold,\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tsubscription = event((cur) => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tdoFire = () => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t};\n\n\t\t\t\t\tif (typeof delay === \"number\") {\n\t\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\t\thandle = setTimeout(doFire, delay);\n\t\t\t\t\t} else if (handle === undefined) {\n\t\t\t\t\t\thandle = 0;\n\t\t\t\t\t\tqueueMicrotask(doFire);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tonWillRemoveListener() {\n\t\t\t\tif (flushOnListenerRemove && numDebouncedCalls > 0) {\n\t\t\t\t\tdoFire?.();\n\t\t\t\t}\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tdoFire = undefined;\n\t\t\t\tsubscription.dispose();\n\t\t\t},\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<O>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function accumulate<T>(\n\t\tevent: Event<T>,\n\t\tdelay = 0,\n\t\tdisposable?: DisposableStore,\n\t): Event<T[]> {\n\t\treturn Event.debounce<T, T[]>(\n\t\t\tevent,\n\t\t\t(last, e) => {\n\t\t\t\tif (!last) {\n\t\t\t\t\treturn [e];\n\t\t\t\t}\n\t\t\t\tlast.push(e);\n\t\t\t\treturn last;\n\t\t\t},\n\t\t\tdelay,\n\t\t\tundefined,\n\t\t\ttrue,\n\t\t\tundefined,\n\t\t\tdisposable,\n\t\t);\n\t}\n\n\t/**\n\t * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n\t * event objects from different sources do not fire the same event object.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param equals The equality condition.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t *\n\t * @example\n\t * ```\n\t * // Fire only one time when a single window is opened or focused\n\t * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n\t * ```\n\t */\n\texport function latch<T>(\n\t\tevent: Event<T>,\n\t\tequals: (a: T, b: T) => boolean = (a, b) => a === b,\n\t\tdisposable?: DisposableStore,\n\t): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(\n\t\t\tevent,\n\t\t\t(value) => {\n\t\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\t\tfirstCall = false;\n\t\t\t\tcache = value;\n\t\t\t\treturn shouldEmit;\n\t\t\t},\n\t\t\tdisposable,\n\t\t);\n\t}\n\n\t/**\n\t * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @example\n\t * ```\n\t * const event = new EventEmitter<number | undefined>().event;\n\t * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n\t * ```\n\t *\n\t * @param event The event source for the new event.\n\t * @param isT A function that determines what event is of the first type.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function split<T, U>(\n\t\tevent: Event<T | U>,\n\t\tisT: (e: T | U) => e is T,\n\t\tdisposable?: DisposableStore,\n\t): [Event<T>, Event<U>] {\n\t\treturn [\n\t\t\tEvent.filter(event, isT, disposable),\n\t\t\tEvent.filter(event, (e) => !isT(e), disposable) as Event<U>,\n\t\t];\n\t}\n\n\t/**\n\t * Buffers an event until it has a listener attached.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n\t * `setTimeout` when the first event listener is added.\n\t * @param _buffer Internal: A source event array used for tests.\n\t *\n\t * @example\n\t * ```\n\t * // Start accumulating events, when the first listener is attached, flush\n\t * // the event after a timeout such that multiple listeners attached before\n\t * // the timeout would receive the event\n\t * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n\t * ```\n\t */\n\texport function buffer<T>(\n\t\tevent: Event<T>,\n\t\tflushAfterTimeout = false,\n\t\t_buffer: T[] = [],\n\t\tdisposable?: DisposableStore,\n\t): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event((e) => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(listener);\n\t\t}\n\n\t\tconst flush = () => {\n\t\t\tbuffer?.forEach((e) => emitter.fire(e));\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event((e) => emitter.fire(e));\n\t\t\t\t\tif (disposable) {\n\t\t\t\t\t\tdisposable.add(listener);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidAddFirstListener() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (flushAfterTimeout) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t},\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(emitter);\n\t\t}\n\n\t\treturn emitter.event;\n\t}\n\t/**\n\t * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n\t *\n\t * @example\n\t * ```\n\t * // Normal\n\t * const onEnterPressNormal = Event.filter(\n\t *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n\t *   e.keyCode === KeyCode.Enter\n\t * ).event;\n\t *\n\t * // Using chain\n\t * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n\t *   .map(e => new StandardKeyboardEvent(e))\n\t *   .filter(e => e.keyCode === KeyCode.Enter)\n\t * );\n\t * ```\n\t */\n\texport function chain<T, R>(\n\t\tevent: Event<T>,\n\t\tsythensize: ($: IChainableSythensis<T>) => IChainableSythensis<R>,\n\t): Event<R> {\n\t\tconst fn: Event<R> = (listener, thisArgs, disposables) => {\n\t\t\tconst cs = sythensize(\n\t\t\t\tnew ChainableSynthesis(),\n\t\t\t) as ChainableSynthesis;\n\t\t\treturn event(\n\t\t\t\t(value) => {\n\t\t\t\t\tconst result = cs.evaluate(value);\n\t\t\t\t\tif (result !== HaltChainable) {\n\t\t\t\t\t\tlistener.call(thisArgs, result);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tundefined,\n\t\t\t\tdisposables,\n\t\t\t);\n\t\t};\n\n\t\treturn fn;\n\t}\n\n\tconst HaltChainable = Symbol(\"HaltChainable\");\n\n\tclass ChainableSynthesis implements IChainableSythensis<any> {\n\t\tprivate readonly steps: ((input: any) => any)[] = [];\n\n\t\tmap<O>(fn: (i: any) => O): this {\n\t\t\tthis.steps.push(fn);\n\t\t\treturn this;\n\t\t}\n\n\t\tforEach(fn: (i: any) => void): this {\n\t\t\tthis.steps.push((v) => {\n\t\t\t\tfn(v);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tfilter(fn: (e: any) => boolean): this {\n\t\t\tthis.steps.push((v) => (fn(v) ? v : HaltChainable));\n\t\t\treturn this;\n\t\t}\n\n\t\treduce<R>(\n\t\t\tmerge: (last: R | undefined, event: any) => R,\n\t\t\tinitial?: R | undefined,\n\t\t): this {\n\t\t\tlet last = initial;\n\t\t\tthis.steps.push((v) => {\n\t\t\t\tlast = merge(last, v);\n\t\t\t\treturn last;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tlatch(\n\t\t\tequals: (a: any, b: any) => boolean = (a, b) => a === b,\n\t\t): ChainableSynthesis {\n\t\t\tlet firstCall = true;\n\t\t\tlet cache: any;\n\t\t\tthis.steps.push((value) => {\n\t\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\t\tfirstCall = false;\n\t\t\t\tcache = value;\n\t\t\t\treturn shouldEmit ? value : HaltChainable;\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic evaluate(value: any) {\n\t\t\tfor (const step of this.steps) {\n\t\t\t\tvalue = step(value);\n\t\t\t\tif (value === HaltChainable) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t}\n\n\texport interface IChainableSythensis<T> {\n\t\tmap<O>(fn: (i: T) => O): IChainableSythensis<O>;\n\t\tforEach(fn: (i: T) => void): IChainableSythensis<T>;\n\t\tfilter<R extends T>(fn: (e: T) => e is R): IChainableSythensis<R>;\n\t\tfilter(fn: (e: T) => boolean): IChainableSythensis<T>;\n\t\treduce<R>(\n\t\t\tmerge: (last: R, event: T) => R,\n\t\t\tinitial: R,\n\t\t): IChainableSythensis<R>;\n\t\treduce<R>(\n\t\t\tmerge: (last: R | undefined, event: T) => R,\n\t\t): IChainableSythensis<R>;\n\t\tlatch(equals?: (a: T, b: T) => boolean): IChainableSythensis<T>;\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): unknown;\n\t\tremoveListener(event: string | symbol, listener: Function): unknown;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a node event emitter.\n\t */\n\texport function fromNodeEventEmitter<T>(\n\t\temitter: NodeEventEmitter,\n\t\teventName: string,\n\t\tmap: (...args: any[]) => T = (id) => id,\n\t): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () =>\n\t\t\temitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({\n\t\t\tonWillAddFirstListener: onFirstListenerAdd,\n\t\t\tonDidRemoveLastListener: onLastListenerRemove,\n\t\t});\n\n\t\treturn result.event;\n\t}\n\n\texport interface DOMEventEmitter {\n\t\taddEventListener(event: string | symbol, listener: Function): void;\n\t\tremoveEventListener(event: string | symbol, listener: Function): void;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a DOM event emitter.\n\t */\n\texport function fromDOMEventEmitter<T>(\n\t\temitter: DOMEventEmitter,\n\t\teventName: string,\n\t\tmap: (...args: any[]) => T = (id) => id,\n\t): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () =>\n\t\t\temitter.addEventListener(eventName, fn);\n\t\tconst onLastListenerRemove = () =>\n\t\t\temitter.removeEventListener(eventName, fn);\n\t\tconst result = new Emitter<T>({\n\t\t\tonWillAddFirstListener: onFirstListenerAdd,\n\t\t\tonDidRemoveLastListener: onLastListenerRemove,\n\t\t});\n\n\t\treturn result.event;\n\t}\n\n\t/**\n\t * Creates a promise out of an event, using the {@link Event.once} helper.\n\t */\n\texport function toPromise<T>(event: Event<T>): Promise<T> {\n\t\treturn new Promise((resolve) => once(event)(resolve));\n\t}\n\n\t/**\n\t * Creates an event out of a promise that fires once when the promise is\n\t * resolved with the result of the promise or `undefined`.\n\t */\n\texport function fromPromise<T>(promise: Promise<T>): Event<T | undefined> {\n\t\tconst result = new Emitter<T | undefined>();\n\n\t\tpromise\n\t\t\t.then(\n\t\t\t\t(res) => {\n\t\t\t\t\tresult.fire(res);\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tresult.fire(undefined);\n\t\t\t\t},\n\t\t\t)\n\t\t\t.finally(() => {\n\t\t\t\tresult.dispose();\n\t\t\t});\n\n\t\treturn result.event;\n\t}\n\n\t/**\n\t * A convenience function for forwarding an event to another emitter which\n\t * improves readability.\n\t *\n\t * This is similar to {@link Relay} but allows instantiating and forwarding\n\t * on a single line and also allows for multiple source events.\n\t * @param from The event to forward.\n\t * @param to The emitter to forward the event to.\n\t * @example\n\t * Event.forward(event, emitter);\n\t * // equivalent to\n\t * event(e => emitter.fire(e));\n\t * // equivalent to\n\t * event(emitter.fire, emitter);\n\t */\n\texport function forward<T>(from: Event<T>, to: Emitter<T>): IDisposable {\n\t\treturn from((e) => to.fire(e));\n\t}\n\n\t/**\n\t * Adds a listener to an event and calls the listener immediately with undefined as the event object.\n\t *\n\t * @example\n\t * ```\n\t * // Initialize the UI and update it when dataChangeEvent fires\n\t * runAndSubscribe(dataChangeEvent, () => this._updateUI());\n\t * ```\n\t */\n\texport function runAndSubscribe<T>(\n\t\tevent: Event<T>,\n\t\thandler: (e: T) => any,\n\t\tinitial: T,\n\t): IDisposable;\n\texport function runAndSubscribe<T>(\n\t\tevent: Event<T>,\n\t\thandler: (e: T | undefined) => any,\n\t): IDisposable;\n\texport function runAndSubscribe<T>(\n\t\tevent: Event<T>,\n\t\thandler: (e: T | undefined) => any,\n\t\tinitial?: T,\n\t): IDisposable {\n\t\thandler(initial);\n\t\treturn event((e) => handler(e));\n\t}\n\n\tclass EmitterObserver<T> implements IObserver {\n\t\treadonly emitter: Emitter<T>;\n\n\t\tprivate _counter = 0;\n\t\tprivate _hasChanged = false;\n\n\t\tconstructor(\n\t\t\treadonly _observable: IObservable<T, any>,\n\t\t\tstore: DisposableStore | undefined,\n\t\t) {\n\t\t\tconst options: EmitterOptions = {\n\t\t\t\tonWillAddFirstListener: () => {\n\t\t\t\t\t_observable.addObserver(this);\n\n\t\t\t\t\t// Communicate to the observable that we received its current value and would like to be notified about future changes.\n\t\t\t\t\tthis._observable.reportChanges();\n\t\t\t\t},\n\t\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\t\t_observable.removeObserver(this);\n\t\t\t\t},\n\t\t\t};\n\t\t\tif (!store) {\n\t\t\t\t_addLeakageTraceLogic(options);\n\t\t\t}\n\t\t\tthis.emitter = new Emitter<T>(options);\n\t\t\tif (store) {\n\t\t\t\tstore.add(this.emitter);\n\t\t\t}\n\t\t}\n\n\t\tbeginUpdate<T>(_observable: IObservable<T, void>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter++;\n\t\t}\n\n\t\thandlePossibleChange<T>(_observable: IObservable<T, unknown>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t}\n\n\t\thandleChange<T, TChange>(\n\t\t\t_observable: IObservable<T, TChange>,\n\t\t\t_change: TChange,\n\t\t): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._hasChanged = true;\n\t\t}\n\n\t\tendUpdate<T>(_observable: IObservable<T, void>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter--;\n\t\t\tif (this._counter === 0) {\n\t\t\t\tthis._observable.reportChanges();\n\t\t\t\tif (this._hasChanged) {\n\t\t\t\t\tthis._hasChanged = false;\n\t\t\t\t\tthis.emitter.fire(this._observable.get());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an event emitter that is fired when the observable changes.\n\t * Each listeners subscribes to the emitter.\n\t */\n\texport function fromObservable<T>(\n\t\tobs: IObservable<T, any>,\n\t\tstore?: DisposableStore,\n\t): Event<T> {\n\t\tconst observer = new EmitterObserver(obs, store);\n\t\treturn observer.emitter.event;\n\t}\n\n\t/**\n\t * Each listener is attached to the observable directly.\n\t */\n\texport function fromObservableLight(\n\t\tobservable: IObservable<any>,\n\t): Event<void> {\n\t\treturn (listener, thisArgs, disposables) => {\n\t\t\tlet count = 0;\n\t\t\tlet didChange = false;\n\t\t\tconst observer: IObserver = {\n\t\t\t\tbeginUpdate() {\n\t\t\t\t\tcount++;\n\t\t\t\t},\n\t\t\t\tendUpdate() {\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\tobservable.reportChanges();\n\t\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\t\tdidChange = false;\n\t\t\t\t\t\t\tlistener.call(thisArgs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\thandlePossibleChange() {\n\t\t\t\t\t// noop\n\t\t\t\t},\n\t\t\t\thandleChange() {\n\t\t\t\t\tdidChange = true;\n\t\t\t\t},\n\t\t\t};\n\t\t\tobservable.addObserver(observer);\n\t\t\tobservable.reportChanges();\n\t\t\tconst disposable = {\n\t\t\t\tdispose() {\n\t\t\t\t\tobservable.removeObserver(observer);\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\tdisposables.add(disposable);\n\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\tdisposables.push(disposable);\n\t\t\t}\n\n\t\t\treturn disposable;\n\t\t};\n\t}\n}\n\nexport interface EmitterOptions {\n\t/**\n\t * Optional function that's called *before* the very first listener is added\n\t */\n\tonWillAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called *after* the very first listener is added\n\t */\n\tonDidAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called after a listener is added\n\t */\n\tonDidAddListener?: Function;\n\t/**\n\t * Optional function that's called *after* remove the very last listener\n\t */\n\tonDidRemoveLastListener?: Function;\n\t/**\n\t * Optional function that's called *before* a listener is removed\n\t */\n\tonWillRemoveListener?: Function;\n\t/**\n\t * Optional function that's called when a listener throws an error. Defaults to\n\t * {@link onUnexpectedError}\n\t */\n\tonListenerError?: (e: any) => void;\n\t/**\n\t * Number of listeners that are allowed before assuming a leak. Default to\n\t * a globally configured value\n\t *\n\t * @see setGlobalLeakWarningThreshold\n\t */\n\tleakWarningThreshold?: number;\n\t/**\n\t * Pass in a delivery queue, which is useful for ensuring\n\t * in order event delivery across multiple emitters.\n\t */\n\tdeliveryQueue?: EventDeliveryQueue;\n\n\t/** ONLY enable this during development */\n\t_profName?: string;\n}\n\nexport class EventProfiling {\n\tstatic readonly all = new Set<EventProfiling>();\n\n\tprivate static _idPool = 0;\n\n\treadonly name: string;\n\tpublic listenerCount = 0;\n\tpublic invocationCount = 0;\n\tpublic elapsedOverall = 0;\n\tpublic durations: number[] = [];\n\n\tprivate _stopWatch?: StopWatch;\n\n\tconstructor(name: string) {\n\t\tthis.name = `${name}_${EventProfiling._idPool++}`;\n\t\tEventProfiling.all.add(this);\n\t}\n\n\tstart(listenerCount: number): void {\n\t\tthis._stopWatch = new StopWatch();\n\t\tthis.listenerCount = listenerCount;\n\t}\n\n\tstop(): void {\n\t\tif (this._stopWatch) {\n\t\t\tconst elapsed = this._stopWatch.elapsed();\n\t\t\tthis.durations.push(elapsed);\n\t\t\tthis.elapsedOverall += elapsed;\n\t\t\tthis.invocationCount += 1;\n\t\t\tthis._stopWatch = undefined;\n\t\t}\n\t}\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t},\n\t};\n}\n\nclass LeakageMonitor {\n\tprivate static _idPool = 1;\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown = 0;\n\n\tconstructor(\n\t\tprivate readonly _errorHandler: (err: Error) => void,\n\t\treadonly threshold: number,\n\t\treadonly name: string = (LeakageMonitor._idPool++)\n\t\t\t.toString(16)\n\t\t\t.padStart(3, \"0\"),\n\t) {}\n\n\tdispose(): void {\n\t\tthis._stacks?.clear();\n\t}\n\n\tcheck(stack: Stacktrace, listenerCount: number): undefined | (() => void) {\n\t\tconst threshold = this.threshold;\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst count = this._stacks.get(stack.value) || 0;\n\t\tthis._stacks.set(stack.value, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\tconst [topStack, topCount] = this.getMostFrequentStack()!;\n\t\t\tconst message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\n\t\t\tconsole.warn(message);\n\t\t\tconsole.warn(topStack!);\n\n\t\t\tconst error = new ListenerLeakError(message, topStack);\n\t\t\tthis._errorHandler(error);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = this._stacks!.get(stack.value) || 0;\n\t\t\tthis._stacks!.set(stack.value, count - 1);\n\t\t};\n\t}\n\n\tgetMostFrequentStack(): [string, number] | undefined {\n\t\tif (!this._stacks) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet topStack: [string, number] | undefined;\n\t\tlet topCount = 0;\n\t\tfor (const [stack, count] of this._stacks) {\n\t\t\tif (!topStack || topCount < count) {\n\t\t\t\ttopStack = [stack, count];\n\t\t\t\ttopCount = count;\n\t\t\t}\n\t\t}\n\t\treturn topStack;\n\t}\n}\n\nclass Stacktrace {\n\tstatic create() {\n\t\tconst err = new Error();\n\t\treturn new Stacktrace(err.stack ?? \"\");\n\t}\n\n\tprivate constructor(readonly value: string) {}\n\n\tprint() {\n\t\tconsole.warn(this.value.split(\"\\n\").slice(2).join(\"\\n\"));\n\t}\n}\n\n// error that is logged when going over the configured listener threshold\nexport class ListenerLeakError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = \"ListenerLeakError\";\n\t\tthis.stack = stack;\n\t}\n}\n\n// SEVERE error that is logged when having gone way over the configured listener\n// threshold so that the emitter refuses to accept more listeners\nexport class ListenerRefusalError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = \"ListenerRefusalError\";\n\t\tthis.stack = stack;\n\t}\n}\n\nlet id = 0;\nclass UniqueContainer<T> {\n\tstack?: Stacktrace;\n\tpublic id = id++;\n\tconstructor(public readonly value: T) {}\n}\nconst compactionThreshold = 2;\n\ntype ListenerContainer<T> = UniqueContainer<(data: T) => void>;\ntype ListenerOrListeners<T> =\n\t| (ListenerContainer<T> | undefined)[]\n\t| ListenerContainer<T>;\n\nconst forEachListener = <T>(\n\tlisteners: ListenerOrListeners<T>,\n\tfn: (c: ListenerContainer<T>) => void,\n) => {\n\tif (listeners instanceof UniqueContainer) {\n\t\tfn(listeners);\n\t} else {\n\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\tconst l = listeners[i];\n\t\t\tif (l) {\n\t\t\t\tfn(l);\n\t\t\t}\n\t\t}\n\t}\n};\n\nlet _listenerFinalizers: FinalizationRegistry<string> | undefined;\n\nif (_enableListenerGCedWarning) {\n\tconst leaks: string[] = [];\n\n\tsetInterval(() => {\n\t\tif (leaks.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconsole.warn(\n\t\t\t\"[LEAKING LISTENERS] GC'ed these listeners that were NOT yet disposed:\",\n\t\t);\n\t\tconsole.warn(leaks.join(\"\\n\"));\n\t\tleaks.length = 0;\n\t}, 3000);\n\n\t_listenerFinalizers = new FinalizationRegistry((heldValue) => {\n\t\tif (typeof heldValue === \"string\") {\n\t\t\tleaks.push(heldValue);\n\t\t}\n\t});\n}\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate readonly _perfMon?: EventProfiling;\n\tprivate _disposed?: true;\n\tprivate _event?: Event<T>;\n\n\t/**\n\t * A listener, or list of listeners. A single listener is the most common\n\t * for event emitters (#185789), so we optimize that special case to avoid\n\t * wrapping it in an array (just like Node.js itself.)\n\t *\n\t * A list of listeners never 'downgrades' back to a plain function if\n\t * listeners are removed, for two reasons:\n\t *\n\t *  1. That's complicated (especially with the deliveryQueue)\n\t *  2. A listener with >1 listener is likely to have >1 listener again at\n\t *     some point, and swapping between arrays and functions may[citation needed]\n\t *     introduce unnecessary work and garbage.\n\t *\n\t * The array listeners can be 'sparse', to avoid reallocating the array\n\t * whenever any listener is added or removed. If more than `1 / compactionThreshold`\n\t * of the array is empty, only then is it resized.\n\t */\n\tprotected _listeners?: ListenerOrListeners<T>;\n\n\t/**\n\t * Always to be defined if _listeners is an array. It's no longer a true\n\t * queue, but holds the dispatching 'state'. If `fire()` is called on an\n\t * emitter, any work left in the _deliveryQueue is finished first.\n\t */\n\tprivate _deliveryQueue?: EventDeliveryQueuePrivate;\n\tprotected _size = 0;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon =\n\t\t\t_globalLeakWarningThreshold > 0 ||\n\t\t\tthis._options?.leakWarningThreshold\n\t\t\t\t? new LeakageMonitor(\n\t\t\t\t\t\toptions?.onListenerError ?? onUnexpectedError,\n\t\t\t\t\t\tthis._options?.leakWarningThreshold ??\n\t\t\t\t\t\t\t_globalLeakWarningThreshold,\n\t\t\t\t\t)\n\t\t\t\t: undefined;\n\t\tthis._perfMon = this._options?._profName\n\t\t\t? new EventProfiling(this._options._profName)\n\t\t\t: undefined;\n\t\tthis._deliveryQueue = this._options?.deliveryQueue as\n\t\t\t| EventDeliveryQueuePrivate\n\t\t\t| undefined;\n\t}\n\n\tdispose() {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\t// It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n\t\t\t// alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n\t\t\t// unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n\t\t\t// the following programming pattern is very popular:\n\t\t\t//\n\t\t\t// const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n\t\t\t// this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n\t\t\t// ...later...\n\t\t\t// this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n\n\t\t\tif (this._deliveryQueue?.current === this) {\n\t\t\t\tthis._deliveryQueue.reset();\n\t\t\t}\n\t\t\tif (this._listeners) {\n\t\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\t\tconst listeners = this._listeners;\n\t\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t\tforEachListener(listeners, (l) => l.stack?.print());\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis._listeners = undefined;\n\t\t\t\tthis._size = 0;\n\t\t\t}\n\t\t\tthis._options?.onDidRemoveLastListener?.();\n\t\t\tthis._leakageMon?.dispose();\n\t\t}\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tthis._event ??= (\n\t\t\tcallback: (e: T) => any,\n\t\t\tthisArgs?: any,\n\t\t\tdisposables?: IDisposable[] | DisposableStore,\n\t\t) => {\n\t\t\tif (\n\t\t\t\tthis._leakageMon &&\n\t\t\t\tthis._size > this._leakageMon.threshold ** 2\n\t\t\t) {\n\t\t\t\tconst message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\n\t\t\t\tconsole.warn(message);\n\n\t\t\t\tconst tuple = this._leakageMon.getMostFrequentStack() ?? [\n\t\t\t\t\t\"UNKNOWN stack\",\n\t\t\t\t\t-1,\n\t\t\t\t];\n\t\t\t\tconst error = new ListenerRefusalError(\n\t\t\t\t\t`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`,\n\t\t\t\t\ttuple[0],\n\t\t\t\t);\n\t\t\t\tconst errorHandler =\n\t\t\t\t\tthis._options?.onListenerError || onUnexpectedError;\n\t\t\t\terrorHandler(error);\n\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (this._disposed) {\n\t\t\t\t// todo: should we warn if a listener is added to a disposed emitter? This happens often\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (thisArgs) {\n\t\t\t\tcallback = callback.bind(thisArgs);\n\t\t\t}\n\n\t\t\tconst contained = new UniqueContainer(callback);\n\n\t\t\tlet removeMonitor: Function | undefined;\n\t\t\tlet stack: Stacktrace | undefined;\n\t\t\tif (\n\t\t\t\tthis._leakageMon &&\n\t\t\t\tthis._size >= Math.ceil(this._leakageMon.threshold * 0.2)\n\t\t\t) {\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tcontained.stack = Stacktrace.create();\n\t\t\t\tremoveMonitor = this._leakageMon.check(\n\t\t\t\t\tcontained.stack,\n\t\t\t\t\tthis._size + 1,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\tcontained.stack = stack ?? Stacktrace.create();\n\t\t\t}\n\n\t\t\tif (!this._listeners) {\n\t\t\t\tthis._options?.onWillAddFirstListener?.(this);\n\t\t\t\tthis._listeners = contained;\n\t\t\t\tthis._options?.onDidAddFirstListener?.(this);\n\t\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\t\tthis._deliveryQueue ??= new EventDeliveryQueuePrivate();\n\t\t\t\tthis._listeners = [this._listeners, contained];\n\t\t\t} else {\n\t\t\t\tthis._listeners.push(contained);\n\t\t\t}\n\n\t\t\tthis._size++;\n\n\t\t\tconst result = toDisposable(() => {\n\t\t\t\t_listenerFinalizers?.unregister(result);\n\t\t\t\tremoveMonitor?.();\n\t\t\t\tthis._removeListener(contained);\n\t\t\t});\n\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\tdisposables.add(result);\n\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\tdisposables.push(result);\n\t\t\t}\n\n\t\t\tif (_listenerFinalizers) {\n\t\t\t\tconst stack = new Error()\n\t\t\t\t\t.stack!.split(\"\\n\")\n\t\t\t\t\t.slice(2, 3)\n\t\t\t\t\t.join(\"\\n\")\n\t\t\t\t\t.trim();\n\t\t\t\tconst match =\n\t\t\t\t\t/(file:|vscode-file:\\/\\/vscode-app)?(\\/[^:]*:\\d+:\\d+)/.exec(\n\t\t\t\t\t\tstack,\n\t\t\t\t\t);\n\t\t\t\t_listenerFinalizers.register(\n\t\t\t\t\tresult,\n\t\t\t\t\tmatch?.[2] ?? stack,\n\t\t\t\t\tresult,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\treturn this._event;\n\t}\n\n\tprivate _removeListener(listener: ListenerContainer<T>) {\n\t\tthis._options?.onWillRemoveListener?.(this);\n\n\t\tif (!this._listeners) {\n\t\t\treturn; // expected if a listener gets disposed\n\t\t}\n\n\t\tif (this._size === 1) {\n\t\t\tthis._listeners = undefined;\n\t\t\tthis._options?.onDidRemoveLastListener?.(this);\n\t\t\tthis._size = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t// size > 1 which requires that listeners be a list:\n\t\tconst listeners = this._listeners as (\n\t\t\t| ListenerContainer<T>\n\t\t\t| undefined\n\t\t)[];\n\n\t\tconst index = listeners.indexOf(listener);\n\t\tif (index === -1) {\n\t\t\tconsole.log(\"disposed?\", this._disposed);\n\t\t\tconsole.log(\"size?\", this._size);\n\t\t\tconsole.log(\"arr?\", JSON.stringify(this._listeners));\n\t\t\tthrow new Error(\"Attempted to dispose unknown listener\");\n\t\t}\n\n\t\tthis._size--;\n\t\tlisteners[index] = undefined;\n\n\t\tconst adjustDeliveryQueue = this._deliveryQueue!.current === this;\n\t\tif (this._size * compactionThreshold <= listeners.length) {\n\t\t\tlet n = 0;\n\t\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t\tif (listeners[i]) {\n\t\t\t\t\tlisteners[n++] = listeners[i];\n\t\t\t\t} else if (adjustDeliveryQueue) {\n\t\t\t\t\tthis._deliveryQueue!.end--;\n\t\t\t\t\tif (n < this._deliveryQueue!.i) {\n\t\t\t\t\t\tthis._deliveryQueue!.i--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisteners.length = n;\n\t\t}\n\t}\n\n\tprivate _deliver(\n\t\tlistener: undefined | UniqueContainer<(value: T) => void>,\n\t\tvalue: T,\n\t) {\n\t\tif (!listener) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst errorHandler =\n\t\t\tthis._options?.onListenerError || onUnexpectedError;\n\t\tif (!errorHandler) {\n\t\t\tlistener.value(value);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tlistener.value(value);\n\t\t} catch (e) {\n\t\t\terrorHandler(e);\n\t\t}\n\t}\n\n\t/** Delivers items in the queue. Assumes the queue is ready to go. */\n\tprivate _deliverQueue(dq: EventDeliveryQueuePrivate) {\n\t\tconst listeners = dq.current!._listeners! as (\n\t\t\t| ListenerContainer<T>\n\t\t\t| undefined\n\t\t)[];\n\t\twhile (dq.i < dq.end) {\n\t\t\t// important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n\t\t\tthis._deliver(listeners[dq.i++], dq.value as T);\n\t\t}\n\t\tdq.reset();\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._deliveryQueue?.current) {\n\t\t\tthis._deliverQueue(this._deliveryQueue);\n\t\t\tthis._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n\t\t}\n\n\t\tthis._perfMon?.start(this._size);\n\n\t\tif (!this._listeners) {\n\t\t\t// no-op\n\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\tthis._deliver(this._listeners, event);\n\t\t} else {\n\t\t\tconst dq = this._deliveryQueue!;\n\t\t\tdq.enqueue(this, event, this._listeners.length);\n\t\t\tthis._deliverQueue(dq);\n\t\t}\n\n\t\tthis._perfMon?.stop();\n\t}\n\n\thasListeners(): boolean {\n\t\treturn this._size > 0;\n\t}\n}\n\nexport interface EventDeliveryQueue {\n\t_isEventDeliveryQueue: true;\n}\n\nexport const createEventDeliveryQueue = (): EventDeliveryQueue =>\n\tnew EventDeliveryQueuePrivate();\n\nclass EventDeliveryQueuePrivate implements EventDeliveryQueue {\n\tdeclare _isEventDeliveryQueue: true;\n\n\t/**\n\t * Index in current's listener list.\n\t */\n\tpublic i = -1;\n\n\t/**\n\t * The last index in the listener's list to deliver.\n\t */\n\tpublic end = 0;\n\n\t/**\n\t * Emitter currently being dispatched on. Emitter._listeners is always an array.\n\t */\n\tpublic current?: Emitter<any>;\n\t/**\n\t * Currently emitting value. Defined whenever `current` is.\n\t */\n\tpublic value?: unknown;\n\n\tpublic enqueue<T>(emitter: Emitter<T>, value: T, end: number) {\n\t\tthis.i = 0;\n\t\tthis.end = end;\n\t\tthis.current = emitter;\n\t\tthis.value = value;\n\t}\n\n\tpublic reset() {\n\t\tthis.i = this.end; // force any current emission loop to stop, mainly for during dispose\n\t\tthis.current = undefined;\n\t\tthis.value = undefined;\n\t}\n}\n\nexport interface IWaitUntil {\n\ttoken: CancellationToken;\n\twaitUntil(thenable: Promise<unknown>): void;\n}\n\nexport type IWaitUntilData<T> = Omit<Omit<T, \"waitUntil\">, \"token\">;\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\tprivate _asyncDeliveryQueue?: LinkedList<\n\t\t[(ev: T) => void, IWaitUntilData<T>]\n\t>;\n\n\tasync fireAsync(\n\t\tdata: IWaitUntilData<T>,\n\t\ttoken: CancellationToken,\n\t\tpromiseJoin?: (\n\t\t\tp: Promise<unknown>,\n\t\t\tlistener: Function,\n\t\t) => Promise<unknown>,\n\t): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = new LinkedList();\n\t\t}\n\n\t\tforEachListener(this._listeners, (listener) =>\n\t\t\tthis._asyncDeliveryQueue!.push([listener.value, data]),\n\t\t);\n\n\t\twhile (\n\t\t\tthis._asyncDeliveryQueue.size > 0 &&\n\t\t\t!token.isCancellationRequested\n\t\t) {\n\t\t\tconst [listener, data] = this._asyncDeliveryQueue.shift()!;\n\t\t\tconst thenables: Promise<unknown>[] = [];\n\n\t\t\tconst event = <T>{\n\t\t\t\t...data,\n\t\t\t\ttoken,\n\t\t\t\twaitUntil: (p: Promise<unknown>): void => {\n\t\t\t\t\tif (Object.isFrozen(thenables)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"waitUntil can NOT be called asynchronous\",\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (promiseJoin) {\n\t\t\t\t\t\tp = promiseJoin(p, listener);\n\t\t\t\t\t}\n\t\t\t\t\tthenables.push(p);\n\t\t\t\t},\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tlistener(event);\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\n\t\t\tawait Promise.allSettled(thenables).then((values) => {\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tif (value.status === \"rejected\") {\n\t\t\t\t\t\tonUnexpectedError(value.reason);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\nexport class PauseableEmitter<T> extends Emitter<T> {\n\tprivate _isPaused = 0;\n\tprotected _eventQueue = new LinkedList<T>();\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tpublic get isPaused(): boolean {\n\t\treturn this._isPaused !== 0;\n\t}\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\n\tpause(): void {\n\t\tthis._isPaused++;\n\t}\n\n\tresume(): void {\n\t\tif (this._isPaused !== 0 && --this._isPaused === 0) {\n\t\t\tif (this._mergeFn) {\n\t\t\t\t// use the merge function to create a single composite\n\t\t\t\t// event. make a copy in case firing pauses this emitter\n\t\t\t\tif (this._eventQueue.size > 0) {\n\t\t\t\t\tconst events = Array.from(this._eventQueue);\n\t\t\t\t\tthis._eventQueue.clear();\n\t\t\t\t\tsuper.fire(this._mergeFn(events));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// no merging, fire each event individually and test\n\t\t\t\t// that this emitter isn't paused halfway through\n\t\t\t\twhile (!this._isPaused && this._eventQueue.size !== 0) {\n\t\t\t\t\tsuper.fire(this._eventQueue.shift()!);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (this._size) {\n\t\t\tif (this._isPaused !== 0) {\n\t\t\t\tthis._eventQueue.push(event);\n\t\t\t} else {\n\t\t\t\tsuper.fire(event);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class DebounceEmitter<T> extends PauseableEmitter<T> {\n\tprivate readonly _delay: number;\n\tprivate _handle: any | undefined;\n\n\tconstructor(\n\t\toptions: EmitterOptions & { merge: (input: T[]) => T; delay?: number },\n\t) {\n\t\tsuper(options);\n\t\tthis._delay = options.delay ?? 100;\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (!this._handle) {\n\t\t\tthis.pause();\n\t\t\tthis._handle = setTimeout(() => {\n\t\t\t\tthis._handle = undefined;\n\t\t\t\tthis.resume();\n\t\t\t}, this._delay);\n\t\t}\n\t\tsuper.fire(event);\n\t}\n}\n\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter<T> extends Emitter<T> {\n\tprivate _queuedEvents: T[] = [];\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\toverride fire(event: T): void {\n\t\tif (!this.hasListeners()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._queuedEvents.push(event);\n\t\tif (this._queuedEvents.length === 1) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (this._mergeFn) {\n\t\t\t\t\tsuper.fire(this._mergeFn(this._queuedEvents));\n\t\t\t\t} else {\n\t\t\t\t\tthis._queuedEvents.forEach((e) => super.fire(e));\n\t\t\t\t}\n\t\t\t\tthis._queuedEvents = [];\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport class EventMultiplexer<T> implements IDisposable {\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => this.onFirstListenerAdd(),\n\t\t\tonDidRemoveLastListener: () => this.onLastListenerRemove(),\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(createSingleCallFunction(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach((e) => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach((e) => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener = e.event((r) => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener?.dispose();\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\n\t\tfor (const e of this.events) {\n\t\t\te.listener?.dispose();\n\t\t}\n\t\tthis.events = [];\n\t}\n}\n\nexport interface IDynamicListEventMultiplexer<TEventType> extends IDisposable {\n\treadonly event: Event<TEventType>;\n}\nexport class DynamicListEventMultiplexer<TItem, TEventType>\n\timplements IDynamicListEventMultiplexer<TEventType>\n{\n\tprivate readonly _store = new DisposableStore();\n\n\treadonly event: Event<TEventType>;\n\n\tconstructor(\n\t\titems: TItem[],\n\t\tonAddItem: Event<TItem>,\n\t\tonRemoveItem: Event<TItem>,\n\t\tgetEvent: (item: TItem) => Event<TEventType>,\n\t) {\n\t\tconst multiplexer = this._store.add(new EventMultiplexer<TEventType>());\n\t\tconst itemListeners = this._store.add(\n\t\t\tnew DisposableMap<TItem, IDisposable>(),\n\t\t);\n\n\t\tfunction addItem(instance: TItem) {\n\t\t\titemListeners.set(instance, multiplexer.add(getEvent(instance)));\n\t\t}\n\n\t\t// Existing items\n\t\tfor (const instance of items) {\n\t\t\taddItem(instance);\n\t\t}\n\n\t\t// Added items\n\t\tthis._store.add(\n\t\t\tonAddItem((instance) => {\n\t\t\t\taddItem(instance);\n\t\t\t}),\n\t\t);\n\n\t\t// Removed items\n\t\tthis._store.add(\n\t\t\tonRemoveItem((instance) => {\n\t\t\t\titemListeners.deleteAndDispose(instance);\n\t\t\t}),\n\t\t);\n\n\t\tthis.event = multiplexer.event;\n\t}\n\n\tdispose() {\n\t\tthis._store.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\tprivate data: { buffers: Function[] }[] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T>;\n\twrapEvent<T>(\n\t\tevent: Event<T>,\n\t\treduce: (last: T | undefined, event: T) => T,\n\t): Event<T>;\n\twrapEvent<T, O>(\n\t\tevent: Event<T>,\n\t\treduce: (last: O | undefined, event: T) => O,\n\t\tinitial: O,\n\t): Event<O>;\n\twrapEvent<T, O>(\n\t\tevent: Event<T>,\n\t\treduce?: (last: T | O | undefined, event: T) => T | O,\n\t\tinitial?: O,\n\t): Event<O | T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(\n\t\t\t\t(i) => {\n\t\t\t\t\tconst data = this.data[this.data.length - 1];\n\n\t\t\t\t\t// Non-reduce scenario\n\t\t\t\t\tif (!reduce) {\n\t\t\t\t\t\t// Buffering case\n\t\t\t\t\t\tif (data) {\n\t\t\t\t\t\t\tdata.buffers.push(() => listener.call(thisArgs, i));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Not buffering case\n\t\t\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reduce scenario\n\t\t\t\t\tconst reduceData = data as typeof data & {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * The accumulated items that will be reduced.\n\t\t\t\t\t\t */\n\t\t\t\t\t\titems?: T[];\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * The reduced result cached to be shared with other listeners.\n\t\t\t\t\t\t */\n\t\t\t\t\t\treducedResult?: T | O;\n\t\t\t\t\t};\n\n\t\t\t\t\t// Not buffering case\n\t\t\t\t\tif (!reduceData) {\n\t\t\t\t\t\t// TODO: Is there a way to cache this reduce call for all listeners?\n\t\t\t\t\t\tlistener.call(thisArgs, reduce(initial, i));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Buffering case\n\t\t\t\t\treduceData.items ??= [];\n\t\t\t\t\treduceData.items.push(i);\n\t\t\t\t\tif (reduceData.buffers.length === 0) {\n\t\t\t\t\t\t// Include a single buffered function that will reduce all events when we're done buffering events\n\t\t\t\t\t\tdata.buffers.push(() => {\n\t\t\t\t\t\t\t// cache the reduced result so that the value can be shared across all listeners\n\t\t\t\t\t\t\treduceData.reducedResult ??= initial\n\t\t\t\t\t\t\t\t? reduceData.items!.reduce(\n\t\t\t\t\t\t\t\t\t\treduce as (\n\t\t\t\t\t\t\t\t\t\t\tlast: O | undefined,\n\t\t\t\t\t\t\t\t\t\t\tevent: T,\n\t\t\t\t\t\t\t\t\t\t) => O,\n\t\t\t\t\t\t\t\t\t\tinitial,\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t: reduceData.items!.reduce(\n\t\t\t\t\t\t\t\t\t\treduce as (\n\t\t\t\t\t\t\t\t\t\t\tlast: T | undefined,\n\t\t\t\t\t\t\t\t\t\t\tevent: T,\n\t\t\t\t\t\t\t\t\t\t) => T,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tlistener.call(thisArgs, reduceData.reducedResult);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tundefined,\n\t\t\t\tdisposables,\n\t\t\t);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst data = { buffers: new Array<Function>() };\n\t\tthis.data.push(data);\n\t\tconst r = fn();\n\t\tthis.data.pop();\n\t\tdata.buffers.forEach((flush) => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate readonly emitter = new Emitter<T>({\n\t\tonDidAddFirstListener: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(\n\t\t\t\tthis.emitter.fire,\n\t\t\t\tthis.emitter,\n\t\t\t);\n\t\t},\n\t\tonDidRemoveLastListener: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t},\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n\nexport interface IValueWithChangeEvent<T> {\n\treadonly onDidChange: Event<void>;\n\tget value(): T;\n}\n\nexport class ValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic static const<T>(value: T): IValueWithChangeEvent<T> {\n\t\treturn new ConstValueWithChangeEvent(value);\n\t}\n\n\tprivate readonly _onDidChange = new Emitter<void>();\n\treadonly onDidChange: Event<void> = this._onDidChange.event;\n\n\tconstructor(private _value: T) {}\n\n\tget value(): T {\n\t\treturn this._value;\n\t}\n\n\tset value(value: T) {\n\t\tif (value !== this._value) {\n\t\t\tthis._value = value;\n\t\t\tthis._onDidChange.fire(undefined);\n\t\t}\n\t}\n}\n\nclass ConstValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic readonly onDidChange: Event<void> = Event.None;\n\n\tconstructor(readonly value: T) {}\n}\n\n/**\n * @param handleItem Is called for each item in the set (but only the first time the item is seen in the set).\n * \tThe returned disposable is disposed if the item is no longer in the set.\n */\nexport function trackSetChanges<T>(\n\tgetData: () => ReadonlySet<T>,\n\tonDidChangeData: Event<unknown>,\n\thandleItem: (d: T) => IDisposable,\n): IDisposable {\n\tconst map = new DisposableMap<T, IDisposable>();\n\tlet oldData = new Set(getData());\n\tfor (const d of oldData) {\n\t\tmap.set(d, handleItem(d));\n\t}\n\n\tconst store = new DisposableStore();\n\tstore.add(\n\t\tonDidChangeData(() => {\n\t\t\tconst newData = getData();\n\t\t\tconst diff = diffSets(oldData, newData);\n\t\t\tfor (const r of diff.removed) {\n\t\t\t\tmap.deleteAndDispose(r);\n\t\t\t}\n\t\t\tfor (const a of diff.added) {\n\t\t\t\tmap.set(a, handleItem(a));\n\t\t\t}\n\t\t\toldData = new Set(newData);\n\t\t}),\n\t);\n\tstore.add(map);\n\treturn store;\n}\n"],
  "mappings": "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",
  "names": ["Event", "map", "filter", "buffer", "id", "count", "stack", "data"]
}
