{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/event.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from './cancellation.js';\nimport { diffSets } from './collections.js';\nimport { onUnexpectedError } from './errors.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableMap, DisposableStore, IDisposable, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { IObservable, IObserver } from './observable.js';\nimport { StopWatch } from './stopwatch.js';\nimport { MicrotaskDelay } from './symbols.js';\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableListenerGCedWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n/**\n * An event with zero or one parameters that can be subscribed to. The event is a function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n}\n\nexport namespace Event {\n\texport const None: Event<any> = () => Disposable.None;\n\n\tfunction _addLeakageTraceLogic(options: EmitterOptions) {\n\t\tif (_enableSnapshotPotentialLeakWarning) {\n\t\t\tconst { onDidAddListener: origListenerDidAdd } = options;\n\t\t\tconst stack = Stacktrace.create();\n\t\t\tlet count = 0;\n\t\t\toptions.onDidAddListener = () => {\n\t\t\t\tif (++count === 2) {\n\t\t\t\t\tconsole.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n\t\t\t\t\tstack.print();\n\t\t\t\t}\n\t\t\t\torigListenerDidAdd?.();\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n\t * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n\t * result of merging events and to try prevent race conditions that could arise when using related deferred and\n\t * non-deferred events.\n\t *\n\t * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n\t * (eg. latency of keypress to text rendered).\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function defer(event: Event<unknown>, disposable?: DisposableStore): Event<void> {\n\t\treturn debounce<unknown, void>(event, () => void 0, 0, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable | undefined = undefined;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once, and only when the condition is met.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function onceIf<T>(event: Event<T>, condition: (e: T) => boolean): Event<T> {\n\t\treturn Event.once(Event.filter(event, condition));\n\t}\n\n\t/**\n\t * Maps an event of one type into an event of another type using a mapping function, similar to how\n\t * `Array.prototype.map` works.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param map The mapping function.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O, disposable?: DisposableStore): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that performs some function on the event object before firing.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param each The function to perform on the event object.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void, disposable?: DisposableStore): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that fires only when some condition is met.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param filter The filter function that defines the condition. The event will fire for the object if this function\n\t * returns true.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function filter<T, U>(event: Event<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event<T>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T>;\n\texport function any(...events: Event<any>[]): Event<void>;\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\tconst disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n\t\t\treturn addAndReturnDisposable(disposable, disposables);\n\t\t};\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O, disposable?: DisposableStore): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t}, disposable);\n\t}\n\n\tfunction snapshot<T>(event: Event<T>, disposable: DisposableStore | undefined): Event<T> {\n\t\tlet listener: IDisposable | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tlistener?.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<T>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Adds the IDisposable to the store if it's set, and returns it. Useful to\n\t * Event function implementation.\n\t */\n\tfunction addAndReturnDisposable<T extends IDisposable>(d: T, store: DisposableStore | IDisposable[] | undefined): T {\n\t\tif (store instanceof Array) {\n\t\t\tstore.push(d);\n\t\t} else if (store) {\n\t\t\tstore.add(d);\n\t\t}\n\t\treturn d;\n\t}\n\n\t/**\n\t * Given an event, creates a new emitter that event that will debounce events based on {@link delay} and give an\n\t * array event object of all events that fired.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The original event to debounce.\n\t * @param merge A function that reduces all events into a single event.\n\t * @param delay The number of milliseconds to debounce.\n\t * @param leading Whether to fire a leading event without debouncing.\n\t * @param flushOnListenerRemove Whether to fire all debounced events when a listener is removed. If this is not\n\t * specified, some events could go missing. Use this if it's important that all events are processed, even if the\n\t * listener gets disposed before the debounced event fires.\n\t * @param leakWarningThreshold See {@link EmitterOptions.leakWarningThreshold}.\n\t * @param disposable A disposable store to register the debounce emitter to.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number | typeof MicrotaskDelay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O> {\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: any = undefined;\n\t\tlet numDebouncedCalls = 0;\n\t\tlet doFire: (() => void) | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tleakWarningThreshold,\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tdoFire = () => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t};\n\n\t\t\t\t\tif (typeof delay === 'number') {\n\t\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\t\thandle = setTimeout(doFire, delay);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (handle === undefined) {\n\t\t\t\t\t\t\thandle = 0;\n\t\t\t\t\t\t\tqueueMicrotask(doFire);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tonWillRemoveListener() {\n\t\t\t\tif (flushOnListenerRemove && numDebouncedCalls > 0) {\n\t\t\t\t\tdoFire?.();\n\t\t\t\t}\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tdoFire = undefined;\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<O>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function accumulate<T>(event: Event<T>, delay: number = 0, disposable?: DisposableStore): Event<T[]> {\n\t\treturn Event.debounce<T, T[]>(event, (last, e) => {\n\t\t\tif (!last) {\n\t\t\t\treturn [e];\n\t\t\t}\n\t\t\tlast.push(e);\n\t\t\treturn last;\n\t\t}, delay, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n\t * event objects from different sources do not fire the same event object.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param equals The equality condition.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t *\n\t * @example\n\t * ```\n\t * // Fire only one time when a single window is opened or focused\n\t * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n\t * ```\n\t */\n\texport function latch<T>(event: Event<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b, disposable?: DisposableStore): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t}, disposable);\n\t}\n\n\t/**\n\t * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @example\n\t * ```\n\t * const event = new EventEmitter<number | undefined>().event;\n\t * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n\t * ```\n\t *\n\t * @param event The event source for the new event.\n\t * @param isT A function that determines what event is of the first type.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function split<T, U>(event: Event<T | U>, isT: (e: T | U) => e is T, disposable?: DisposableStore): [Event<T>, Event<U>] {\n\t\treturn [\n\t\t\tEvent.filter(event, isT, disposable),\n\t\t\tEvent.filter(event, e => !isT(e), disposable) as Event<U>,\n\t\t];\n\t}\n\n\t/**\n\t * Buffers an event until it has a listener attached.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n\t * `setTimeout` when the first event listener is added.\n\t * @param _buffer Internal: A source event array used for tests.\n\t *\n\t * @example\n\t * ```\n\t * // Start accumulating events, when the first listener is attached, flush\n\t * // the event after a timeout such that multiple listeners attached before\n\t * // the timeout would receive the event\n\t * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, flushAfterTimeout = false, _buffer: T[] = [], disposable?: DisposableStore): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(listener);\n\t\t}\n\n\t\tconst flush = () => {\n\t\t\tbuffer?.forEach(e => emitter.fire(e));\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t\tif (disposable) {\n\t\t\t\t\t\tdisposable.add(listener);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidAddFirstListener() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (flushAfterTimeout) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(emitter);\n\t\t}\n\n\t\treturn emitter.event;\n\t}\n\t/**\n\t * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n\t *\n\t * @example\n\t * ```\n\t * // Normal\n\t * const onEnterPressNormal = Event.filter(\n\t *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n\t *   e.keyCode === KeyCode.Enter\n\t * ).event;\n\t *\n\t * // Using chain\n\t * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n\t *   .map(e => new StandardKeyboardEvent(e))\n\t *   .filter(e => e.keyCode === KeyCode.Enter)\n\t * );\n\t * ```\n\t */\n\texport function chain<T, R>(event: Event<T>, sythensize: ($: IChainableSythensis<T>) => IChainableSythensis<R>): Event<R> {\n\t\tconst fn: Event<R> = (listener, thisArgs, disposables) => {\n\t\t\tconst cs = sythensize(new ChainableSynthesis()) as ChainableSynthesis;\n\t\t\treturn event(function (value) {\n\t\t\t\tconst result = cs.evaluate(value);\n\t\t\t\tif (result !== HaltChainable) {\n\t\t\t\t\tlistener.call(thisArgs, result);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\n\t\treturn fn;\n\t}\n\n\tconst HaltChainable = Symbol('HaltChainable');\n\n\tclass ChainableSynthesis implements IChainableSythensis<any> {\n\t\tprivate readonly steps: ((input: any) => any)[] = [];\n\n\t\tmap<O>(fn: (i: any) => O): this {\n\t\t\tthis.steps.push(fn);\n\t\t\treturn this;\n\t\t}\n\n\t\tforEach(fn: (i: any) => void): this {\n\t\t\tthis.steps.push(v => {\n\t\t\t\tfn(v);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tfilter(fn: (e: any) => boolean): this {\n\t\t\tthis.steps.push(v => fn(v) ? v : HaltChainable);\n\t\t\treturn this;\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: any) => R, initial?: R | undefined): this {\n\t\t\tlet last = initial;\n\t\t\tthis.steps.push(v => {\n\t\t\t\tlast = merge(last, v);\n\t\t\t\treturn last;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tlatch(equals: (a: any, b: any) => boolean = (a, b) => a === b): ChainableSynthesis {\n\t\t\tlet firstCall = true;\n\t\t\tlet cache: any;\n\t\t\tthis.steps.push(value => {\n\t\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\t\tfirstCall = false;\n\t\t\t\tcache = value;\n\t\t\t\treturn shouldEmit ? value : HaltChainable;\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic evaluate(value: any) {\n\t\t\tfor (const step of this.steps) {\n\t\t\t\tvalue = step(value);\n\t\t\t\tif (value === HaltChainable) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t}\n\n\texport interface IChainableSythensis<T> {\n\t\tmap<O>(fn: (i: T) => O): IChainableSythensis<O>;\n\t\tforEach(fn: (i: T) => void): IChainableSythensis<T>;\n\t\tfilter<R extends T>(fn: (e: T) => e is R): IChainableSythensis<R>;\n\t\tfilter(fn: (e: T) => boolean): IChainableSythensis<T>;\n\t\treduce<R>(merge: (last: R, event: T) => R, initial: R): IChainableSythensis<R>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R): IChainableSythensis<R>;\n\t\tlatch(equals?: (a: T, b: T) => boolean): IChainableSythensis<T>;\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): unknown;\n\t\tremoveListener(event: string | symbol, listener: Function): unknown;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a node event emitter.\n\t */\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport interface DOMEventEmitter {\n\t\taddEventListener(event: string | symbol, listener: Function): void;\n\t\tremoveEventListener(event: string | symbol, listener: Function): void;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a DOM event emitter.\n\t */\n\texport function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\t/**\n\t * Creates a promise out of an event, using the {@link Event.once} helper.\n\t */\n\texport function toPromise<T>(event: Event<T>): Promise<T> {\n\t\treturn new Promise(resolve => once(event)(resolve));\n\t}\n\n\t/**\n\t * Creates an event out of a promise that fires once when the promise is\n\t * resolved with the result of the promise or `undefined`.\n\t */\n\texport function fromPromise<T>(promise: Promise<T>): Event<T | undefined> {\n\t\tconst result = new Emitter<T | undefined>();\n\n\t\tpromise.then(res => {\n\t\t\tresult.fire(res);\n\t\t}, () => {\n\t\t\tresult.fire(undefined);\n\t\t}).finally(() => {\n\t\t\tresult.dispose();\n\t\t});\n\n\t\treturn result.event;\n\t}\n\n\t/**\n\t * A convenience function for forwarding an event to another emitter which\n\t * improves readability.\n\t *\n\t * This is similar to {@link Relay} but allows instantiating and forwarding\n\t * on a single line and also allows for multiple source events.\n\t * @param from The event to forward.\n\t * @param to The emitter to forward the event to.\n\t * @example\n\t * Event.forward(event, emitter);\n\t * // equivalent to\n\t * event(e => emitter.fire(e));\n\t * // equivalent to\n\t * event(emitter.fire, emitter);\n\t */\n\texport function forward<T>(from: Event<T>, to: Emitter<T>): IDisposable {\n\t\treturn from(e => to.fire(e));\n\t}\n\n\t/**\n\t * Adds a listener to an event and calls the listener immediately with undefined as the event object.\n\t *\n\t * @example\n\t * ```\n\t * // Initialize the UI and update it when dataChangeEvent fires\n\t * runAndSubscribe(dataChangeEvent, () => this._updateUI());\n\t * ```\n\t */\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T) => any, initial: T): IDisposable;\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => any): IDisposable;\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => any, initial?: T): IDisposable {\n\t\thandler(initial);\n\t\treturn event(e => handler(e));\n\t}\n\n\tclass EmitterObserver<T> implements IObserver {\n\n\t\treadonly emitter: Emitter<T>;\n\n\t\tprivate _counter = 0;\n\t\tprivate _hasChanged = false;\n\n\t\tconstructor(readonly _observable: IObservable<T, any>, store: DisposableStore | undefined) {\n\t\t\tconst options: EmitterOptions = {\n\t\t\t\tonWillAddFirstListener: () => {\n\t\t\t\t\t_observable.addObserver(this);\n\n\t\t\t\t\t// Communicate to the observable that we received its current value and would like to be notified about future changes.\n\t\t\t\t\tthis._observable.reportChanges();\n\t\t\t\t},\n\t\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\t\t_observable.removeObserver(this);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (!store) {\n\t\t\t\t_addLeakageTraceLogic(options);\n\t\t\t}\n\t\t\tthis.emitter = new Emitter<T>(options);\n\t\t\tif (store) {\n\t\t\t\tstore.add(this.emitter);\n\t\t\t}\n\t\t}\n\n\t\tbeginUpdate<T>(_observable: IObservable<T, void>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter++;\n\t\t}\n\n\t\thandlePossibleChange<T>(_observable: IObservable<T, unknown>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t}\n\n\t\thandleChange<T, TChange>(_observable: IObservable<T, TChange>, _change: TChange): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._hasChanged = true;\n\t\t}\n\n\t\tendUpdate<T>(_observable: IObservable<T, void>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter--;\n\t\t\tif (this._counter === 0) {\n\t\t\t\tthis._observable.reportChanges();\n\t\t\t\tif (this._hasChanged) {\n\t\t\t\t\tthis._hasChanged = false;\n\t\t\t\t\tthis.emitter.fire(this._observable.get());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an event emitter that is fired when the observable changes.\n\t * Each listeners subscribes to the emitter.\n\t */\n\texport function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event<T> {\n\t\tconst observer = new EmitterObserver(obs, store);\n\t\treturn observer.emitter.event;\n\t}\n\n\t/**\n\t * Each listener is attached to the observable directly.\n\t */\n\texport function fromObservableLight(observable: IObservable<any>): Event<void> {\n\t\treturn (listener, thisArgs, disposables) => {\n\t\t\tlet count = 0;\n\t\t\tlet didChange = false;\n\t\t\tconst observer: IObserver = {\n\t\t\t\tbeginUpdate() {\n\t\t\t\t\tcount++;\n\t\t\t\t},\n\t\t\t\tendUpdate() {\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\tobservable.reportChanges();\n\t\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\t\tdidChange = false;\n\t\t\t\t\t\t\tlistener.call(thisArgs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\thandlePossibleChange() {\n\t\t\t\t\t// noop\n\t\t\t\t},\n\t\t\t\thandleChange() {\n\t\t\t\t\tdidChange = true;\n\t\t\t\t}\n\t\t\t};\n\t\t\tobservable.addObserver(observer);\n\t\t\tobservable.reportChanges();\n\t\t\tconst disposable = {\n\t\t\t\tdispose() {\n\t\t\t\t\tobservable.removeObserver(observer);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\tdisposables.add(disposable);\n\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\tdisposables.push(disposable);\n\t\t\t}\n\n\t\t\treturn disposable;\n\t\t};\n\t}\n}\n\nexport interface EmitterOptions {\n\t/**\n\t * Optional function that's called *before* the very first listener is added\n\t */\n\tonWillAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called *after* the very first listener is added\n\t */\n\tonDidAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called after a listener is added\n\t */\n\tonDidAddListener?: Function;\n\t/**\n\t * Optional function that's called *after* remove the very last listener\n\t */\n\tonDidRemoveLastListener?: Function;\n\t/**\n\t * Optional function that's called *before* a listener is removed\n\t */\n\tonWillRemoveListener?: Function;\n\t/**\n\t * Optional function that's called when a listener throws an error. Defaults to\n\t * {@link onUnexpectedError}\n\t */\n\tonListenerError?: (e: any) => void;\n\t/**\n\t * Number of listeners that are allowed before assuming a leak. Default to\n\t * a globally configured value\n\t *\n\t * @see setGlobalLeakWarningThreshold\n\t */\n\tleakWarningThreshold?: number;\n\t/**\n\t * Pass in a delivery queue, which is useful for ensuring\n\t * in order event delivery across multiple emitters.\n\t */\n\tdeliveryQueue?: EventDeliveryQueue;\n\n\t/** ONLY enable this during development */\n\t_profName?: string;\n}\n\n\nexport class EventProfiling {\n\n\tstatic readonly all = new Set<EventProfiling>();\n\n\tprivate static _idPool = 0;\n\n\treadonly name: string;\n\tpublic listenerCount: number = 0;\n\tpublic invocationCount = 0;\n\tpublic elapsedOverall = 0;\n\tpublic durations: number[] = [];\n\n\tprivate _stopWatch?: StopWatch;\n\n\tconstructor(name: string) {\n\t\tthis.name = `${name}_${EventProfiling._idPool++}`;\n\t\tEventProfiling.all.add(this);\n\t}\n\n\tstart(listenerCount: number): void {\n\t\tthis._stopWatch = new StopWatch();\n\t\tthis.listenerCount = listenerCount;\n\t}\n\n\tstop(): void {\n\t\tif (this._stopWatch) {\n\t\t\tconst elapsed = this._stopWatch.elapsed();\n\t\t\tthis.durations.push(elapsed);\n\t\t\tthis.elapsedOverall += elapsed;\n\t\t\tthis.invocationCount += 1;\n\t\t\tthis._stopWatch = undefined;\n\t\t}\n\t}\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate static _idPool = 1;\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _errorHandler: (err: Error) => void,\n\t\treadonly threshold: number,\n\t\treadonly name: string = (LeakageMonitor._idPool++).toString(16).padStart(3, '0')\n\t) { }\n\n\tdispose(): void {\n\t\tthis._stacks?.clear();\n\t}\n\n\tcheck(stack: Stacktrace, listenerCount: number): undefined | (() => void) {\n\n\t\tconst threshold = this.threshold;\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst count = (this._stacks.get(stack.value) || 0);\n\t\tthis._stacks.set(stack.value, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\tconst [topStack, topCount] = this.getMostFrequentStack()!;\n\t\t\tconst message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\n\t\t\tconsole.warn(message);\n\t\t\tconsole.warn(topStack!);\n\n\t\t\tconst error = new ListenerLeakError(message, topStack);\n\t\t\tthis._errorHandler(error);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack.value) || 0);\n\t\t\tthis._stacks!.set(stack.value, count - 1);\n\t\t};\n\t}\n\n\tgetMostFrequentStack(): [string, number] | undefined {\n\t\tif (!this._stacks) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet topStack: [string, number] | undefined;\n\t\tlet topCount: number = 0;\n\t\tfor (const [stack, count] of this._stacks) {\n\t\t\tif (!topStack || topCount < count) {\n\t\t\t\ttopStack = [stack, count];\n\t\t\t\ttopCount = count;\n\t\t\t}\n\t\t}\n\t\treturn topStack;\n\t}\n}\n\nclass Stacktrace {\n\n\tstatic create() {\n\t\tconst err = new Error();\n\t\treturn new Stacktrace(err.stack ?? '');\n\t}\n\n\tprivate constructor(readonly value: string) { }\n\n\tprint() {\n\t\tconsole.warn(this.value.split('\\n').slice(2).join('\\n'));\n\t}\n}\n\n// error that is logged when going over the configured listener threshold\nexport class ListenerLeakError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = 'ListenerLeakError';\n\t\tthis.stack = stack;\n\t}\n}\n\n// SEVERE error that is logged when having gone way over the configured listener\n// threshold so that the emitter refuses to accept more listeners\nexport class ListenerRefusalError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = 'ListenerRefusalError';\n\t\tthis.stack = stack;\n\t}\n}\n\nlet id = 0;\nclass UniqueContainer<T> {\n\tstack?: Stacktrace;\n\tpublic id = id++;\n\tconstructor(public readonly value: T) { }\n}\nconst compactionThreshold = 2;\n\ntype ListenerContainer<T> = UniqueContainer<(data: T) => void>;\ntype ListenerOrListeners<T> = (ListenerContainer<T> | undefined)[] | ListenerContainer<T>;\n\nconst forEachListener = <T>(listeners: ListenerOrListeners<T>, fn: (c: ListenerContainer<T>) => void) => {\n\tif (listeners instanceof UniqueContainer) {\n\t\tfn(listeners);\n\t} else {\n\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\tconst l = listeners[i];\n\t\t\tif (l) {\n\t\t\t\tfn(l);\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nlet _listenerFinalizers: FinalizationRegistry<string> | undefined;\n\nif (_enableListenerGCedWarning) {\n\tconst leaks: string[] = [];\n\n\tsetInterval(() => {\n\t\tif (leaks.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconsole.warn('[LEAKING LISTENERS] GC\\'ed these listeners that were NOT yet disposed:');\n\t\tconsole.warn(leaks.join('\\n'));\n\t\tleaks.length = 0;\n\t}, 3000);\n\n\t_listenerFinalizers = new FinalizationRegistry(heldValue => {\n\t\tif (typeof heldValue === 'string') {\n\t\t\tleaks.push(heldValue);\n\t\t}\n\t});\n}\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate readonly _perfMon?: EventProfiling;\n\tprivate _disposed?: true;\n\tprivate _event?: Event<T>;\n\n\t/**\n\t * A listener, or list of listeners. A single listener is the most common\n\t * for event emitters (#185789), so we optimize that special case to avoid\n\t * wrapping it in an array (just like Node.js itself.)\n\t *\n\t * A list of listeners never 'downgrades' back to a plain function if\n\t * listeners are removed, for two reasons:\n\t *\n\t *  1. That's complicated (especially with the deliveryQueue)\n\t *  2. A listener with >1 listener is likely to have >1 listener again at\n\t *     some point, and swapping between arrays and functions may[citation needed]\n\t *     introduce unnecessary work and garbage.\n\t *\n\t * The array listeners can be 'sparse', to avoid reallocating the array\n\t * whenever any listener is added or removed. If more than `1 / compactionThreshold`\n\t * of the array is empty, only then is it resized.\n\t */\n\tprotected _listeners?: ListenerOrListeners<T>;\n\n\t/**\n\t * Always to be defined if _listeners is an array. It's no longer a true\n\t * queue, but holds the dispatching 'state'. If `fire()` is called on an\n\t * emitter, any work left in the _deliveryQueue is finished first.\n\t */\n\tprivate _deliveryQueue?: EventDeliveryQueuePrivate;\n\tprotected _size = 0;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = (_globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold)\n\t\t\t? new LeakageMonitor(options?.onListenerError ?? onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) :\n\t\t\tundefined;\n\t\tthis._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n\t\tthis._deliveryQueue = this._options?.deliveryQueue as EventDeliveryQueuePrivate | undefined;\n\t}\n\n\tdispose() {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\t// It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n\t\t\t// alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n\t\t\t// unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n\t\t\t// the following programming pattern is very popular:\n\t\t\t//\n\t\t\t// const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n\t\t\t// this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n\t\t\t// ...later...\n\t\t\t// this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n\n\t\t\tif (this._deliveryQueue?.current === this) {\n\t\t\t\tthis._deliveryQueue.reset();\n\t\t\t}\n\t\t\tif (this._listeners) {\n\t\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\t\tconst listeners = this._listeners;\n\t\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t\tforEachListener(listeners, l => l.stack?.print());\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis._listeners = undefined;\n\t\t\t\tthis._size = 0;\n\t\t\t}\n\t\t\tthis._options?.onDidRemoveLastListener?.();\n\t\t\tthis._leakageMon?.dispose();\n\t\t}\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tthis._event ??= (callback: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore) => {\n\t\t\tif (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {\n\t\t\t\tconst message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\n\t\t\t\tconsole.warn(message);\n\n\t\t\t\tconst tuple = this._leakageMon.getMostFrequentStack() ?? ['UNKNOWN stack', -1];\n\t\t\t\tconst error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);\n\t\t\t\tconst errorHandler = this._options?.onListenerError || onUnexpectedError;\n\t\t\t\terrorHandler(error);\n\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (this._disposed) {\n\t\t\t\t// todo: should we warn if a listener is added to a disposed emitter? This happens often\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (thisArgs) {\n\t\t\t\tcallback = callback.bind(thisArgs);\n\t\t\t}\n\n\t\t\tconst contained = new UniqueContainer(callback);\n\n\t\t\tlet removeMonitor: Function | undefined;\n\t\t\tlet stack: Stacktrace | undefined;\n\t\t\tif (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tcontained.stack = Stacktrace.create();\n\t\t\t\tremoveMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n\t\t\t}\n\n\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\tcontained.stack = stack ?? Stacktrace.create();\n\t\t\t}\n\n\t\t\tif (!this._listeners) {\n\t\t\t\tthis._options?.onWillAddFirstListener?.(this);\n\t\t\t\tthis._listeners = contained;\n\t\t\t\tthis._options?.onDidAddFirstListener?.(this);\n\t\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\t\tthis._deliveryQueue ??= new EventDeliveryQueuePrivate();\n\t\t\t\tthis._listeners = [this._listeners, contained];\n\t\t\t} else {\n\t\t\t\tthis._listeners.push(contained);\n\t\t\t}\n\n\t\t\tthis._size++;\n\n\n\t\t\tconst result = toDisposable(() => {\n\t\t\t\t_listenerFinalizers?.unregister(result);\n\t\t\t\tremoveMonitor?.();\n\t\t\t\tthis._removeListener(contained);\n\t\t\t});\n\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\tdisposables.add(result);\n\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\tdisposables.push(result);\n\t\t\t}\n\n\t\t\tif (_listenerFinalizers) {\n\t\t\t\tconst stack = new Error().stack!.split('\\n').slice(2, 3).join('\\n').trim();\n\t\t\t\tconst match = /(file:|vscode-file:\\/\\/vscode-app)?(\\/[^:]*:\\d+:\\d+)/.exec(stack);\n\t\t\t\t_listenerFinalizers.register(result, match?.[2] ?? stack, result);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\treturn this._event;\n\t}\n\n\tprivate _removeListener(listener: ListenerContainer<T>) {\n\t\tthis._options?.onWillRemoveListener?.(this);\n\n\t\tif (!this._listeners) {\n\t\t\treturn; // expected if a listener gets disposed\n\t\t}\n\n\t\tif (this._size === 1) {\n\t\t\tthis._listeners = undefined;\n\t\t\tthis._options?.onDidRemoveLastListener?.(this);\n\t\t\tthis._size = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t// size > 1 which requires that listeners be a list:\n\t\tconst listeners = this._listeners as (ListenerContainer<T> | undefined)[];\n\n\t\tconst index = listeners.indexOf(listener);\n\t\tif (index === -1) {\n\t\t\tconsole.log('disposed?', this._disposed);\n\t\t\tconsole.log('size?', this._size);\n\t\t\tconsole.log('arr?', JSON.stringify(this._listeners));\n\t\t\tthrow new Error('Attempted to dispose unknown listener');\n\t\t}\n\n\t\tthis._size--;\n\t\tlisteners[index] = undefined;\n\n\t\tconst adjustDeliveryQueue = this._deliveryQueue!.current === this;\n\t\tif (this._size * compactionThreshold <= listeners.length) {\n\t\t\tlet n = 0;\n\t\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t\tif (listeners[i]) {\n\t\t\t\t\tlisteners[n++] = listeners[i];\n\t\t\t\t} else if (adjustDeliveryQueue) {\n\t\t\t\t\tthis._deliveryQueue!.end--;\n\t\t\t\t\tif (n < this._deliveryQueue!.i) {\n\t\t\t\t\t\tthis._deliveryQueue!.i--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisteners.length = n;\n\t\t}\n\t}\n\n\tprivate _deliver(listener: undefined | UniqueContainer<(value: T) => void>, value: T) {\n\t\tif (!listener) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst errorHandler = this._options?.onListenerError || onUnexpectedError;\n\t\tif (!errorHandler) {\n\t\t\tlistener.value(value);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tlistener.value(value);\n\t\t} catch (e) {\n\t\t\terrorHandler(e);\n\t\t}\n\t}\n\n\t/** Delivers items in the queue. Assumes the queue is ready to go. */\n\tprivate _deliverQueue(dq: EventDeliveryQueuePrivate) {\n\t\tconst listeners = dq.current!._listeners! as (ListenerContainer<T> | undefined)[];\n\t\twhile (dq.i < dq.end) {\n\t\t\t// important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n\t\t\tthis._deliver(listeners[dq.i++], dq.value as T);\n\t\t}\n\t\tdq.reset();\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._deliveryQueue?.current) {\n\t\t\tthis._deliverQueue(this._deliveryQueue);\n\t\t\tthis._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n\t\t}\n\n\t\tthis._perfMon?.start(this._size);\n\n\t\tif (!this._listeners) {\n\t\t\t// no-op\n\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\tthis._deliver(this._listeners, event);\n\t\t} else {\n\t\t\tconst dq = this._deliveryQueue!;\n\t\t\tdq.enqueue(this, event, this._listeners.length);\n\t\t\tthis._deliverQueue(dq);\n\t\t}\n\n\t\tthis._perfMon?.stop();\n\t}\n\n\thasListeners(): boolean {\n\t\treturn this._size > 0;\n\t}\n}\n\nexport interface EventDeliveryQueue {\n\t_isEventDeliveryQueue: true;\n}\n\nexport const createEventDeliveryQueue = (): EventDeliveryQueue => new EventDeliveryQueuePrivate();\n\nclass EventDeliveryQueuePrivate implements EventDeliveryQueue {\n\tdeclare _isEventDeliveryQueue: true;\n\n\t/**\n\t * Index in current's listener list.\n\t */\n\tpublic i = -1;\n\n\t/**\n\t * The last index in the listener's list to deliver.\n\t */\n\tpublic end = 0;\n\n\t/**\n\t * Emitter currently being dispatched on. Emitter._listeners is always an array.\n\t */\n\tpublic current?: Emitter<any>;\n\t/**\n\t * Currently emitting value. Defined whenever `current` is.\n\t */\n\tpublic value?: unknown;\n\n\tpublic enqueue<T>(emitter: Emitter<T>, value: T, end: number) {\n\t\tthis.i = 0;\n\t\tthis.end = end;\n\t\tthis.current = emitter;\n\t\tthis.value = value;\n\t}\n\n\tpublic reset() {\n\t\tthis.i = this.end; // force any current emission loop to stop, mainly for during dispose\n\t\tthis.current = undefined;\n\t\tthis.value = undefined;\n\t}\n}\n\nexport interface IWaitUntil {\n\ttoken: CancellationToken;\n\twaitUntil(thenable: Promise<unknown>): void;\n}\n\nexport type IWaitUntilData<T> = Omit<Omit<T, 'waitUntil'>, 'token'>;\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue?: LinkedList<[(ev: T) => void, IWaitUntilData<T>]>;\n\n\tasync fireAsync(data: IWaitUntilData<T>, token: CancellationToken, promiseJoin?: (p: Promise<unknown>, listener: Function) => Promise<unknown>): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = new LinkedList();\n\t\t}\n\n\t\tforEachListener(this._listeners, listener => this._asyncDeliveryQueue!.push([listener.value, data]));\n\n\t\twhile (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n\n\t\t\tconst [listener, data] = this._asyncDeliveryQueue.shift()!;\n\t\t\tconst thenables: Promise<unknown>[] = [];\n\n\t\t\tconst event = <T>{\n\t\t\t\t...data,\n\t\t\t\ttoken,\n\t\t\t\twaitUntil: (p: Promise<unknown>): void => {\n\t\t\t\t\tif (Object.isFrozen(thenables)) {\n\t\t\t\t\t\tthrow new Error('waitUntil can NOT be called asynchronous');\n\t\t\t\t\t}\n\t\t\t\t\tif (promiseJoin) {\n\t\t\t\t\t\tp = promiseJoin(p, listener);\n\t\t\t\t\t}\n\t\t\t\t\tthenables.push(p);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tlistener(event);\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\n\t\t\tawait Promise.allSettled(thenables).then(values => {\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tif (value.status === 'rejected') {\n\t\t\t\t\t\tonUnexpectedError(value.reason);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\n\nexport class PauseableEmitter<T> extends Emitter<T> {\n\n\tprivate _isPaused = 0;\n\tprotected _eventQueue = new LinkedList<T>();\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tpublic get isPaused(): boolean {\n\t\treturn this._isPaused !== 0;\n\t}\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\n\tpause(): void {\n\t\tthis._isPaused++;\n\t}\n\n\tresume(): void {\n\t\tif (this._isPaused !== 0 && --this._isPaused === 0) {\n\t\t\tif (this._mergeFn) {\n\t\t\t\t// use the merge function to create a single composite\n\t\t\t\t// event. make a copy in case firing pauses this emitter\n\t\t\t\tif (this._eventQueue.size > 0) {\n\t\t\t\t\tconst events = Array.from(this._eventQueue);\n\t\t\t\t\tthis._eventQueue.clear();\n\t\t\t\t\tsuper.fire(this._mergeFn(events));\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// no merging, fire each event individually and test\n\t\t\t\t// that this emitter isn't paused halfway through\n\t\t\t\twhile (!this._isPaused && this._eventQueue.size !== 0) {\n\t\t\t\t\tsuper.fire(this._eventQueue.shift()!);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (this._size) {\n\t\t\tif (this._isPaused !== 0) {\n\t\t\t\tthis._eventQueue.push(event);\n\t\t\t} else {\n\t\t\t\tsuper.fire(event);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class DebounceEmitter<T> extends PauseableEmitter<T> {\n\n\tprivate readonly _delay: number;\n\tprivate _handle: any | undefined;\n\n\tconstructor(options: EmitterOptions & { merge: (input: T[]) => T; delay?: number }) {\n\t\tsuper(options);\n\t\tthis._delay = options.delay ?? 100;\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (!this._handle) {\n\t\t\tthis.pause();\n\t\t\tthis._handle = setTimeout(() => {\n\t\t\t\tthis._handle = undefined;\n\t\t\t\tthis.resume();\n\t\t\t}, this._delay);\n\t\t}\n\t\tsuper.fire(event);\n\t}\n}\n\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter<T> extends Emitter<T> {\n\tprivate _queuedEvents: T[] = [];\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\toverride fire(event: T): void {\n\n\t\tif (!this.hasListeners()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._queuedEvents.push(event);\n\t\tif (this._queuedEvents.length === 1) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (this._mergeFn) {\n\t\t\t\t\tsuper.fire(this._mergeFn(this._queuedEvents));\n\t\t\t\t} else {\n\t\t\t\t\tthis._queuedEvents.forEach(e => super.fire(e));\n\t\t\t\t}\n\t\t\t\tthis._queuedEvents = [];\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => this.onFirstListenerAdd(),\n\t\t\tonDidRemoveLastListener: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(createSingleCallFunction(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener?.dispose();\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\n\t\tfor (const e of this.events) {\n\t\t\te.listener?.dispose();\n\t\t}\n\t\tthis.events = [];\n\t}\n}\n\nexport interface IDynamicListEventMultiplexer<TEventType> extends IDisposable {\n\treadonly event: Event<TEventType>;\n}\nexport class DynamicListEventMultiplexer<TItem, TEventType> implements IDynamicListEventMultiplexer<TEventType> {\n\tprivate readonly _store = new DisposableStore();\n\n\treadonly event: Event<TEventType>;\n\n\tconstructor(\n\t\titems: TItem[],\n\t\tonAddItem: Event<TItem>,\n\t\tonRemoveItem: Event<TItem>,\n\t\tgetEvent: (item: TItem) => Event<TEventType>\n\t) {\n\t\tconst multiplexer = this._store.add(new EventMultiplexer<TEventType>());\n\t\tconst itemListeners = this._store.add(new DisposableMap<TItem, IDisposable>());\n\n\t\tfunction addItem(instance: TItem) {\n\t\t\titemListeners.set(instance, multiplexer.add(getEvent(instance)));\n\t\t}\n\n\t\t// Existing items\n\t\tfor (const instance of items) {\n\t\t\taddItem(instance);\n\t\t}\n\n\t\t// Added items\n\t\tthis._store.add(onAddItem(instance => {\n\t\t\taddItem(instance);\n\t\t}));\n\n\t\t// Removed items\n\t\tthis._store.add(onRemoveItem(instance => {\n\t\t\titemListeners.deleteAndDispose(instance);\n\t\t}));\n\n\t\tthis.event = multiplexer.event;\n\t}\n\n\tdispose() {\n\t\tthis._store.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate data: { buffers: Function[] }[] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T>;\n\twrapEvent<T>(event: Event<T>, reduce: (last: T | undefined, event: T) => T): Event<T>;\n\twrapEvent<T, O>(event: Event<T>, reduce: (last: O | undefined, event: T) => O, initial: O): Event<O>;\n\twrapEvent<T, O>(event: Event<T>, reduce?: (last: T | O | undefined, event: T) => T | O, initial?: O): Event<O | T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst data = this.data[this.data.length - 1];\n\n\t\t\t\t// Non-reduce scenario\n\t\t\t\tif (!reduce) {\n\t\t\t\t\t// Buffering case\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\tdata.buffers.push(() => listener.call(thisArgs, i));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Not buffering case\n\t\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Reduce scenario\n\t\t\t\tconst reduceData = data as typeof data & {\n\t\t\t\t\t/**\n\t\t\t\t\t * The accumulated items that will be reduced.\n\t\t\t\t\t */\n\t\t\t\t\titems?: T[];\n\t\t\t\t\t/**\n\t\t\t\t\t * The reduced result cached to be shared with other listeners.\n\t\t\t\t\t */\n\t\t\t\t\treducedResult?: T | O;\n\t\t\t\t};\n\n\t\t\t\t// Not buffering case\n\t\t\t\tif (!reduceData) {\n\t\t\t\t\t// TODO: Is there a way to cache this reduce call for all listeners?\n\t\t\t\t\tlistener.call(thisArgs, reduce(initial, i));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Buffering case\n\t\t\t\treduceData.items ??= [];\n\t\t\t\treduceData.items.push(i);\n\t\t\t\tif (reduceData.buffers.length === 0) {\n\t\t\t\t\t// Include a single buffered function that will reduce all events when we're done buffering events\n\t\t\t\t\tdata.buffers.push(() => {\n\t\t\t\t\t\t// cache the reduced result so that the value can be shared across all listeners\n\t\t\t\t\t\treduceData.reducedResult ??= initial\n\t\t\t\t\t\t\t? reduceData.items!.reduce(reduce as (last: O | undefined, event: T) => O, initial)\n\t\t\t\t\t\t\t: reduceData.items!.reduce(reduce as (last: T | undefined, event: T) => T);\n\t\t\t\t\t\tlistener.call(thisArgs, reduceData.reducedResult);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst data = { buffers: new Array<Function>() };\n\t\tthis.data.push(data);\n\t\tconst r = fn();\n\t\tthis.data.pop();\n\t\tdata.buffers.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate readonly emitter = new Emitter<T>({\n\t\tonDidAddFirstListener: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonDidRemoveLastListener: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n\nexport interface IValueWithChangeEvent<T> {\n\treadonly onDidChange: Event<void>;\n\tget value(): T;\n}\n\nexport class ValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic static const<T>(value: T): IValueWithChangeEvent<T> {\n\t\treturn new ConstValueWithChangeEvent(value);\n\t}\n\n\tprivate readonly _onDidChange = new Emitter<void>();\n\treadonly onDidChange: Event<void> = this._onDidChange.event;\n\n\tconstructor(private _value: T) { }\n\n\tget value(): T {\n\t\treturn this._value;\n\t}\n\n\tset value(value: T) {\n\t\tif (value !== this._value) {\n\t\t\tthis._value = value;\n\t\t\tthis._onDidChange.fire(undefined);\n\t\t}\n\t}\n}\n\nclass ConstValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic readonly onDidChange: Event<void> = Event.None;\n\n\tconstructor(readonly value: T) { }\n}\n\n/**\n * @param handleItem Is called for each item in the set (but only the first time the item is seen in the set).\n * \tThe returned disposable is disposed if the item is no longer in the set.\n */\nexport function trackSetChanges<T>(getData: () => ReadonlySet<T>, onDidChangeData: Event<unknown>, handleItem: (d: T) => IDisposable): IDisposable {\n\tconst map = new DisposableMap<T, IDisposable>();\n\tlet oldData = new Set(getData());\n\tfor (const d of oldData) {\n\t\tmap.set(d, handleItem(d));\n\t}\n\n\tconst store = new DisposableStore();\n\tstore.add(onDidChangeData(() => {\n\t\tconst newData = getData();\n\t\tconst diff = diffSets(oldData, newData);\n\t\tfor (const r of diff.removed) {\n\t\t\tmap.deleteAndDispose(r);\n\t\t}\n\t\tfor (const a of diff.added) {\n\t\t\tmap.set(a, handleItem(a));\n\t\t}\n\t\toldData = new Set(newData);\n\t}));\n\tstore.add(map);\n\treturn store;\n}\n"],
  "mappings": "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",
  "names": ["Event", "map", "filter", "buffer", "id", "count", "stack", "data"]
}
