{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/async.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { BugIndicatingError, CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { Disposable, DisposableMap, DisposableStore, IDisposable, MutableDisposable, toDisposable } from './lifecycle.js';\nimport { extUri as defaultExtUri, IExtUri } from './resources.js';\nimport { URI } from './uri.js';\nimport { setTimeout0 } from './platform.js';\nimport { MicrotaskDelay } from './symbols.js';\nimport { Lazy } from './lazy.js';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t\tsource.dispose();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\ttry {\n\t\tconst result = await Promise.race(promises);\n\t\treturn result;\n\t} finally {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex) {\n\t\t\t\tcancellablePromise.cancel();\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\n/**\n * Creates and returns a new promise, plus its `resolve` and `reject` callbacks.\n *\n * Replace with standardized [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) once it is supported\n */\nexport function promiseWithResolvers<T>(): { promise: Promise<T>; resolve: (value: T | PromiseLike<T>) => void; reject: (err?: any) => void } {\n\tlet resolve: (value: T | PromiseLike<T>) => void;\n\tlet reject: (reason?: any) => void;\n\tconst promise = new Promise<T>((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn { promise, resolve: resolve!, reject: reject! };\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.deleteAndLeak(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n\n\tclear(): void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T> {\n\n\tprivate _size = 0;\n\tprivate _isDisposed = false;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t *\n\t * @returns A promise that resolved when all work is done (onDrained) or when\n\t * there is nothing to do\n\t */\n\twhenIdle(): Promise<void> {\n\t\treturn this.size > 0\n\t\t\t? Event.toPromise(this.onDrained)\n\t\t\t: Promise.resolve();\n\t}\n\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tthis.runningPromises--;\n\t\tif (--this._size === 0) {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis.outstandingPromises.length = 0;\n\t\tthis._size = this.runningPromises;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tthis.outstandingPromises.length = 0; // stop further processing\n\t\tthis._size = 0;\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nexport class LimitedQueue {\n\n\tprivate readonly sequentializer = new TaskSequentializer();\n\n\tprivate tasks = 0;\n\n\tqueue(factory: ITask<Promise<void>>): Promise<void> {\n\t\tif (!this.sequentializer.isRunning()) {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t}\n\n\t\treturn this.sequentializer.queue(() => {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t});\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tprivate drainListeners: DisposableMap<number> | undefined = undefined;\n\tprivate drainListenerCount = 0;\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueSize(resource: URI, extUri: IExtUri = defaultExtUri): number {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\treturn this.queues.get(key)?.size ?? 0;\n\t}\n\n\tqueueFor(resource: URI, factory: ITask<Promise<void>>, extUri: IExtUri = defaultExtUri): Promise<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tconst drainListenerId = this.drainListenerCount++;\n\t\t\tconst drainListener = Event.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\n\t\t\t\tthis.drainListeners?.deleteAndDispose(drainListenerId);\n\n\t\t\t\tif (this.drainListeners?.size === 0) {\n\t\t\t\t\tthis.drainListeners.dispose();\n\t\t\t\t\tthis.drainListeners = undefined;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!this.drainListeners) {\n\t\t\t\tthis.drainListeners = new DisposableMap();\n\t\t\t}\n\t\t\tthis.drainListeners.set(drainListenerId, drainListener);\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue.queue(factory);\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\n\t\tthis.drainListeners?.dispose();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\tprivate _isDisposed = false;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis._isDisposed = true;\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate disposable: IDisposable | undefined = undefined;\n\tprivate isDisposed = false;\n\n\tcancel(): void {\n\t\tthis.disposable?.dispose();\n\t\tthis.disposable = undefined;\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number, context = globalThis): void {\n\t\tif (this.isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tconst handle = context.setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\n\t\tthis.disposable = toDisposable(() => {\n\t\t\tcontext.clearInterval(handle);\n\t\t\tthis.disposable = undefined;\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\ntype IdleApi = Pick<typeof globalThis, 'requestIdleCallback' | 'cancelIdleCallback'>;\n\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\nexport let _runWhenIdle: (targetWindow: IdleApi, callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\n(function () {\n\tif (typeof globalThis.requestIdleCallback !== 'function' || typeof globalThis.cancelIdleCallback !== 'function') {\n\t\t_runWhenIdle = (_targetWindow, runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\tconst deadline: IdleDeadline = {\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunner(Object.freeze(deadline));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\t_runWhenIdle = (targetWindow: IdleApi, runner, timeout?) => {\n\t\t\tconst handle: number = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\ttargetWindow.cancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\trunWhenGlobalIdle = (runner) => _runWhenIdle(globalThis, runner);\n})();\n\nexport abstract class AbstractIdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(targetWindow: IdleApi, executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = _runWhenIdle(targetWindow, () => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue<T> extends AbstractIdleValue<T> {\n\n\tconstructor(executor: () => T) {\n\t\tsuper(globalThis, executor);\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IRunningTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface IQueuedTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: ITask<Promise<void>>;\n}\n\nexport interface ITaskSequentializerWithRunningTask {\n\treadonly running: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithQueuedTask {\n\treadonly queued: IQueuedTask;\n}\n\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nexport class TaskSequentializer {\n\n\tprivate _running?: IRunningTask;\n\tprivate _queued?: IQueuedTask;\n\n\tisRunning(taskId?: number): this is ITaskSequentializerWithRunningTask {\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._running?.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._running;\n\t}\n\n\tget running(): Promise<void> | undefined {\n\t\treturn this._running?.promise;\n\t}\n\n\tcancelRunning(): void {\n\t\tthis._running?.cancel();\n\t}\n\n\trun(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._running = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate doneRunning(taskId: number): void {\n\t\tif (this._running && taskId === this._running.taskId) {\n\n\t\t\t// only set running to done if the promise finished that is associated with that taskId\n\t\t\tthis._running = undefined;\n\n\t\t\t// schedule the queued task now that we are free if we have any\n\t\t\tthis.runQueued();\n\t\t}\n\t}\n\n\tprivate runQueued(): void {\n\t\tif (this._queued) {\n\t\t\tconst queued = this._queued;\n\t\t\tthis._queued = undefined;\n\n\t\t\t// Run queued task and complete on the associated promise\n\t\t\tqueued.run().then(queued.promiseResolve, queued.promiseReject);\n\t\t}\n\t}\n\n\t/**\n\t * Note: the promise to schedule as next run MUST itself call `run`.\n\t *       Otherwise, this sequentializer will report `false` for `isRunning`\n\t *       even when this task is running. Missing this detail means that\n\t *       suddenly multiple tasks will run in parallel.\n\t */\n\tqueue(run: ITask<Promise<void>>): Promise<void> {\n\n\t\t// this is our first queued task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._queued) {\n\t\t\tconst { promise, resolve: promiseResolve, reject: promiseReject } = promiseWithResolvers<void>();\n\t\t\tthis._queued = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous queued task, just overwrite it\n\t\telse {\n\t\t\tthis._queued.run = run;\n\t\t}\n\n\t\treturn this._queued.promise;\n\t}\n\n\thasQueued(): this is ITaskSequentializerWithQueuedTask {\n\t\treturn !!this._queued;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._queued?.promise ?? this._running?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: any } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class StatefulPromise<T> {\n\tprivate _value: T | undefined = undefined;\n\tget value(): T | undefined { return this._value; }\n\n\tprivate _error: unknown = undefined;\n\tget error(): unknown { return this._error; }\n\n\tprivate _isResolved = false;\n\tget isResolved() { return this._isResolved; }\n\n\tpublic readonly promise: Promise<T>;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(\n\t\t\tvalue => {\n\t\t\t\tthis._value = value;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\terror => {\n\t\t\t\tthis._error = error;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\tif (!this._isResolved) {\n\t\t\tthrow new BugIndicatingError('Promise is not resolved yet');\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\nexport class LazyStatefulPromise<T> {\n\tprivate readonly _promise = new Lazy(() => new StatefulPromise(this._compute()));\n\n\tconstructor(\n\t\tprivate readonly _compute: () => Promise<T>,\n\t) { }\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\treturn this._promise.value.requireValue();\n\t}\n\n\t/**\n\t * Returns the promise (and triggers a computation of the promise if not yet done so).\n\t */\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._promise.value.promise;\n\t}\n\n\t/**\n\t * Reads the current value without triggering a computation of the promise.\n\t */\n\tpublic get currentValue(): T | undefined {\n\t\treturn this._promise.rawValue?.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onReturn?: () => void | Promise<void>;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>, onReturn?: () => void | Promise<void>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onReturn = onReturn;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t},\n\t\t\treturn: async () => {\n\t\t\t\tthis._onReturn?.();\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\nexport class AsyncIterableSource<T> {\n\n\tprivate readonly _deferred = new DeferredPromise<void>();\n\tprivate readonly _asyncIterable: AsyncIterableObject<T>;\n\n\tprivate _errorFn: (error: Error) => void;\n\tprivate _emitFn: (item: T) => void;\n\n\t/**\n\t *\n\t * @param onReturn A function that will be called when consuming the async iterable\n\t * has finished by the consumer, e.g the for-await-loop has be existed (break, return) early.\n\t * This is NOT called when resolving this source by its owner.\n\t */\n\tconstructor(onReturn?: () => Promise<void> | void) {\n\t\tthis._asyncIterable = new AsyncIterableObject(emitter => {\n\n\t\t\tif (earlyError) {\n\t\t\t\temitter.reject(earlyError);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (earlyItems) {\n\t\t\t\temitter.emitMany(earlyItems);\n\t\t\t}\n\t\t\tthis._errorFn = (error: Error) => emitter.reject(error);\n\t\t\tthis._emitFn = (item: T) => emitter.emitOne(item);\n\t\t\treturn this._deferred.p;\n\t\t}, onReturn);\n\n\t\tlet earlyError: Error | undefined;\n\t\tlet earlyItems: T[] | undefined;\n\n\t\tthis._emitFn = (item: T) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = [];\n\t\t\t}\n\t\t\tearlyItems.push(item);\n\t\t};\n\t\tthis._errorFn = (error: Error) => {\n\t\t\tif (!earlyError) {\n\t\t\t\tearlyError = error;\n\t\t\t}\n\t\t};\n\t}\n\n\tget asyncIterable(): AsyncIterableObject<T> {\n\t\treturn this._asyncIterable;\n\t}\n\n\tresolve(): void {\n\t\tthis._deferred.complete();\n\t}\n\n\treject(error: Error): void {\n\t\tthis._errorFn(error);\n\t\tthis._deferred.complete();\n\t}\n\n\temitOne(item: T): void {\n\t\tthis._emitFn(item);\n\t}\n}\n\n//#endregion\n"],
  "mappings": "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",
  "names": ["timeout", "task", "token", "DeferredOutcome", "Promises", "AsyncIterableSourceState"]
}
