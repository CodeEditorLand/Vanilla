{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/types.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: unknown): str is string {\n\treturn (typeof str === 'string');\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: unknown): value is string[] {\n\treturn Array.isArray(value) && (<unknown[]>value).every(elem => isString(elem));\n}\n\n/**\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: unknown): obj is Object {\n\t// The method can't do a type cast since there are type (like strings) which\n\t// are subclasses of any put not positvely matched by the function. Hence type\n\t// narrowing results in wrong results.\n\treturn typeof obj === 'object'\n\t\t&& obj !== null\n\t\t&& !Array.isArray(obj)\n\t\t&& !(obj instanceof RegExp)\n\t\t&& !(obj instanceof Date);\n}\n\n/**\n * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type\n */\nexport function isTypedArray(obj: unknown): obj is Object {\n\tconst TypedArray = Object.getPrototypeOf(Uint8Array);\n\treturn typeof obj === 'object'\n\t\t&& obj instanceof TypedArray;\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: unknown): obj is number {\n\treturn (typeof obj === 'number' && !isNaN(obj));\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isIterable<T>(obj: unknown): obj is Iterable<T> {\n\treturn !!obj && typeof (obj as any)[Symbol.iterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: unknown): obj is boolean {\n\treturn (obj === true || obj === false);\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: unknown): obj is undefined {\n\treturn (typeof obj === 'undefined');\n}\n\n/**\n * @returns whether the provided parameter is defined.\n */\nexport function isDefined<T>(arg: T | null | undefined): arg is T {\n\treturn !isUndefinedOrNull(arg);\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: unknown): obj is undefined | null {\n\treturn (isUndefined(obj) || obj === null);\n}\n\n\nexport function assertType(condition: unknown, type?: string): asserts condition {\n\tif (!condition) {\n\t\tthrow new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');\n\t}\n}\n\n/**\n * Asserts that the argument passed in is neither undefined nor null.\n */\nexport function assertIsDefined<T>(arg: T | null | undefined): T {\n\tif (isUndefinedOrNull(arg)) {\n\t\tthrow new Error('Assertion Failed: argument is undefined or null');\n\t}\n\n\treturn arg;\n}\n\n/**\n * Asserts that each argument passed in is neither undefined nor null.\n */\nexport function assertAllDefined<T1, T2>(t1: T1 | null | undefined, t2: T2 | null | undefined): [T1, T2];\nexport function assertAllDefined<T1, T2, T3>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined): [T1, T2, T3];\nexport function assertAllDefined<T1, T2, T3, T4>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined, t4: T4 | null | undefined): [T1, T2, T3, T4];\nexport function assertAllDefined(...args: (unknown | null | undefined)[]): unknown[] {\n\tconst result = [];\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tconst arg = args[i];\n\n\t\tif (isUndefinedOrNull(arg)) {\n\t\t\tthrow new Error(`Assertion Failed: argument at index ${i} is undefined or null`);\n\t\t}\n\n\t\tresult.push(arg);\n\t}\n\n\treturn result;\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: unknown): obj is object {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (const key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: unknown): obj is Function {\n\treturn (typeof obj === 'function');\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: unknown[]): boolean {\n\treturn objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(args: unknown[], constraints: Array<TypeConstraint | undefined>): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(arg: unknown, constraint: TypeConstraint | undefined): void {\n\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(`argument does not match constraint: typeof ${constraint}`);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\ttry {\n\t\t\tif (arg instanceof constraint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// ignore\n\t\t}\n\t\tif (!isUndefinedOrNull(arg) && (arg as any).constructor === constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n\t}\n}\n\n/**\n * Helper type assertion that safely upcasts a type to a supertype.\n *\n * This can be used to make sure the argument correctly conforms to the subtype while still being able to pass it\n * to contexts that expects the supertype.\n */\nexport function upcast<Base, Sub extends Base>(x: Sub): Base {\n\treturn x;\n}\n\ntype AddFirstParameterToFunction<T, TargetFunctionsReturnType, FirstParameter> = T extends (...args: any[]) => TargetFunctionsReturnType ?\n\t// Function: add param to function\n\t(firstArg: FirstParameter, ...args: Parameters<T>) => ReturnType<T> :\n\n\t// Else: just leave as is\n\tT;\n\n/**\n * Allows to add a first parameter to functions of a type.\n */\nexport type AddFirstParameterToFunctions<Target, TargetFunctionsReturnType, FirstParameter> = {\n\t// For every property\n\t[K in keyof Target]: AddFirstParameterToFunction<Target[K], TargetFunctionsReturnType, FirstParameter>;\n};\n\n/**\n * Given an object with all optional properties, requires at least one to be defined.\n * i.e. AtLeastOne<MyObject>;\n */\nexport type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U];\n\n/**\n * Only picks the non-optional properties of a type.\n */\nexport type OmitOptional<T> = { [K in keyof T as T[K] extends Required<T>[K] ? K : never]: T[K] };\n\n/**\n * A type that removed readonly-less from all properties of `T`\n */\nexport type Mutable<T> = {\n\t-readonly [P in keyof T]: T[P]\n};\n\n/**\n * A single object or an array of the objects.\n */\nexport type SingleOrMany<T> = T | T[];\n\n\n/**\n * A type that recursively makes all properties of `T` required\n */\nexport type DeepRequiredNonNullable<T> = {\n\t[P in keyof T]-?: T[P] extends object ? DeepRequiredNonNullable<T[P]> : Required<NonNullable<T[P]>>;\n};\n\n\n/**\n * Represents a type that is a partial version of a given type `T`, where all properties are optional and can be deeply nested.\n */\nexport type DeepPartial<T> = {\n\t[P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : Partial<T[P]>;\n};\n\n/**\n * Represents a type that is a partial version of a given type `T`, except a subset.\n */\nexport type PartialExcept<T, K extends keyof T> = Partial<Omit<T, K>> & Pick<T, K>;\n"],
  "mappings": "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",
  "names": []
}
