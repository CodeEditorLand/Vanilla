{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/types.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: unknown): str is string {\n\treturn typeof str === \"string\";\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: unknown): value is string[] {\n\treturn (\n\t\tArray.isArray(value) &&\n\t\t(<unknown[]>value).every((elem) => isString(elem))\n\t);\n}\n\n/**\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: unknown): obj is Object {\n\t// The method can't do a type cast since there are type (like strings) which\n\t// are subclasses of any put not positvely matched by the function. Hence type\n\t// narrowing results in wrong results.\n\treturn (\n\t\ttypeof obj === \"object\" &&\n\t\tobj !== null &&\n\t\t!Array.isArray(obj) &&\n\t\t!(obj instanceof RegExp) &&\n\t\t!(obj instanceof Date)\n\t);\n}\n\n/**\n * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type\n */\nexport function isTypedArray(obj: unknown): obj is Object {\n\tconst TypedArray = Object.getPrototypeOf(Uint8Array);\n\treturn typeof obj === \"object\" && obj instanceof TypedArray;\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: unknown): obj is number {\n\treturn typeof obj === \"number\" && !isNaN(obj);\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isIterable<T>(obj: unknown): obj is Iterable<T> {\n\treturn !!obj && typeof (obj as any)[Symbol.iterator] === \"function\";\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: unknown): obj is boolean {\n\treturn obj === true || obj === false;\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: unknown): obj is undefined {\n\treturn typeof obj === \"undefined\";\n}\n\n/**\n * @returns whether the provided parameter is defined.\n */\nexport function isDefined<T>(arg: T | null | undefined): arg is T {\n\treturn !isUndefinedOrNull(arg);\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: unknown): obj is undefined | null {\n\treturn isUndefined(obj) || obj === null;\n}\n\nexport function assertType(\n\tcondition: unknown,\n\ttype?: string,\n): asserts condition {\n\tif (!condition) {\n\t\tthrow new Error(\n\t\t\ttype ? `Unexpected type, expected '${type}'` : \"Unexpected type\",\n\t\t);\n\t}\n}\n\n/**\n * Asserts that the argument passed in is neither undefined nor null.\n */\nexport function assertIsDefined<T>(arg: T | null | undefined): T {\n\tif (isUndefinedOrNull(arg)) {\n\t\tthrow new Error(\"Assertion Failed: argument is undefined or null\");\n\t}\n\n\treturn arg;\n}\n\n/**\n * Asserts that each argument passed in is neither undefined nor null.\n */\nexport function assertAllDefined<T1, T2>(\n\tt1: T1 | null | undefined,\n\tt2: T2 | null | undefined,\n): [T1, T2];\nexport function assertAllDefined<T1, T2, T3>(\n\tt1: T1 | null | undefined,\n\tt2: T2 | null | undefined,\n\tt3: T3 | null | undefined,\n): [T1, T2, T3];\nexport function assertAllDefined<T1, T2, T3, T4>(\n\tt1: T1 | null | undefined,\n\tt2: T2 | null | undefined,\n\tt3: T3 | null | undefined,\n\tt4: T4 | null | undefined,\n): [T1, T2, T3, T4];\nexport function assertAllDefined(\n\t...args: (unknown | null | undefined)[]\n): unknown[] {\n\tconst result = [];\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tconst arg = args[i];\n\n\t\tif (isUndefinedOrNull(arg)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Assertion Failed: argument at index ${i} is undefined or null`,\n\t\t\t);\n\t\t}\n\n\t\tresult.push(arg);\n\t}\n\n\treturn result;\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: unknown): obj is object {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (const key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: unknown): obj is Function {\n\treturn typeof obj === \"function\";\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: unknown[]): boolean {\n\treturn objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(\n\targs: unknown[],\n\tconstraints: Array<TypeConstraint | undefined>,\n): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(\n\targ: unknown,\n\tconstraint: TypeConstraint | undefined,\n): void {\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(\n\t\t\t\t`argument does not match constraint: typeof ${constraint}`,\n\t\t\t);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\ttry {\n\t\t\tif (arg instanceof constraint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// ignore\n\t\t}\n\t\tif (\n\t\t\t!isUndefinedOrNull(arg) &&\n\t\t\t(arg as any).constructor === constraint\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\tif (\n\t\t\tconstraint.length === 1 &&\n\t\t\tconstraint.call(undefined, arg) === true\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(\n\t\t\t`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`,\n\t\t);\n\t}\n}\n\n/**\n * Helper type assertion that safely upcasts a type to a supertype.\n *\n * This can be used to make sure the argument correctly conforms to the subtype while still being able to pass it\n * to contexts that expects the supertype.\n */\nexport function upcast<Base, Sub extends Base>(x: Sub): Base {\n\treturn x;\n}\n\ntype AddFirstParameterToFunction<T, TargetFunctionsReturnType, FirstParameter> =\n\tT extends (...args: any[]) => TargetFunctionsReturnType\n\t\t? // Function: add param to function\n\t\t\t(firstArg: FirstParameter, ...args: Parameters<T>) => ReturnType<T>\n\t\t: // Else: just leave as is\n\t\t\tT;\n\n/**\n * Allows to add a first parameter to functions of a type.\n */\nexport type AddFirstParameterToFunctions<\n\tTarget,\n\tTargetFunctionsReturnType,\n\tFirstParameter,\n> = {\n\t// For every property\n\t[K in keyof Target]: AddFirstParameterToFunction<\n\t\tTarget[K],\n\t\tTargetFunctionsReturnType,\n\t\tFirstParameter\n\t>;\n};\n\n/**\n * Given an object with all optional properties, requires at least one to be defined.\n * i.e. AtLeastOne<MyObject>;\n */\nexport type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &\n\tU[keyof U];\n\n/**\n * Only picks the non-optional properties of a type.\n */\nexport type OmitOptional<T> = {\n\t[K in keyof T as T[K] extends Required<T>[K] ? K : never]: T[K];\n};\n\n/**\n * A type that removed readonly-less from all properties of `T`\n */\nexport type Mutable<T> = {\n\t-readonly [P in keyof T]: T[P];\n};\n\n/**\n * A single object or an array of the objects.\n */\nexport type SingleOrMany<T> = T | T[];\n\n/**\n * A type that recursively makes all properties of `T` required\n */\nexport type DeepRequiredNonNullable<T> = {\n\t[P in keyof T]-?: T[P] extends object\n\t\t? DeepRequiredNonNullable<T[P]>\n\t\t: Required<NonNullable<T[P]>>;\n};\n\n/**\n * Represents a type that is a partial version of a given type `T`, where all properties are optional and can be deeply nested.\n */\nexport type DeepPartial<T> = {\n\t[P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : Partial<T[P]>;\n};\n\n/**\n * Represents a type that is a partial version of a given type `T`, except a subset.\n */\nexport type PartialExcept<T, K extends keyof T> = Partial<Omit<T, K>> &\n\tPick<T, K>;\n"],
  "mappings": "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",
  "names": []
}
