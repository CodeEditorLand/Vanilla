class t{static Undefined=new t(void 0);element;next;prev;constructor(e){this.element=e,this.next=t.Undefined,this.prev=t.Undefined}}class f{_first=t.Undefined;_last=t.Undefined;_size=0;get size(){return this._size}isEmpty(){return this._first===t.Undefined}clear(){let e=this._first;for(;e!==t.Undefined;){const n=e.next;e.prev=t.Undefined,e.next=t.Undefined,e=n}this._first=t.Undefined,this._last=t.Undefined,this._size=0}unshift(e){return this._insert(e,!1)}push(e){return this._insert(e,!0)}_insert(e,n){const i=new t(e);if(this._first===t.Undefined)this._first=i,this._last=i;else if(n){const s=this._last;this._last=i,i.prev=s,s.next=i}else{const s=this._first;this._first=i,i.next=s,s.prev=i}this._size+=1;let r=!1;return()=>{r||(r=!0,this._remove(i))}}shift(){if(this._first!==t.Undefined){const e=this._first.element;return this._remove(this._first),e}}pop(){if(this._last!==t.Undefined){const e=this._last.element;return this._remove(this._last),e}}_remove(e){if(e.prev!==t.Undefined&&e.next!==t.Undefined){const n=e.prev;n.next=e.next,e.next.prev=n}else e.prev===t.Undefined&&e.next===t.Undefined?(this._first=t.Undefined,this._last=t.Undefined):e.next===t.Undefined?(this._last=this._last.prev,this._last.next=t.Undefined):e.prev===t.Undefined&&(this._first=this._first.next,this._first.prev=t.Undefined);this._size-=1}*[Symbol.iterator](){let e=this._first;for(;e!==t.Undefined;)yield e.element,e=e.next}}export{f as LinkedList};
