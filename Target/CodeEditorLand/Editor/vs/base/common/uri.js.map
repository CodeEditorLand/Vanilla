{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/uri.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"./charCode.js\";\nimport { MarshalledId } from \"./marshallingIds.js\";\nimport * as paths from \"./path.js\";\nimport { isWindows } from \"./platform.js\";\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\t// scheme, must be set\n\tif (!ret.scheme && _strict) {\n\t\tthrow new Error(\n\t\t\t`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`,\n\t\t);\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error(\"[UriError]: Scheme contains illegal characters.\");\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character',\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (_doubleSlashStart.test(ret.path)) {\n\t\t\tthrow new Error(\n\t\t\t\t'[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")',\n\t\t\t);\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (!scheme && !_strict) {\n\t\treturn \"file\";\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase \"https\":\n\t\tcase \"http\":\n\t\tcase \"file\":\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = \"\";\nconst _slash = \"/\";\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI implements UriComponents {\n\tstatic isUri(thing: any): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (\n\t\t\ttypeof (<URI>thing).authority === \"string\" &&\n\t\t\ttypeof (<URI>thing).fragment === \"string\" &&\n\t\t\ttypeof (<URI>thing).path === \"string\" &&\n\t\t\ttypeof (<URI>thing).query === \"string\" &&\n\t\t\ttypeof (<URI>thing).scheme === \"string\" &&\n\t\t\ttypeof (<URI>thing).fsPath === \"string\" &&\n\t\t\ttypeof (<URI>thing).with === \"function\" &&\n\t\t\ttypeof (<URI>thing).toString === \"function\"\n\t\t);\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(\n\t\tscheme: string,\n\t\tauthority?: string,\n\t\tpath?: string,\n\t\tquery?: string,\n\t\tfragment?: string,\n\t\t_strict?: boolean,\n\t);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(\n\t\tschemeOrData: string | UriComponents,\n\t\tauthority?: string,\n\t\tpath?: string,\n\t\tquery?: string,\n\t\tfragment?: string,\n\t\t_strict = false,\n\t) {\n\t\tif (typeof schemeOrData === \"object\") {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn uriToFsPath(this, false);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\twith(change: {\n\t\tscheme?: string;\n\t\tauthority?: string | null;\n\t\tpath?: string | null;\n\t\tquery?: string | null;\n\t\tfragment?: string | null;\n\t}): URI {\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (\n\t\t\tscheme === this.scheme &&\n\t\t\tauthority === this.authority &&\n\t\t\tpath === this.path &&\n\t\t\tquery === this.query &&\n\t\t\tfragment === this.fragment\n\t\t) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new Uri(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tstatic parse(value: string, _strict = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new Uri(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new Uri(\n\t\t\tmatch[2] || _empty,\n\t\t\tpercentDecode(match[4] || _empty),\n\t\t\tpercentDecode(match[5] || _empty),\n\t\t\tpercentDecode(match[7] || _empty),\n\t\t\tpercentDecode(match[9] || _empty),\n\t\t\t_strict,\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tstatic file(path: string): URI {\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new Uri(\"file\", authority, path, _empty, _empty);\n\t}\n\n\t/**\n\t * Creates new URI from uri components.\n\t *\n\t * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs\n\t * validation and should be used for untrusted uri components retrieved from storage,\n\t * user input, command arguments etc\n\t */\n\tstatic from(components: UriComponents, strict?: boolean): URI {\n\t\tconst result = new Uri(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t\tstrict,\n\t\t);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param uri The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tstatic joinPath(uri: URI, ...pathFragment: string[]): URI {\n\t\tif (!uri.path) {\n\t\t\tthrow new Error(\n\t\t\t\t`[UriError]: cannot call joinPath on URI without path`,\n\t\t\t);\n\t\t}\n\t\tlet newPath: string;\n\t\tif (isWindows && uri.scheme === \"file\") {\n\t\t\tnewPath = URI.file(\n\t\t\t\tpaths.win32.join(uriToFsPath(uri, true), ...pathFragment),\n\t\t\t).path;\n\t\t} else {\n\t\t\tnewPath = paths.posix.join(uri.path, ...pathFragment);\n\t\t}\n\t\treturn uri.with({ path: newPath });\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\ttoString(skipEncoding = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\ttoJSON(): UriComponents {\n\t\treturn this;\n\t}\n\n\t/**\n\t * A helper function to revive URIs.\n\t *\n\t * **Note** that this function should only be used when receiving URI#toJSON generated data\n\t * and that it doesn't do any validation. Use {@link URI.from} when received \"untrusted\"\n\t * uri components such as command arguments or data from storage.\n\t *\n\t * @param data The URI components or URI to revive.\n\t * @returns The revived URI or undefined or null.\n\t */\n\tstatic revive(data: UriComponents | URI): URI;\n\tstatic revive(data: UriComponents | URI | undefined): URI | undefined;\n\tstatic revive(data: UriComponents | URI | null): URI | null;\n\tstatic revive(\n\t\tdata: UriComponents | URI | undefined | null,\n\t): URI | undefined | null;\n\tstatic revive(\n\t\tdata: UriComponents | URI | undefined | null,\n\t): URI | undefined | null {\n\t\tif (!data) {\n\t\t\treturn data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new Uri(data);\n\t\t\tresult._formatted = (<UriState>data).external ?? null;\n\t\t\tresult._fsPath =\n\t\t\t\t(<UriState>data)._sep === _pathSepMarker\n\t\t\t\t\t? ((<UriState>data).fsPath ?? null)\n\t\t\t\t\t: null;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t[Symbol.for(\"debug.description\")]() {\n\t\treturn `URI(${this.toString()})`;\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority?: string;\n\tpath?: string;\n\tquery?: string;\n\tfragment?: string;\n}\n\nexport function isUriComponents(thing: any): thing is UriComponents {\n\tif (!thing || typeof thing !== \"object\") {\n\t\treturn false;\n\t}\n\treturn (\n\t\ttypeof (<UriComponents>thing).scheme === \"string\" &&\n\t\t(typeof (<UriComponents>thing).authority === \"string\" ||\n\t\t\ttypeof (<UriComponents>thing).authority === \"undefined\") &&\n\t\t(typeof (<UriComponents>thing).path === \"string\" ||\n\t\t\ttypeof (<UriComponents>thing).path === \"undefined\") &&\n\t\t(typeof (<UriComponents>thing).query === \"string\" ||\n\t\t\ttypeof (<UriComponents>thing).query === \"undefined\") &&\n\t\t(typeof (<UriComponents>thing).fragment === \"string\" ||\n\t\t\ttypeof (<UriComponents>thing).fragment === \"undefined\")\n\t);\n}\n\ninterface UriState extends UriComponents {\n\t$mid: MarshalledId.Uri;\n\texternal?: string;\n\tfsPath?: string;\n\t_sep?: 1;\n}\n\nconst _pathSepMarker = isWindows ? 1 : undefined;\n\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends URI {\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\toverride get fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = uriToFsPath(this, false);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\toverride toString(skipEncoding = false): string {\n\t\tif (skipEncoding) {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t} else {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t}\n\t}\n\n\toverride toJSON(): UriComponents {\n\t\tconst res = <UriState>{\n\t\t\t$mid: MarshalledId.Uri,\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t\tres._sep = _pathSepMarker;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t//--- uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\t// TODO\n\t\t// this isn't correct and can violate the UriComponents contract but\n\t\t// this is part of the vscode.Uri API and we shouldn't change how that\n\t\t// works anymore\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: \"%3A\", // gen-delims\n\t[CharCode.Slash]: \"%2F\",\n\t[CharCode.QuestionMark]: \"%3F\",\n\t[CharCode.Hash]: \"%23\",\n\t[CharCode.OpenSquareBracket]: \"%5B\",\n\t[CharCode.CloseSquareBracket]: \"%5D\",\n\t[CharCode.AtSign]: \"%40\",\n\n\t[CharCode.ExclamationMark]: \"%21\", // sub-delims\n\t[CharCode.DollarSign]: \"%24\",\n\t[CharCode.Ampersand]: \"%26\",\n\t[CharCode.SingleQuote]: \"%27\",\n\t[CharCode.OpenParen]: \"%28\",\n\t[CharCode.CloseParen]: \"%29\",\n\t[CharCode.Asterisk]: \"%2A\",\n\t[CharCode.Plus]: \"%2B\",\n\t[CharCode.Comma]: \"%2C\",\n\t[CharCode.Semicolon]: \"%3B\",\n\t[CharCode.Equals]: \"%3D\",\n\n\t[CharCode.Space]: \"%20\",\n};\n\nfunction encodeURIComponentFast(\n\turiComponent: string,\n\tisPath: boolean,\n\tisAuthority: boolean,\n): string {\n\tlet res: string | undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z) ||\n\t\t\t(code >= CharCode.A && code <= CharCode.Z) ||\n\t\t\t(code >= CharCode.Digit0 && code <= CharCode.Digit9) ||\n\t\t\tcode === CharCode.Dash ||\n\t\t\tcode === CharCode.Period ||\n\t\t\tcode === CharCode.Underline ||\n\t\t\tcode === CharCode.Tilde ||\n\t\t\t(isPath && code === CharCode.Slash) ||\n\t\t\t(isAuthority && code === CharCode.OpenSquareBracket) ||\n\t\t\t(isAuthority && code === CharCode.CloseSquareBracket) ||\n\t\t\t(isAuthority && code === CharCode.Colon)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(\n\t\t\t\t\turiComponent.substring(nativeEncodePos, pos),\n\t\t\t\t);\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(\n\t\t\t\t\t\turiComponent.substring(nativeEncodePos, pos),\n\t\t\t\t\t);\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else if (res !== undefined) {\n\t\t\tres += path[pos];\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: URI, keepDriveLetterCasing: boolean): string {\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === \"file\") {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash &&\n\t\t((uri.path.charCodeAt(1) >= CharCode.A &&\n\t\t\turi.path.charCodeAt(1) <= CharCode.Z) ||\n\t\t\t(uri.path.charCodeAt(1) >= CharCode.a &&\n\t\t\t\turi.path.charCodeAt(1) <= CharCode.z)) &&\n\t\turi.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tif (keepDriveLetterCasing) {\n\t\t\tvalue = uri.path.substr(1);\n\t\t} else {\n\t\t\t// windows drive letter: file:///c:/far/boo\n\t\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t\t}\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, \"\\\\\");\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\tconst encoder = skipEncoding\n\t\t? encodeURIComponentMinimal\n\t\t: encodeURIComponentFast;\n\n\tlet res = \"\";\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += \":\";\n\t}\n\tif (authority || scheme === \"file\") {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf(\"@\");\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.lastIndexOf(\":\");\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false, false);\n\t\t\t\tres += \":\";\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false, true);\n\t\t\t}\n\t\t\tres += \"@\";\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.lastIndexOf(\":\");\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false, true);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false, true);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (\n\t\t\tpath.length >= 3 &&\n\t\t\tpath.charCodeAt(0) === CharCode.Slash &&\n\t\t\tpath.charCodeAt(2) === CharCode.Colon\n\t\t) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true, false);\n\t}\n\tif (query) {\n\t\tres += \"?\";\n\t\tres += encoder(query, false, false);\n\t}\n\tif (fragment) {\n\t\tres += \"#\";\n\t\tres += skipEncoding\n\t\t\t? fragment\n\t\t\t: encodeURIComponentFast(fragment, false, false);\n\t}\n\treturn res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n\ttry {\n\t\treturn decodeURIComponent(str);\n\t} catch {\n\t\tif (str.length > 3) {\n\t\t\treturn str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n\tif (!str.match(_rEncodedAsHex)) {\n\t\treturn str;\n\t}\n\treturn str.replace(_rEncodedAsHex, (match) =>\n\t\tdecodeURIComponentGraceful(match),\n\t);\n}\n\n/**\n * Mapped-type that replaces all occurrences of URI with UriComponents\n */\nexport type UriDto<T> = {\n\t[K in keyof T]: T[K] extends URI ? UriComponents : UriDto<T[K]>;\n};\n"],
  "mappings": ";;AAKA,SAAS,gBAAgB;AACzB,SAAS,oBAAoB;AAC7B,YAAY,WAAW;AACvB,SAAS,iBAAiB;AAE1B,MAAM,iBAAiB;AACvB,MAAM,oBAAoB;AAC1B,MAAM,oBAAoB;AAE1B,SAAS,aAAa,KAAU,SAAyB;AAExD,MAAI,CAAC,IAAI,UAAU,SAAS;AAC3B,UAAM,IAAI;AAAA,MACT,2DAA2D,IAAI,SAAS,aAAa,IAAI,IAAI,cAAc,IAAI,KAAK,iBAAiB,IAAI,QAAQ;AAAA,IAClJ;AAAA,EACD;AAIA,MAAI,IAAI,UAAU,CAAC,eAAe,KAAK,IAAI,MAAM,GAAG;AACnD,UAAM,IAAI,MAAM,iDAAiD;AAAA,EAClE;AAOA,MAAI,IAAI,MAAM;AACb,QAAI,IAAI,WAAW;AAClB,UAAI,CAAC,kBAAkB,KAAK,IAAI,IAAI,GAAG;AACtC,cAAM,IAAI;AAAA,UACT;AAAA,QACD;AAAA,MACD;AAAA,IACD,WAAW,kBAAkB,KAAK,IAAI,IAAI,GAAG;AAC5C,YAAM,IAAI;AAAA,QACT;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;AAhCS;AAsCT,SAAS,WAAW,QAAgB,SAA0B;AAC7D,MAAI,CAAC,UAAU,CAAC,SAAS;AACxB,WAAO;AAAA,EACR;AACA,SAAO;AACR;AALS;AAQT,SAAS,qBAAqB,QAAgB,MAAsB;AAKnE,UAAQ,QAAQ;AAAA,IACf,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACJ,UAAI,CAAC,MAAM;AACV,eAAO;AAAA,MACR,WAAW,KAAK,CAAC,MAAM,QAAQ;AAC9B,eAAO,SAAS;AAAA,MACjB;AACA;AAAA,EACF;AACA,SAAO;AACR;AAjBS;AAmBT,MAAM,SAAS;AACf,MAAM,SAAS;AACf,MAAM,UAAU;AAkBT,MAAM,IAA6B;AAAA,EAnG1C,OAmG0C;AAAA;AAAA;AAAA,EACzC,OAAO,MAAM,OAA0B;AACtC,QAAI,iBAAiB,KAAK;AACzB,aAAO;AAAA,IACR;AACA,QAAI,CAAC,OAAO;AACX,aAAO;AAAA,IACR;AACA,WACC,OAAa,MAAO,cAAc,YAClC,OAAa,MAAO,aAAa,YACjC,OAAa,MAAO,SAAS,YAC7B,OAAa,MAAO,UAAU,YAC9B,OAAa,MAAO,WAAW,YAC/B,OAAa,MAAO,WAAW,YAC/B,OAAa,MAAO,SAAS,cAC7B,OAAa,MAAO,aAAa;AAAA,EAEnC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMS;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAsBC,YACT,cACA,WACA,MACA,OACA,UACA,UAAU,OACT;AACD,QAAI,OAAO,iBAAiB,UAAU;AACrC,WAAK,SAAS,aAAa,UAAU;AACrC,WAAK,YAAY,aAAa,aAAa;AAC3C,WAAK,OAAO,aAAa,QAAQ;AACjC,WAAK,QAAQ,aAAa,SAAS;AACnC,WAAK,WAAW,aAAa,YAAY;AAAA,IAI1C,OAAO;AACN,WAAK,SAAS,WAAW,cAAc,OAAO;AAC9C,WAAK,YAAY,aAAa;AAC9B,WAAK,OAAO,qBAAqB,KAAK,QAAQ,QAAQ,MAAM;AAC5D,WAAK,QAAQ,SAAS;AACtB,WAAK,WAAW,YAAY;AAE5B,mBAAa,MAAM,OAAO;AAAA,IAC3B;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4BA,IAAI,SAAiB;AAIpB,WAAO,YAAY,MAAM,KAAK;AAAA,EAC/B;AAAA;AAAA,EAIA,KAAK,QAMG;AACP,QAAI,CAAC,QAAQ;AACZ,aAAO;AAAA,IACR;AAEA,QAAI,EAAE,QAAQ,WAAW,MAAM,OAAO,SAAS,IAAI;AACnD,QAAI,WAAW,QAAW;AACzB,eAAS,KAAK;AAAA,IACf,WAAW,WAAW,MAAM;AAC3B,eAAS;AAAA,IACV;AACA,QAAI,cAAc,QAAW;AAC5B,kBAAY,KAAK;AAAA,IAClB,WAAW,cAAc,MAAM;AAC9B,kBAAY;AAAA,IACb;AACA,QAAI,SAAS,QAAW;AACvB,aAAO,KAAK;AAAA,IACb,WAAW,SAAS,MAAM;AACzB,aAAO;AAAA,IACR;AACA,QAAI,UAAU,QAAW;AACxB,cAAQ,KAAK;AAAA,IACd,WAAW,UAAU,MAAM;AAC1B,cAAQ;AAAA,IACT;AACA,QAAI,aAAa,QAAW;AAC3B,iBAAW,KAAK;AAAA,IACjB,WAAW,aAAa,MAAM;AAC7B,iBAAW;AAAA,IACZ;AAEA,QACC,WAAW,KAAK,UAChB,cAAc,KAAK,aACnB,SAAS,KAAK,QACd,UAAU,KAAK,SACf,aAAa,KAAK,UACjB;AACD,aAAO;AAAA,IACR;AAEA,WAAO,IAAI,IAAI,QAAQ,WAAW,MAAM,OAAO,QAAQ;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,OAAO,MAAM,OAAe,UAAU,OAAY;AACjD,UAAM,QAAQ,QAAQ,KAAK,KAAK;AAChC,QAAI,CAAC,OAAO;AACX,aAAO,IAAI,IAAI,QAAQ,QAAQ,QAAQ,QAAQ,MAAM;AAAA,IACtD;AACA,WAAO,IAAI;AAAA,MACV,MAAM,CAAC,KAAK;AAAA,MACZ,cAAc,MAAM,CAAC,KAAK,MAAM;AAAA,MAChC,cAAc,MAAM,CAAC,KAAK,MAAM;AAAA,MAChC,cAAc,MAAM,CAAC,KAAK,MAAM;AAAA,MAChC,cAAc,MAAM,CAAC,KAAK,MAAM;AAAA,MAChC;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBA,OAAO,KAAK,MAAmB;AAC9B,QAAI,YAAY;AAKhB,QAAI,WAAW;AACd,aAAO,KAAK,QAAQ,OAAO,MAAM;AAAA,IAClC;AAIA,QAAI,KAAK,CAAC,MAAM,UAAU,KAAK,CAAC,MAAM,QAAQ;AAC7C,YAAM,MAAM,KAAK,QAAQ,QAAQ,CAAC;AAClC,UAAI,QAAQ,IAAI;AACf,oBAAY,KAAK,UAAU,CAAC;AAC5B,eAAO;AAAA,MACR,OAAO;AACN,oBAAY,KAAK,UAAU,GAAG,GAAG;AACjC,eAAO,KAAK,UAAU,GAAG,KAAK;AAAA,MAC/B;AAAA,IACD;AAEA,WAAO,IAAI,IAAI,QAAQ,WAAW,MAAM,QAAQ,MAAM;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,KAAK,YAA2B,QAAuB;AAC7D,UAAM,SAAS,IAAI;AAAA,MAClB,WAAW;AAAA,MACX,WAAW;AAAA,MACX,WAAW;AAAA,MACX,WAAW;AAAA,MACX,WAAW;AAAA,MACX;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,SAAS,QAAa,cAA6B;AACzD,QAAI,CAAC,IAAI,MAAM;AACd,YAAM,IAAI;AAAA,QACT;AAAA,MACD;AAAA,IACD;AACA,QAAI;AACJ,QAAI,aAAa,IAAI,WAAW,QAAQ;AACvC,gBAAU,IAAI;AAAA,QACb,MAAM,MAAM,KAAK,YAAY,KAAK,IAAI,GAAG,GAAG,YAAY;AAAA,MACzD,EAAE;AAAA,IACH,OAAO;AACN,gBAAU,MAAM,MAAM,KAAK,IAAI,MAAM,GAAG,YAAY;AAAA,IACrD;AACA,WAAO,IAAI,KAAK,EAAE,MAAM,QAAQ,CAAC;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,SAAS,eAAe,OAAe;AACtC,WAAO,aAAa,MAAM,YAAY;AAAA,EACvC;AAAA,EAEA,SAAwB;AACvB,WAAO;AAAA,EACR;AAAA,EAkBA,OAAO,OACN,MACyB;AACzB,QAAI,CAAC,MAAM;AACV,aAAO;AAAA,IACR,WAAW,gBAAgB,KAAK;AAC/B,aAAO;AAAA,IACR,OAAO;AACN,YAAM,SAAS,IAAI,IAAI,IAAI;AAC3B,aAAO,aAAwB,KAAM,YAAY;AACjD,aAAO,UACK,KAAM,SAAS,iBACX,KAAM,UAAU,OAC5B;AACJ,aAAO;AAAA,IACR;AAAA,EACD;AAAA,EAEA,CAAC,OAAO,IAAI,mBAAmB,CAAC,IAAI;AACnC,WAAO,OAAO,KAAK,SAAS,CAAC;AAAA,EAC9B;AACD;AAUO,SAAS,gBAAgB,OAAoC;AACnE,MAAI,CAAC,SAAS,OAAO,UAAU,UAAU;AACxC,WAAO;AAAA,EACR;AACA,SACC,OAAuB,MAAO,WAAW,aACxC,OAAuB,MAAO,cAAc,YAC5C,OAAuB,MAAO,cAAc,iBAC5C,OAAuB,MAAO,SAAS,YACvC,OAAuB,MAAO,SAAS,iBACvC,OAAuB,MAAO,UAAU,YACxC,OAAuB,MAAO,UAAU,iBACxC,OAAuB,MAAO,aAAa,YAC3C,OAAuB,MAAO,aAAa;AAE9C;AAfgB;AAwBhB,MAAM,iBAAiB,YAAY,IAAI;AAGvC,MAAM,YAAY,IAAI;AAAA,EAxetB,OAwesB;AAAA;AAAA;AAAA,EACrB,aAA4B;AAAA,EAC5B,UAAyB;AAAA,EAEzB,IAAa,SAAiB;AAC7B,QAAI,CAAC,KAAK,SAAS;AAClB,WAAK,UAAU,YAAY,MAAM,KAAK;AAAA,IACvC;AACA,WAAO,KAAK;AAAA,EACb;AAAA,EAES,SAAS,eAAe,OAAe;AAC/C,QAAI,cAAc;AAEjB,aAAO,aAAa,MAAM,IAAI;AAAA,IAC/B,OAAO;AACN,UAAI,CAAC,KAAK,YAAY;AACrB,aAAK,aAAa,aAAa,MAAM,KAAK;AAAA,MAC3C;AACA,aAAO,KAAK;AAAA,IACb;AAAA,EACD;AAAA,EAES,SAAwB;AAChC,UAAM,MAAgB;AAAA,MACrB,MAAM,aAAa;AAAA,IACpB;AAEA,QAAI,KAAK,SAAS;AACjB,UAAI,SAAS,KAAK;AAClB,UAAI,OAAO;AAAA,IACZ;AACA,QAAI,KAAK,YAAY;AACpB,UAAI,WAAW,KAAK;AAAA,IACrB;AAEA,QAAI,KAAK,MAAM;AACd,UAAI,OAAO,KAAK;AAAA,IACjB;AAKA,QAAI,KAAK,QAAQ;AAChB,UAAI,SAAS,KAAK;AAAA,IACnB;AACA,QAAI,KAAK,WAAW;AACnB,UAAI,YAAY,KAAK;AAAA,IACtB;AACA,QAAI,KAAK,OAAO;AACf,UAAI,QAAQ,KAAK;AAAA,IAClB;AACA,QAAI,KAAK,UAAU;AAClB,UAAI,WAAW,KAAK;AAAA,IACrB;AACA,WAAO;AAAA,EACR;AACD;AAGA,MAAM,cAAwC;AAAA,EAC7C,CAAC,SAAS,KAAK,GAAG;AAAA;AAAA,EAClB,CAAC,SAAS,KAAK,GAAG;AAAA,EAClB,CAAC,SAAS,YAAY,GAAG;AAAA,EACzB,CAAC,SAAS,IAAI,GAAG;AAAA,EACjB,CAAC,SAAS,iBAAiB,GAAG;AAAA,EAC9B,CAAC,SAAS,kBAAkB,GAAG;AAAA,EAC/B,CAAC,SAAS,MAAM,GAAG;AAAA,EAEnB,CAAC,SAAS,eAAe,GAAG;AAAA;AAAA,EAC5B,CAAC,SAAS,UAAU,GAAG;AAAA,EACvB,CAAC,SAAS,SAAS,GAAG;AAAA,EACtB,CAAC,SAAS,WAAW,GAAG;AAAA,EACxB,CAAC,SAAS,SAAS,GAAG;AAAA,EACtB,CAAC,SAAS,UAAU,GAAG;AAAA,EACvB,CAAC,SAAS,QAAQ,GAAG;AAAA,EACrB,CAAC,SAAS,IAAI,GAAG;AAAA,EACjB,CAAC,SAAS,KAAK,GAAG;AAAA,EAClB,CAAC,SAAS,SAAS,GAAG;AAAA,EACtB,CAAC,SAAS,MAAM,GAAG;AAAA,EAEnB,CAAC,SAAS,KAAK,GAAG;AACnB;AAEA,SAAS,uBACR,cACA,QACA,aACS;AACT,MAAI;AACJ,MAAI,kBAAkB;AAEtB,WAAS,MAAM,GAAG,MAAM,aAAa,QAAQ,OAAO;AACnD,UAAM,OAAO,aAAa,WAAW,GAAG;AAGxC,QACE,QAAQ,SAAS,KAAK,QAAQ,SAAS,KACvC,QAAQ,SAAS,KAAK,QAAQ,SAAS,KACvC,QAAQ,SAAS,UAAU,QAAQ,SAAS,UAC7C,SAAS,SAAS,QAClB,SAAS,SAAS,UAClB,SAAS,SAAS,aAClB,SAAS,SAAS,SACjB,UAAU,SAAS,SAAS,SAC5B,eAAe,SAAS,SAAS,qBACjC,eAAe,SAAS,SAAS,sBACjC,eAAe,SAAS,SAAS,OACjC;AAED,UAAI,oBAAoB,IAAI;AAC3B,eAAO;AAAA,UACN,aAAa,UAAU,iBAAiB,GAAG;AAAA,QAC5C;AACA,0BAAkB;AAAA,MACnB;AAEA,UAAI,QAAQ,QAAW;AACtB,eAAO,aAAa,OAAO,GAAG;AAAA,MAC/B;AAAA,IACD,OAAO;AAEN,UAAI,QAAQ,QAAW;AACtB,cAAM,aAAa,OAAO,GAAG,GAAG;AAAA,MACjC;AAGA,YAAM,UAAU,YAAY,IAAI;AAChC,UAAI,YAAY,QAAW;AAE1B,YAAI,oBAAoB,IAAI;AAC3B,iBAAO;AAAA,YACN,aAAa,UAAU,iBAAiB,GAAG;AAAA,UAC5C;AACA,4BAAkB;AAAA,QACnB;AAGA,eAAO;AAAA,MACR,WAAW,oBAAoB,IAAI;AAElC,0BAAkB;AAAA,MACnB;AAAA,IACD;AAAA,EACD;AAEA,MAAI,oBAAoB,IAAI;AAC3B,WAAO,mBAAmB,aAAa,UAAU,eAAe,CAAC;AAAA,EAClE;AAEA,SAAO,QAAQ,SAAY,MAAM;AAClC;AAnES;AAqET,SAAS,0BAA0B,MAAsB;AACxD,MAAI;AACJ,WAAS,MAAM,GAAG,MAAM,KAAK,QAAQ,OAAO;AAC3C,UAAM,OAAO,KAAK,WAAW,GAAG;AAChC,QAAI,SAAS,SAAS,QAAQ,SAAS,SAAS,cAAc;AAC7D,UAAI,QAAQ,QAAW;AACtB,cAAM,KAAK,OAAO,GAAG,GAAG;AAAA,MACzB;AACA,aAAO,YAAY,IAAI;AAAA,IACxB,WAAW,QAAQ,QAAW;AAC7B,aAAO,KAAK,GAAG;AAAA,IAChB;AAAA,EACD;AACA,SAAO,QAAQ,SAAY,MAAM;AAClC;AAdS;AAmBF,SAAS,YAAY,KAAU,uBAAwC;AAC7E,MAAI;AACJ,MAAI,IAAI,aAAa,IAAI,KAAK,SAAS,KAAK,IAAI,WAAW,QAAQ;AAElE,YAAQ,KAAK,IAAI,SAAS,GAAG,IAAI,IAAI;AAAA,EACtC,WACC,IAAI,KAAK,WAAW,CAAC,MAAM,SAAS,UAClC,IAAI,KAAK,WAAW,CAAC,KAAK,SAAS,KACpC,IAAI,KAAK,WAAW,CAAC,KAAK,SAAS,KAClC,IAAI,KAAK,WAAW,CAAC,KAAK,SAAS,KACnC,IAAI,KAAK,WAAW,CAAC,KAAK,SAAS,MACrC,IAAI,KAAK,WAAW,CAAC,MAAM,SAAS,OACnC;AACD,QAAI,uBAAuB;AAC1B,cAAQ,IAAI,KAAK,OAAO,CAAC;AAAA,IAC1B,OAAO;AAEN,cAAQ,IAAI,KAAK,CAAC,EAAE,YAAY,IAAI,IAAI,KAAK,OAAO,CAAC;AAAA,IACtD;AAAA,EACD,OAAO;AAEN,YAAQ,IAAI;AAAA,EACb;AACA,MAAI,WAAW;AACd,YAAQ,MAAM,QAAQ,OAAO,IAAI;AAAA,EAClC;AACA,SAAO;AACR;AA3BgB;AAgChB,SAAS,aAAa,KAAU,cAA+B;AAC9D,QAAM,UAAU,eACb,4BACA;AAEH,MAAI,MAAM;AACV,MAAI,EAAE,QAAQ,WAAW,MAAM,OAAO,SAAS,IAAI;AACnD,MAAI,QAAQ;AACX,WAAO;AACP,WAAO;AAAA,EACR;AACA,MAAI,aAAa,WAAW,QAAQ;AACnC,WAAO;AACP,WAAO;AAAA,EACR;AACA,MAAI,WAAW;AACd,QAAI,MAAM,UAAU,QAAQ,GAAG;AAC/B,QAAI,QAAQ,IAAI;AAEf,YAAM,WAAW,UAAU,OAAO,GAAG,GAAG;AACxC,kBAAY,UAAU,OAAO,MAAM,CAAC;AACpC,YAAM,SAAS,YAAY,GAAG;AAC9B,UAAI,QAAQ,IAAI;AACf,eAAO,QAAQ,UAAU,OAAO,KAAK;AAAA,MACtC,OAAO;AAEN,eAAO,QAAQ,SAAS,OAAO,GAAG,GAAG,GAAG,OAAO,KAAK;AACpD,eAAO;AACP,eAAO,QAAQ,SAAS,OAAO,MAAM,CAAC,GAAG,OAAO,IAAI;AAAA,MACrD;AACA,aAAO;AAAA,IACR;AACA,gBAAY,UAAU,YAAY;AAClC,UAAM,UAAU,YAAY,GAAG;AAC/B,QAAI,QAAQ,IAAI;AACf,aAAO,QAAQ,WAAW,OAAO,IAAI;AAAA,IACtC,OAAO;AAEN,aAAO,QAAQ,UAAU,OAAO,GAAG,GAAG,GAAG,OAAO,IAAI;AACpD,aAAO,UAAU,OAAO,GAAG;AAAA,IAC5B;AAAA,EACD;AACA,MAAI,MAAM;AAET,QACC,KAAK,UAAU,KACf,KAAK,WAAW,CAAC,MAAM,SAAS,SAChC,KAAK,WAAW,CAAC,MAAM,SAAS,OAC/B;AACD,YAAM,OAAO,KAAK,WAAW,CAAC;AAC9B,UAAI,QAAQ,SAAS,KAAK,QAAQ,SAAS,GAAG;AAC7C,eAAO,IAAI,OAAO,aAAa,OAAO,EAAE,CAAC,IAAI,KAAK,OAAO,CAAC,CAAC;AAAA,MAC5D;AAAA,IACD,WAAW,KAAK,UAAU,KAAK,KAAK,WAAW,CAAC,MAAM,SAAS,OAAO;AACrE,YAAM,OAAO,KAAK,WAAW,CAAC;AAC9B,UAAI,QAAQ,SAAS,KAAK,QAAQ,SAAS,GAAG;AAC7C,eAAO,GAAG,OAAO,aAAa,OAAO,EAAE,CAAC,IAAI,KAAK,OAAO,CAAC,CAAC;AAAA,MAC3D;AAAA,IACD;AAEA,WAAO,QAAQ,MAAM,MAAM,KAAK;AAAA,EACjC;AACA,MAAI,OAAO;AACV,WAAO;AACP,WAAO,QAAQ,OAAO,OAAO,KAAK;AAAA,EACnC;AACA,MAAI,UAAU;AACb,WAAO;AACP,WAAO,eACJ,WACA,uBAAuB,UAAU,OAAO,KAAK;AAAA,EACjD;AACA,SAAO;AACR;AAzES;AA6ET,SAAS,2BAA2B,KAAqB;AACxD,MAAI;AACH,WAAO,mBAAmB,GAAG;AAAA,EAC9B,QAAQ;AACP,QAAI,IAAI,SAAS,GAAG;AACnB,aAAO,IAAI,OAAO,GAAG,CAAC,IAAI,2BAA2B,IAAI,OAAO,CAAC,CAAC;AAAA,IACnE,OAAO;AACN,aAAO;AAAA,IACR;AAAA,EACD;AACD;AAVS;AAYT,MAAM,iBAAiB;AAEvB,SAAS,cAAc,KAAqB;AAC3C,MAAI,CAAC,IAAI,MAAM,cAAc,GAAG;AAC/B,WAAO;AAAA,EACR;AACA,SAAO,IAAI;AAAA,IAAQ;AAAA,IAAgB,CAAC,UACnC,2BAA2B,KAAK;AAAA,EACjC;AACD;AAPS;",
  "names": []
}
