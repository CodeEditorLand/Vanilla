{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/extpath.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { isAbsolute, join, normalize, posix, sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from './strings.js';\nimport { isNumber } from './types.js';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\treturn removeTrailingPathSeparator(candidate);\n}\n\nexport function removeTrailingPathSeparator(candidate: string): string {\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string, isWindowsOS: boolean = isWindows): string | undefined {\n\treturn hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tlet pathCharsTouse: string;\n\t\tif (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {\n\n\t\t\t// Windows has certain reserved file names that cannot be used, such\n\t\t\t// as AUX, CON, PRN, etc. We want to avoid generating a random name\n\t\t\t// that matches that pattern, so we use a different set of characters\n\t\t\t// for the first character of the name that does not include any of\n\t\t\t// the reserved names first characters.\n\n\t\t\tpathCharsTouse = windowsSafePathFirstChars;\n\t\t} else {\n\t\t\tpathCharsTouse = pathChars;\n\t\t}\n\n\t\tsuffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n"],
  "mappings": "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",
  "names": ["sep", "pos"]
}
