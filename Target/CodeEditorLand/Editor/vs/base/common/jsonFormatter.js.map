{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/jsonFormatter.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ScanError, SyntaxKind, createScanner } from \"./json.js\";\n\nexport interface FormattingOptions {\n\t/**\n\t * If indentation is based on spaces (`insertSpaces` = true), then what is the number of spaces that make an indent?\n\t */\n\ttabSize?: number;\n\t/**\n\t * Is indentation based on spaces?\n\t */\n\tinsertSpaces?: boolean;\n\t/**\n\t * The default 'end of line' character. If not set, '\\n' is used as default.\n\t */\n\teol?: string;\n}\n\n/**\n * Represents a text modification\n */\nexport interface Edit {\n\t/**\n\t * The start offset of the modification.\n\t */\n\toffset: number;\n\t/**\n\t * The length of the modification. Must not be negative. Empty length represents an *insert*.\n\t */\n\tlength: number;\n\t/**\n\t * The new content. Empty content represents a *remove*.\n\t */\n\tcontent: string;\n}\n\n/**\n * A text range in the document\n */\nexport interface Range {\n\t/**\n\t * The start offset of the range.\n\t */\n\toffset: number;\n\t/**\n\t * The length of the range. Must not be negative.\n\t */\n\tlength: number;\n}\n\nexport function format(\n\tdocumentText: string,\n\trange: Range | undefined,\n\toptions: FormattingOptions,\n): Edit[] {\n\tlet initialIndentLevel: number;\n\tlet formatText: string;\n\tlet formatTextStart: number;\n\tlet rangeStart: number;\n\tlet rangeEnd: number;\n\tif (range) {\n\t\trangeStart = range.offset;\n\t\trangeEnd = rangeStart + range.length;\n\n\t\tformatTextStart = rangeStart;\n\t\twhile (\n\t\t\tformatTextStart > 0 &&\n\t\t\t!isEOL(documentText, formatTextStart - 1)\n\t\t) {\n\t\t\tformatTextStart--;\n\t\t}\n\t\tlet endOffset = rangeEnd;\n\t\twhile (\n\t\t\tendOffset < documentText.length &&\n\t\t\t!isEOL(documentText, endOffset)\n\t\t) {\n\t\t\tendOffset++;\n\t\t}\n\t\tformatText = documentText.substring(formatTextStart, endOffset);\n\t\tinitialIndentLevel = computeIndentLevel(formatText, options);\n\t} else {\n\t\tformatText = documentText;\n\t\tinitialIndentLevel = 0;\n\t\tformatTextStart = 0;\n\t\trangeStart = 0;\n\t\trangeEnd = documentText.length;\n\t}\n\tconst eol = getEOL(options, documentText);\n\n\tlet lineBreak = false;\n\tlet indentLevel = 0;\n\tlet indentValue: string;\n\tif (options.insertSpaces) {\n\t\tindentValue = repeat(\" \", options.tabSize || 4);\n\t} else {\n\t\tindentValue = \"\\t\";\n\t}\n\n\tconst scanner = createScanner(formatText, false);\n\tlet hasError = false;\n\n\tfunction newLineAndIndent(): string {\n\t\treturn eol + repeat(indentValue, initialIndentLevel + indentLevel);\n\t}\n\tfunction scanNext(): SyntaxKind {\n\t\tlet token = scanner.scan();\n\t\tlineBreak = false;\n\t\twhile (\n\t\t\ttoken === SyntaxKind.Trivia ||\n\t\t\ttoken === SyntaxKind.LineBreakTrivia\n\t\t) {\n\t\t\tlineBreak = lineBreak || token === SyntaxKind.LineBreakTrivia;\n\t\t\ttoken = scanner.scan();\n\t\t}\n\t\thasError =\n\t\t\ttoken === SyntaxKind.Unknown ||\n\t\t\tscanner.getTokenError() !== ScanError.None;\n\t\treturn token;\n\t}\n\tconst editOperations: Edit[] = [];\n\tfunction addEdit(text: string, startOffset: number, endOffset: number) {\n\t\tif (\n\t\t\t!hasError &&\n\t\t\tstartOffset < rangeEnd &&\n\t\t\tendOffset > rangeStart &&\n\t\t\tdocumentText.substring(startOffset, endOffset) !== text\n\t\t) {\n\t\t\teditOperations.push({\n\t\t\t\toffset: startOffset,\n\t\t\t\tlength: endOffset - startOffset,\n\t\t\t\tcontent: text,\n\t\t\t});\n\t\t}\n\t}\n\n\tlet firstToken = scanNext();\n\n\tif (firstToken !== SyntaxKind.EOF) {\n\t\tconst firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n\t\tconst initialIndent = repeat(indentValue, initialIndentLevel);\n\t\taddEdit(initialIndent, formatTextStart, firstTokenStart);\n\t}\n\n\twhile (firstToken !== SyntaxKind.EOF) {\n\t\tlet firstTokenEnd =\n\t\t\tscanner.getTokenOffset() +\n\t\t\tscanner.getTokenLength() +\n\t\t\tformatTextStart;\n\t\tlet secondToken = scanNext();\n\n\t\tlet replaceContent = \"\";\n\t\twhile (\n\t\t\t!lineBreak &&\n\t\t\t(secondToken === SyntaxKind.LineCommentTrivia ||\n\t\t\t\tsecondToken === SyntaxKind.BlockCommentTrivia)\n\t\t) {\n\t\t\t// comments on the same line: keep them on the same line, but ignore them otherwise\n\t\t\tconst commentTokenStart =\n\t\t\t\tscanner.getTokenOffset() + formatTextStart;\n\t\t\taddEdit(\" \", firstTokenEnd, commentTokenStart);\n\t\t\tfirstTokenEnd =\n\t\t\t\tscanner.getTokenOffset() +\n\t\t\t\tscanner.getTokenLength() +\n\t\t\t\tformatTextStart;\n\t\t\treplaceContent =\n\t\t\t\tsecondToken === SyntaxKind.LineCommentTrivia\n\t\t\t\t\t? newLineAndIndent()\n\t\t\t\t\t: \"\";\n\t\t\tsecondToken = scanNext();\n\t\t}\n\n\t\tif (secondToken === SyntaxKind.CloseBraceToken) {\n\t\t\tif (firstToken !== SyntaxKind.OpenBraceToken) {\n\t\t\t\tindentLevel--;\n\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t}\n\t\t} else if (secondToken === SyntaxKind.CloseBracketToken) {\n\t\t\tif (firstToken !== SyntaxKind.OpenBracketToken) {\n\t\t\t\tindentLevel--;\n\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (firstToken) {\n\t\t\t\tcase SyntaxKind.OpenBracketToken:\n\t\t\t\tcase SyntaxKind.OpenBraceToken:\n\t\t\t\t\tindentLevel++;\n\t\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.CommaToken:\n\t\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\t\t\tif (lineBreak) {\n\t\t\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// symbol following comment on the same line: keep on same line, separate with ' '\n\t\t\t\t\t\treplaceContent = \" \";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.ColonToken:\n\t\t\t\t\treplaceContent = \" \";\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.StringLiteral:\n\t\t\t\t\tif (secondToken === SyntaxKind.ColonToken) {\n\t\t\t\t\t\treplaceContent = \"\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t// fall through\n\t\t\t\tcase SyntaxKind.NullKeyword:\n\t\t\t\tcase SyntaxKind.TrueKeyword:\n\t\t\t\tcase SyntaxKind.FalseKeyword:\n\t\t\t\tcase SyntaxKind.NumericLiteral:\n\t\t\t\tcase SyntaxKind.CloseBraceToken:\n\t\t\t\tcase SyntaxKind.CloseBracketToken:\n\t\t\t\t\tif (\n\t\t\t\t\t\tsecondToken === SyntaxKind.LineCommentTrivia ||\n\t\t\t\t\t\tsecondToken === SyntaxKind.BlockCommentTrivia\n\t\t\t\t\t) {\n\t\t\t\t\t\treplaceContent = \" \";\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tsecondToken !== SyntaxKind.CommaToken &&\n\t\t\t\t\t\tsecondToken !== SyntaxKind.EOF\n\t\t\t\t\t) {\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Unknown:\n\t\t\t\t\thasError = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tlineBreak &&\n\t\t\t\t(secondToken === SyntaxKind.LineCommentTrivia ||\n\t\t\t\t\tsecondToken === SyntaxKind.BlockCommentTrivia)\n\t\t\t) {\n\t\t\t\treplaceContent = newLineAndIndent();\n\t\t\t}\n\t\t}\n\t\tconst secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n\t\taddEdit(replaceContent, firstTokenEnd, secondTokenStart);\n\t\tfirstToken = secondToken;\n\t}\n\treturn editOperations;\n}\n\n/**\n * Creates a formatted string out of the object passed as argument, using the given formatting options\n * @param any The object to stringify and format\n * @param options The formatting options to use\n */\nexport function toFormattedString(obj: any, options: FormattingOptions) {\n\tconst content = JSON.stringify(\n\t\tobj,\n\t\tundefined,\n\t\toptions.insertSpaces ? options.tabSize || 4 : \"\\t\",\n\t);\n\tif (options.eol !== undefined) {\n\t\treturn content.replace(/\\r\\n|\\r|\\n/g, options.eol);\n\t}\n\treturn content;\n}\n\nfunction repeat(s: string, count: number): string {\n\tlet result = \"\";\n\tfor (let i = 0; i < count; i++) {\n\t\tresult += s;\n\t}\n\treturn result;\n}\n\nfunction computeIndentLevel(\n\tcontent: string,\n\toptions: FormattingOptions,\n): number {\n\tlet i = 0;\n\tlet nChars = 0;\n\tconst tabSize = options.tabSize || 4;\n\twhile (i < content.length) {\n\t\tconst ch = content.charAt(i);\n\t\tif (ch === \" \") {\n\t\t\tnChars++;\n\t\t} else if (ch === \"\\t\") {\n\t\t\tnChars += tabSize;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn Math.floor(nChars / tabSize);\n}\n\nexport function getEOL(options: FormattingOptions, text: string): string {\n\tfor (let i = 0; i < text.length; i++) {\n\t\tconst ch = text.charAt(i);\n\t\tif (ch === \"\\r\") {\n\t\t\tif (i + 1 < text.length && text.charAt(i + 1) === \"\\n\") {\n\t\t\t\treturn \"\\r\\n\";\n\t\t\t}\n\t\t\treturn \"\\r\";\n\t\t} else if (ch === \"\\n\") {\n\t\t\treturn \"\\n\";\n\t\t}\n\t}\n\treturn (options && options.eol) || \"\\n\";\n}\n\nexport function isEOL(text: string, offset: number) {\n\treturn \"\\r\\n\".indexOf(text.charAt(offset)) !== -1;\n}\n"],
  "mappings": "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",
  "names": []
}
