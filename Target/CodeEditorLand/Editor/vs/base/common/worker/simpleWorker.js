import{CharCode as v}from"../charCode.js";import{onUnexpectedError as b,transformErrorForSerialization as u}from"../errors.js";import{Emitter as _}from"../event.js";import{Disposable as M}from"../lifecycle.js";import{FileAccess as E}from"../network.js";import{isWeb as w}from"../platform.js";import*as h from"../strings.js";const m=!0,l="default",p="$initialize";let y=!1;function A(i){w&&(y||(y=!0))}var q=(n=>(n[n.Request=0]="Request",n[n.Reply=1]="Reply",n[n.SubscribeEvent=2]="SubscribeEvent",n[n.Event=3]="Event",n[n.UnsubscribeEvent=4]="UnsubscribeEvent",n))(q||{});class k{constructor(e,r,s,t,n){this.vsWorker=e;this.req=r;this.channel=s;this.method=t;this.args=n}type=0}class g{constructor(e,r,s,t){this.vsWorker=e;this.seq=r;this.res=s;this.err=t}type=1}class I{constructor(e,r,s,t,n){this.vsWorker=e;this.req=r;this.channel=s;this.eventName=t;this.arg=n}type=2}class R{constructor(e,r,s){this.vsWorker=e;this.req=r;this.event=s}type=3}class x{constructor(e,r){this.vsWorker=e;this.req=r}type=4}class f{_workerId;_lastSentReq;_pendingReplies;_pendingEmitters;_pendingEvents;_handler;constructor(e){this._workerId=-1,this._handler=e,this._lastSentReq=0,this._pendingReplies=Object.create(null),this._pendingEmitters=new Map,this._pendingEvents=new Map}setWorkerId(e){this._workerId=e}sendMessage(e,r,s){const t=String(++this._lastSentReq);return new Promise((n,o)=>{this._pendingReplies[t]={resolve:n,reject:o},this._send(new k(this._workerId,t,e,r,s))})}listen(e,r,s){let t=null;const n=new _({onWillAddFirstListener:()=>{t=String(++this._lastSentReq),this._pendingEmitters.set(t,n),this._send(new I(this._workerId,t,e,r,s))},onDidRemoveLastListener:()=>{this._pendingEmitters.delete(t),this._send(new x(this._workerId,t)),t=null}});return n.event}handleMessage(e){!e||!e.vsWorker||this._workerId!==-1&&e.vsWorker!==this._workerId||this._handleMessage(e)}createProxyToRemoteChannel(e,r){const s={get:(t,n)=>(typeof n=="string"&&!t[n]&&(c(n)?t[n]=o=>this.listen(e,n,o):d(n)?t[n]=this.listen(e,n,void 0):n.charCodeAt(0)===v.DollarSign&&(t[n]=async(...o)=>(await r?.(),this.sendMessage(e,n,o)))),t[n])};return new Proxy(Object.create(null),s)}_handleMessage(e){switch(e.type){case 1:return this._handleReplyMessage(e);case 0:return this._handleRequestMessage(e);case 2:return this._handleSubscribeEventMessage(e);case 3:return this._handleEventMessage(e);case 4:return this._handleUnsubscribeEventMessage(e)}}_handleReplyMessage(e){if(!this._pendingReplies[e.seq])return;const r=this._pendingReplies[e.seq];if(delete this._pendingReplies[e.seq],e.err){let s=e.err;e.err.$isError&&(s=new Error,s.name=e.err.name,s.message=e.err.message,s.stack=e.err.stack),r.reject(s);return}r.resolve(e.res)}_handleRequestMessage(e){const r=e.req;this._handler.handleMessage(e.channel,e.method,e.args).then(t=>{this._send(new g(this._workerId,r,t,void 0))},t=>{t.detail instanceof Error&&(t.detail=u(t.detail)),this._send(new g(this._workerId,r,void 0,u(t)))})}_handleSubscribeEventMessage(e){const r=e.req,s=this._handler.handleEvent(e.channel,e.eventName,e.arg)(t=>{this._send(new R(this._workerId,r,t))});this._pendingEvents.set(r,s)}_handleEventMessage(e){this._pendingEmitters.has(e.req)&&this._pendingEmitters.get(e.req).fire(e.event)}_handleUnsubscribeEventMessage(e){this._pendingEvents.has(e.req)&&(this._pendingEvents.get(e.req).dispose(),this._pendingEvents.delete(e.req))}_send(e){const r=[];if(e.type===0)for(let s=0;s<e.args.length;s++)e.args[s]instanceof ArrayBuffer&&r.push(e.args[s]);else e.type===1&&e.res instanceof ArrayBuffer&&r.push(e.res);this._handler.sendMessage(e,r)}}class $ extends M{_worker;_onModuleLoaded;_protocol;proxy;_localChannels=new Map;_remoteChannels=new Map;constructor(e,r){super(),this._worker=this._register(e.create({amdModuleId:"vs/base/common/worker/simpleWorker",esmModuleLocation:r.esmModuleLocation,label:r.label},n=>{this._protocol.handleMessage(n)},n=>{b(n)})),this._protocol=new f({sendMessage:(n,o)=>{this._worker.postMessage(n,o)},handleMessage:(n,o,a)=>this._handleMessage(n,o,a),handleEvent:(n,o,a)=>this._handleEvent(n,o,a)}),this._protocol.setWorkerId(this._worker.getId());let s=null;const t=globalThis.require;typeof t<"u"&&typeof t.getConfig=="function"?s=t.getConfig():typeof globalThis.requirejs<"u"&&(s=globalThis.requirejs.s.contexts._.config),this._onModuleLoaded=this._protocol.sendMessage(l,p,[this._worker.getId(),JSON.parse(JSON.stringify(s)),r.amdModuleId]),this.proxy=this._protocol.createProxyToRemoteChannel(l,async()=>{await this._onModuleLoaded}),this._onModuleLoaded.catch(n=>{this._onError("Worker failed to load "+r.amdModuleId,n)})}_handleMessage(e,r,s){const t=this._localChannels.get(e);if(!t)return Promise.reject(new Error(`Missing channel ${e} on main thread`));if(typeof t[r]!="function")return Promise.reject(new Error(`Missing method ${r} on main thread channel ${e}`));try{return Promise.resolve(t[r].apply(t,s))}catch(n){return Promise.reject(n)}}_handleEvent(e,r,s){const t=this._localChannels.get(e);if(!t)throw new Error(`Missing channel ${e} on main thread`);if(c(r)){const n=t[r].call(t,s);if(typeof n!="function")throw new Error(`Missing dynamic event ${r} on main thread channel ${e}.`);return n}if(d(r)){const n=t[r];if(typeof n!="function")throw new Error(`Missing event ${r} on main thread channel ${e}.`);return n}throw new Error(`Malformed event name ${r}`)}setChannel(e,r){this._localChannels.set(e,r)}getChannel(e){if(!this._remoteChannels.has(e)){const r=this._protocol.createProxyToRemoteChannel(e,async()=>{await this._onModuleLoaded});this._remoteChannels.set(e,r)}return this._remoteChannels.get(e)}_onError(e,r){}}function d(i){return i[0]==="o"&&i[1]==="n"&&h.isUpperAsciiLetter(i.charCodeAt(2))}function c(i){return/^onDynamic/.test(i)&&h.isUpperAsciiLetter(i.charCodeAt(9))}class P{_requestHandlerFactory;_requestHandler;_protocol;_localChannels=new Map;_remoteChannels=new Map;constructor(e,r){this._requestHandlerFactory=r,this._requestHandler=null,this._protocol=new f({sendMessage:(s,t)=>{e(s,t)},handleMessage:(s,t,n)=>this._handleMessage(s,t,n),handleEvent:(s,t,n)=>this._handleEvent(s,t,n)})}onmessage(e){this._protocol.handleMessage(e)}_handleMessage(e,r,s){if(e===l&&r===p)return this.initialize(s[0],s[1],s[2]);const t=e===l?this._requestHandler:this._localChannels.get(e);if(!t)return Promise.reject(new Error(`Missing channel ${e} on worker thread`));if(typeof t[r]!="function")return Promise.reject(new Error(`Missing method ${r} on worker thread channel ${e}`));try{return Promise.resolve(t[r].apply(t,s))}catch(n){return Promise.reject(n)}}_handleEvent(e,r,s){const t=e===l?this._requestHandler:this._localChannels.get(e);if(!t)throw new Error(`Missing channel ${e} on worker thread`);if(c(r)){const n=t[r].call(t,s);if(typeof n!="function")throw new Error(`Missing dynamic event ${r} on request handler.`);return n}if(d(r)){const n=t[r];if(typeof n!="function")throw new Error(`Missing event ${r} on request handler.`);return n}throw new Error(`Malformed event name ${r}`)}setChannel(e,r){this._localChannels.set(e,r)}getChannel(e){if(!this._remoteChannels.has(e)){const r=this._protocol.createProxyToRemoteChannel(e);this._remoteChannels.set(e,r)}return this._remoteChannels.get(e)}async initialize(e,r,s){if(this._protocol.setWorkerId(e),this._requestHandlerFactory){this._requestHandler=this._requestHandlerFactory(this);return}return r&&(typeof r.baseUrl<"u"&&delete r.baseUrl,typeof r.paths<"u"&&typeof r.paths.vs<"u"&&delete r.paths.vs,typeof r.trustedTypesPolicy<"u"&&delete r.trustedTypesPolicy,r.catchError=!0,globalThis.require.config(r)),m?import(`${E.asBrowserUri(`${s}.js`).toString(!0)}`).then(n=>{if(this._requestHandler=n.create(this),!this._requestHandler)throw new Error("No RequestHandler!")}):new Promise((t,n)=>{const o=globalThis.require;o([s],a=>{if(this._requestHandler=a.create(this),!this._requestHandler){n(new Error("No RequestHandler!"));return}t()},n)})}}function U(i){return new P(i,null)}export{$ as SimpleWorkerClient,P as SimpleWorkerServer,U as create,A as logOnceWebWorkerWarning};
