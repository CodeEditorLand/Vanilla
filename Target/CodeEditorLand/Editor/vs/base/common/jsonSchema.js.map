{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/jsonSchema.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type JSONSchemaType =\n\t| \"string\"\n\t| \"number\"\n\t| \"integer\"\n\t| \"boolean\"\n\t| \"null\"\n\t| \"array\"\n\t| \"object\";\n\nexport interface IJSONSchema {\n\tid?: string;\n\t$id?: string;\n\t$schema?: string;\n\ttype?: JSONSchemaType | JSONSchemaType[];\n\ttitle?: string;\n\tdefault?: any;\n\tdefinitions?: IJSONSchemaMap;\n\tdescription?: string;\n\tproperties?: IJSONSchemaMap;\n\tpatternProperties?: IJSONSchemaMap;\n\tadditionalProperties?: boolean | IJSONSchema;\n\tminProperties?: number;\n\tmaxProperties?: number;\n\tdependencies?: IJSONSchemaMap | { [prop: string]: string[] };\n\titems?: IJSONSchema | IJSONSchema[];\n\tminItems?: number;\n\tmaxItems?: number;\n\tuniqueItems?: boolean;\n\tadditionalItems?: boolean | IJSONSchema;\n\tpattern?: string;\n\tminLength?: number;\n\tmaxLength?: number;\n\tminimum?: number;\n\tmaximum?: number;\n\texclusiveMinimum?: boolean | number;\n\texclusiveMaximum?: boolean | number;\n\tmultipleOf?: number;\n\trequired?: string[];\n\t$ref?: string;\n\tanyOf?: IJSONSchema[];\n\tallOf?: IJSONSchema[];\n\toneOf?: IJSONSchema[];\n\tnot?: IJSONSchema;\n\tenum?: any[];\n\tformat?: string;\n\n\t// schema draft 06\n\tconst?: any;\n\tcontains?: IJSONSchema;\n\tpropertyNames?: IJSONSchema;\n\texamples?: any[];\n\n\t// schema draft 07\n\t$comment?: string;\n\tif?: IJSONSchema;\n\tthen?: IJSONSchema;\n\telse?: IJSONSchema;\n\n\t// schema 2019-09\n\tunevaluatedProperties?: boolean | IJSONSchema;\n\tunevaluatedItems?: boolean | IJSONSchema;\n\tminContains?: number;\n\tmaxContains?: number;\n\tdeprecated?: boolean;\n\tdependentRequired?: { [prop: string]: string[] };\n\tdependentSchemas?: IJSONSchemaMap;\n\t$defs?: { [name: string]: IJSONSchema };\n\t$anchor?: string;\n\t$recursiveRef?: string;\n\t$recursiveAnchor?: string;\n\t$vocabulary?: any;\n\n\t// schema 2020-12\n\tprefixItems?: IJSONSchema[];\n\t$dynamicRef?: string;\n\t$dynamicAnchor?: string;\n\n\t// VSCode extensions\n\n\tdefaultSnippets?: IJSONSchemaSnippet[];\n\terrorMessage?: string;\n\tpatternErrorMessage?: string;\n\tdeprecationMessage?: string;\n\tmarkdownDeprecationMessage?: string;\n\tenumDescriptions?: string[];\n\tmarkdownEnumDescriptions?: string[];\n\tmarkdownDescription?: string;\n\tdoNotSuggest?: boolean;\n\tsuggestSortText?: string;\n\tallowComments?: boolean;\n\tallowTrailingCommas?: boolean;\n}\n\nexport interface IJSONSchemaMap {\n\t[name: string]: IJSONSchema;\n}\n\nexport interface IJSONSchemaSnippet {\n\tlabel?: string;\n\tdescription?: string;\n\tbody?: any; // a object that will be JSON stringified\n\tbodyText?: string; // an already stringified JSON object that can contain new lines (\\n) and tabs (\\t)\n}\n\n/**\n * Converts a basic JSON schema to a TypeScript type.\n *\n * TODO: only supports basic schemas. Doesn't support all JSON schema features.\n */\nexport type SchemaToType<T> = T extends { type: \"string\" }\n\t? string\n\t: T extends { type: \"number\" }\n\t\t? number\n\t\t: T extends { type: \"boolean\" }\n\t\t\t? boolean\n\t\t\t: T extends { type: \"null\" }\n\t\t\t\t? null\n\t\t\t\t: T extends { type: \"object\"; properties: infer P }\n\t\t\t\t\t? { [K in keyof P]: SchemaToType<P[K]> }\n\t\t\t\t\t: T extends { type: \"array\"; items: infer I }\n\t\t\t\t\t\t? Array<SchemaToType<I>>\n\t\t\t\t\t\t: never;\n\ninterface Equals {\n\tschemas: IJSONSchema[];\n\tid?: string;\n}\n\nexport function getCompressedContent(schema: IJSONSchema): string {\n\tlet hasDups = false;\n\n\t// visit all schema nodes and collect the ones that are equal\n\tconst equalsByString = new Map<string, Equals>();\n\tconst nodeToEquals = new Map<IJSONSchema, Equals>();\n\tconst visitSchemas = (next: IJSONSchema) => {\n\t\tif (schema === next) {\n\t\t\treturn true;\n\t\t}\n\t\tconst val = JSON.stringify(next);\n\t\tif (val.length < 30) {\n\t\t\t// the $ref takes around 25 chars, so we don't save anything\n\t\t\treturn true;\n\t\t}\n\t\tconst eq = equalsByString.get(val);\n\t\tif (!eq) {\n\t\t\tconst newEq = { schemas: [next] };\n\t\t\tequalsByString.set(val, newEq);\n\t\t\tnodeToEquals.set(next, newEq);\n\t\t\treturn true;\n\t\t}\n\t\teq.schemas.push(next);\n\t\tnodeToEquals.set(next, eq);\n\t\thasDups = true;\n\t\treturn false;\n\t};\n\ttraverseNodes(schema, visitSchemas);\n\tequalsByString.clear();\n\n\tif (!hasDups) {\n\t\treturn JSON.stringify(schema);\n\t}\n\n\tlet defNodeName = \"$defs\";\n\twhile (schema.hasOwnProperty(defNodeName)) {\n\t\tdefNodeName += \"_\";\n\t}\n\n\t// used to collect all schemas that are later put in `$defs`. The index in the array is the id of the schema.\n\tconst definitions: IJSONSchema[] = [];\n\n\tfunction stringify(root: IJSONSchema): string {\n\t\treturn JSON.stringify(root, (_key: string, value: any) => {\n\t\t\tif (value !== root) {\n\t\t\t\tconst eq = nodeToEquals.get(value);\n\t\t\t\tif (eq && eq.schemas.length > 1) {\n\t\t\t\t\tif (!eq.id) {\n\t\t\t\t\t\teq.id = `_${definitions.length}`;\n\t\t\t\t\t\tdefinitions.push(eq.schemas[0]);\n\t\t\t\t\t}\n\t\t\t\t\treturn { $ref: `#/${defNodeName}/${eq.id}` };\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t});\n\t}\n\n\t// stringify the schema and replace duplicate subtrees with $ref\n\t// this will add new items to the definitions array\n\tconst str = stringify(schema);\n\n\t// now stringify the definitions. Each invication of stringify cann add new items to the definitions array, so the length can grow while we iterate\n\tconst defStrings: string[] = [];\n\tfor (let i = 0; i < definitions.length; i++) {\n\t\tdefStrings.push(`\"_${i}\":${stringify(definitions[i])}`);\n\t}\n\tif (defStrings.length) {\n\t\treturn `${str.substring(0, str.length - 1)},\"${defNodeName}\":{${defStrings.join(\",\")}}}`;\n\t}\n\treturn str;\n}\n\ntype IJSONSchemaRef = IJSONSchema | boolean;\n\nfunction isObject(thing: any): thing is object {\n\treturn typeof thing === \"object\" && thing !== null;\n}\n\n/*\n * Traverse a JSON schema and visit each schema node\n */\nfunction traverseNodes(\n\troot: IJSONSchema,\n\tvisit: (schema: IJSONSchema) => boolean,\n) {\n\tif (!root || typeof root !== \"object\") {\n\t\treturn;\n\t}\n\tconst collectEntries = (...entries: (IJSONSchemaRef | undefined)[]) => {\n\t\tfor (const entry of entries) {\n\t\t\tif (isObject(entry)) {\n\t\t\t\ttoWalk.push(entry);\n\t\t\t}\n\t\t}\n\t};\n\tconst collectMapEntries = (...maps: (IJSONSchemaMap | undefined)[]) => {\n\t\tfor (const map of maps) {\n\t\t\tif (isObject(map)) {\n\t\t\t\tfor (const key in map) {\n\t\t\t\t\tconst entry = map[key];\n\t\t\t\t\tif (isObject(entry)) {\n\t\t\t\t\t\ttoWalk.push(entry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tconst collectArrayEntries = (\n\t\t...arrays: (IJSONSchemaRef[] | undefined)[]\n\t) => {\n\t\tfor (const array of arrays) {\n\t\t\tif (Array.isArray(array)) {\n\t\t\t\tfor (const entry of array) {\n\t\t\t\t\tif (isObject(entry)) {\n\t\t\t\t\t\ttoWalk.push(entry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tconst collectEntryOrArrayEntries = (\n\t\titems: IJSONSchemaRef[] | IJSONSchemaRef | undefined,\n\t) => {\n\t\tif (Array.isArray(items)) {\n\t\t\tfor (const entry of items) {\n\t\t\t\tif (isObject(entry)) {\n\t\t\t\t\ttoWalk.push(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(items)) {\n\t\t\ttoWalk.push(items);\n\t\t}\n\t};\n\n\tconst toWalk: IJSONSchema[] = [root];\n\n\tlet next = toWalk.pop();\n\twhile (next) {\n\t\tconst visitChildern = visit(next);\n\t\tif (visitChildern) {\n\t\t\tcollectEntries(\n\t\t\t\tnext.additionalItems,\n\t\t\t\tnext.additionalProperties,\n\t\t\t\tnext.not,\n\t\t\t\tnext.contains,\n\t\t\t\tnext.propertyNames,\n\t\t\t\tnext.if,\n\t\t\t\tnext.then,\n\t\t\t\tnext.else,\n\t\t\t\tnext.unevaluatedItems,\n\t\t\t\tnext.unevaluatedProperties,\n\t\t\t);\n\t\t\tcollectMapEntries(\n\t\t\t\tnext.definitions,\n\t\t\t\tnext.$defs,\n\t\t\t\tnext.properties,\n\t\t\t\tnext.patternProperties,\n\t\t\t\t<IJSONSchemaMap>next.dependencies,\n\t\t\t\tnext.dependentSchemas,\n\t\t\t);\n\t\t\tcollectArrayEntries(\n\t\t\t\tnext.anyOf,\n\t\t\t\tnext.allOf,\n\t\t\t\tnext.oneOf,\n\t\t\t\tnext.prefixItems,\n\t\t\t);\n\t\t\tcollectEntryOrArrayEntries(next.items);\n\t\t}\n\t\tnext = toWalk.pop();\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
