{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/iconLabels.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IMatch, matchesFuzzy } from './filters.js';\nimport { ltrim } from './strings.js';\nimport { ThemeIcon } from './themables.js';\n\nconst iconStartMarker = '$(';\n\nconst iconsRegex = new RegExp(`\\\\$\\\\(${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?\\\\)`, 'g'); // no capturing groups\n\nconst escapeIconsRegex = new RegExp(`(\\\\\\\\)?${iconsRegex.source}`, 'g');\nexport function escapeIcons(text: string): string {\n\treturn text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\\\${match}`);\n}\n\nconst markdownEscapedIconsRegex = new RegExp(`\\\\\\\\${iconsRegex.source}`, 'g');\nexport function markdownEscapeEscapedIcons(text: string): string {\n\t// Need to add an extra \\ for escaping in markdown\n\treturn text.replace(markdownEscapedIconsRegex, match => `\\\\${match}`);\n}\n\nconst stripIconsRegex = new RegExp(`(\\\\s)?(\\\\\\\\)?${iconsRegex.source}(\\\\s)?`, 'g');\n\n/**\n * Takes a label with icons (`$(iconId)xyz`)  and strips the icons out (`xyz`)\n */\nexport function stripIcons(text: string): string {\n\tif (text.indexOf(iconStartMarker) === -1) {\n\t\treturn text;\n\t}\n\n\treturn text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');\n}\n\n\n/**\n * Takes a label with icons (`$(iconId)xyz`), removes the icon syntax adds whitespace so that screen readers can read the text better.\n */\nexport function getCodiconAriaLabel(text: string | undefined) {\n\tif (!text) {\n\t\treturn '';\n\t}\n\n\treturn text.replace(/\\$\\((.*?)\\)/g, (_match, codiconName) => ` ${codiconName} `).trim();\n}\n\n\nexport interface IParsedLabelWithIcons {\n\treadonly text: string;\n\treadonly iconOffsets?: readonly number[];\n}\n\nconst _parseIconsRegex = new RegExp(`\\\\$\\\\(${ThemeIcon.iconNameCharacter}+\\\\)`, 'g');\n\n/**\n * Takes a label with icons (`abc $(iconId)xyz`) and returns the text (`abc xyz`) and the offsets of the icons (`[3]`)\n */\nexport function parseLabelWithIcons(input: string): IParsedLabelWithIcons {\n\n\t_parseIconsRegex.lastIndex = 0;\n\n\tlet text = '';\n\tconst iconOffsets: number[] = [];\n\tlet iconsOffset = 0;\n\n\twhile (true) {\n\t\tconst pos = _parseIconsRegex.lastIndex;\n\t\tconst match = _parseIconsRegex.exec(input);\n\n\t\tconst chars = input.substring(pos, match?.index);\n\t\tif (chars.length > 0) {\n\t\t\ttext += chars;\n\t\t\tfor (let i = 0; i < chars.length; i++) {\n\t\t\t\ticonOffsets.push(iconsOffset);\n\t\t\t}\n\t\t}\n\t\tif (!match) {\n\t\t\tbreak;\n\t\t}\n\t\ticonsOffset += match[0].length;\n\t}\n\n\treturn { text, iconOffsets };\n}\n\n\nexport function matchesFuzzyIconAware(query: string, target: IParsedLabelWithIcons, enableSeparateSubstringMatching = false): IMatch[] | null {\n\tconst { text, iconOffsets } = target;\n\n\t// Return early if there are no icon markers in the word to match against\n\tif (!iconOffsets || iconOffsets.length === 0) {\n\t\treturn matchesFuzzy(query, text, enableSeparateSubstringMatching);\n\t}\n\n\t// Trim the word to match against because it could have leading\n\t// whitespace now if the word started with an icon\n\tconst wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n\tconst leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;\n\n\t// match on value without icon\n\tconst matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);\n\n\t// Map matches back to offsets with icon and trimming\n\tif (matches) {\n\t\tfor (const match of matches) {\n\t\t\tconst iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] /* icon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n\t\t\tmatch.start += iconOffset;\n\t\t\tmatch.end += iconOffset;\n\t\t}\n\t}\n\n\treturn matches;\n}\n"],
  "mappings": ";;AAKA,SAAS,QAAQ,oBAAoB;AACrC,SAAS,aAAa;AACtB,SAAS,iBAAiB;AAE1B,MAAM,kBAAkB;AAExB,MAAM,aAAa,IAAI,OAAO,SAAS,UAAU,kBAAkB,MAAM,UAAU,sBAAsB,SAAS,GAAG;AAErH,MAAM,mBAAmB,IAAI,OAAO,UAAU,WAAW,MAAM,IAAI,GAAG;AAC/D,SAAS,YAAY,MAAsB;AACjD,SAAO,KAAK,QAAQ,kBAAkB,CAAC,OAAO,YAAY,UAAU,QAAQ,KAAK,KAAK,EAAE;AACzF;AAFgB;AAIhB,MAAM,4BAA4B,IAAI,OAAO,OAAO,WAAW,MAAM,IAAI,GAAG;AACrE,SAAS,2BAA2B,MAAsB;AAEhE,SAAO,KAAK,QAAQ,2BAA2B,WAAS,KAAK,KAAK,EAAE;AACrE;AAHgB;AAKhB,MAAM,kBAAkB,IAAI,OAAO,gBAAgB,WAAW,MAAM,UAAU,GAAG;AAK1E,SAAS,WAAW,MAAsB;AAChD,MAAI,KAAK,QAAQ,eAAe,MAAM,IAAI;AACzC,WAAO;AAAA,EACR;AAEA,SAAO,KAAK,QAAQ,iBAAiB,CAAC,OAAO,eAAe,SAAS,mBAAmB,UAAU,QAAQ,iBAAiB,kBAAkB,EAAE;AAChJ;AANgB;AAYT,SAAS,oBAAoB,MAA0B;AAC7D,MAAI,CAAC,MAAM;AACV,WAAO;AAAA,EACR;AAEA,SAAO,KAAK,QAAQ,gBAAgB,CAAC,QAAQ,gBAAgB,IAAI,WAAW,GAAG,EAAE,KAAK;AACvF;AANgB;AAchB,MAAM,mBAAmB,IAAI,OAAO,SAAS,UAAU,iBAAiB,QAAQ,GAAG;AAK5E,SAAS,oBAAoB,OAAsC;AAEzE,mBAAiB,YAAY;AAE7B,MAAI,OAAO;AACX,QAAM,cAAwB,CAAC;AAC/B,MAAI,cAAc;AAElB,SAAO,MAAM;AACZ,UAAM,MAAM,iBAAiB;AAC7B,UAAM,QAAQ,iBAAiB,KAAK,KAAK;AAEzC,UAAM,QAAQ,MAAM,UAAU,KAAK,OAAO,KAAK;AAC/C,QAAI,MAAM,SAAS,GAAG;AACrB,cAAQ;AACR,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,oBAAY,KAAK,WAAW;AAAA,MAC7B;AAAA,IACD;AACA,QAAI,CAAC,OAAO;AACX;AAAA,IACD;AACA,mBAAe,MAAM,CAAC,EAAE;AAAA,EACzB;AAEA,SAAO,EAAE,MAAM,YAAY;AAC5B;AA1BgB;AA6BT,SAAS,sBAAsB,OAAe,QAA+B,kCAAkC,OAAwB;AAC7I,QAAM,EAAE,MAAM,YAAY,IAAI;AAG9B,MAAI,CAAC,eAAe,YAAY,WAAW,GAAG;AAC7C,WAAO,aAAa,OAAO,MAAM,+BAA+B;AAAA,EACjE;AAIA,QAAM,wCAAwC,MAAM,MAAM,GAAG;AAC7D,QAAM,0BAA0B,KAAK,SAAS,sCAAsC;AAGpF,QAAM,UAAU,aAAa,OAAO,uCAAuC,+BAA+B;AAG1G,MAAI,SAAS;AACZ,eAAW,SAAS,SAAS;AAC5B,YAAM,aAAa,YAAY,MAAM,QAAQ,uBAAuB,IAAgC;AACpG,YAAM,SAAS;AACf,YAAM,OAAO;AAAA,IACd;AAAA,EACD;AAEA,SAAO;AACR;AA1BgB;",
  "names": []
}
