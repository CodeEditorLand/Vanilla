{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/cache.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { IDisposable } from './lifecycle.js';\n\nexport interface CacheResult<T> extends IDisposable {\n\tpromise: Promise<T>;\n}\n\nexport class Cache<T> {\n\n\tprivate result: CacheResult<T> | null = null;\n\tconstructor(private task: (ct: CancellationToken) => Promise<T>) { }\n\n\tget(): CacheResult<T> {\n\t\tif (this.result) {\n\t\t\treturn this.result;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource();\n\t\tconst promise = this.task(cts.token);\n\n\t\tthis.result = {\n\t\t\tpromise,\n\t\t\tdispose: () => {\n\t\t\t\tthis.result = null;\n\t\t\t\tcts.cancel();\n\t\t\t\tcts.dispose();\n\t\t\t}\n\t\t};\n\n\t\treturn this.result;\n\t}\n}\n\nexport function identity<T>(t: T): T {\n\treturn t;\n}\n\ninterface ICacheOptions<TArg> {\n\t/**\n\t * The cache key is used to identify the cache entry.\n\t * Strict equality is used to compare cache keys.\n\t*/\n\tgetCacheKey: (arg: TArg) => unknown;\n}\n\n/**\n * Uses a LRU cache to make a given parametrized function cached.\n * Caches just the last key/value.\n*/\nexport class LRUCachedFunction<TArg, TComputed> {\n\tprivate lastCache: TComputed | undefined = undefined;\n\tprivate lastArgKey: unknown | undefined = undefined;\n\n\tprivate readonly _fn: (arg: TArg) => TComputed;\n\tprivate readonly _computeKey: (arg: TArg) => unknown;\n\n\tconstructor(fn: (arg: TArg) => TComputed);\n\tconstructor(options: ICacheOptions<TArg>, fn: (arg: TArg) => TComputed);\n\tconstructor(arg1: ICacheOptions<TArg> | ((arg: TArg) => TComputed), arg2?: (arg: TArg) => TComputed) {\n\t\tif (typeof arg1 === 'function') {\n\t\t\tthis._fn = arg1;\n\t\t\tthis._computeKey = identity;\n\t\t} else {\n\t\t\tthis._fn = arg2!;\n\t\t\tthis._computeKey = arg1.getCacheKey;\n\t\t}\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = this._computeKey(arg);\n\t\tif (this.lastArgKey !== key) {\n\t\t\tthis.lastArgKey = key;\n\t\t\tthis.lastCache = this._fn(arg);\n\t\t}\n\t\treturn this.lastCache!;\n\t}\n}\n\n/**\n * Uses an unbounded cache to memoize the results of the given function.\n*/\nexport class CachedFunction<TArg, TComputed> {\n\tprivate readonly _map = new Map<TArg, TComputed>();\n\tprivate readonly _map2 = new Map<unknown, TComputed>();\n\tpublic get cachedValues(): ReadonlyMap<TArg, TComputed> {\n\t\treturn this._map;\n\t}\n\n\tprivate readonly _fn: (arg: TArg) => TComputed;\n\tprivate readonly _computeKey: (arg: TArg) => unknown;\n\n\tconstructor(fn: (arg: TArg) => TComputed);\n\tconstructor(options: ICacheOptions<TArg>, fn: (arg: TArg) => TComputed);\n\tconstructor(arg1: ICacheOptions<TArg> | ((arg: TArg) => TComputed), arg2?: (arg: TArg) => TComputed) {\n\t\tif (typeof arg1 === 'function') {\n\t\t\tthis._fn = arg1;\n\t\t\tthis._computeKey = identity;\n\t\t} else {\n\t\t\tthis._fn = arg2!;\n\t\t\tthis._computeKey = arg1.getCacheKey;\n\t\t}\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = this._computeKey(arg);\n\t\tif (this._map2.has(key)) {\n\t\t\treturn this._map2.get(key)!;\n\t\t}\n\n\t\tconst value = this._fn(arg);\n\t\tthis._map.set(arg, value);\n\t\tthis._map2.set(key, value);\n\t\treturn value;\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,mBAAmB,+BAA+B;AAC3D,SAAS,mBAAmB;AAMrB,MAAM,MAAS;AAAA,EAGrB,YAAoB,MAA6C;AAA7C;AAAA,EAA+C;AAAA,EAfpE,OAYsB;AAAA;AAAA;AAAA,EAEb,SAAgC;AAAA,EAGxC,MAAsB;AACrB,QAAI,KAAK,QAAQ;AAChB,aAAO,KAAK;AAAA,IACb;AAEA,UAAM,MAAM,IAAI,wBAAwB;AACxC,UAAM,UAAU,KAAK,KAAK,IAAI,KAAK;AAEnC,SAAK,SAAS;AAAA,MACb;AAAA,MACA,SAAS,6BAAM;AACd,aAAK,SAAS;AACd,YAAI,OAAO;AACX,YAAI,QAAQ;AAAA,MACb,GAJS;AAAA,IAKV;AAEA,WAAO,KAAK;AAAA,EACb;AACD;AAEO,SAAS,SAAY,GAAS;AACpC,SAAO;AACR;AAFgB;AAgBT,MAAM,kBAAmC;AAAA,EAtDhD,OAsDgD;AAAA;AAAA;AAAA,EACvC,YAAmC;AAAA,EACnC,aAAkC;AAAA,EAEzB;AAAA,EACA;AAAA,EAIjB,YAAY,MAAwD,MAAiC;AACpG,QAAI,OAAO,SAAS,YAAY;AAC/B,WAAK,MAAM;AACX,WAAK,cAAc;AAAA,IACpB,OAAO;AACN,WAAK,MAAM;AACX,WAAK,cAAc,KAAK;AAAA,IACzB;AAAA,EACD;AAAA,EAEO,IAAI,KAAsB;AAChC,UAAM,MAAM,KAAK,YAAY,GAAG;AAChC,QAAI,KAAK,eAAe,KAAK;AAC5B,WAAK,aAAa;AAClB,WAAK,YAAY,KAAK,IAAI,GAAG;AAAA,IAC9B;AACA,WAAO,KAAK;AAAA,EACb;AACD;AAKO,MAAM,eAAgC;AAAA,EAtF7C,OAsF6C;AAAA;AAAA;AAAA,EAC3B,OAAO,oBAAI,IAAqB;AAAA,EAChC,QAAQ,oBAAI,IAAwB;AAAA,EACrD,IAAW,eAA6C;AACvD,WAAO,KAAK;AAAA,EACb;AAAA,EAEiB;AAAA,EACA;AAAA,EAIjB,YAAY,MAAwD,MAAiC;AACpG,QAAI,OAAO,SAAS,YAAY;AAC/B,WAAK,MAAM;AACX,WAAK,cAAc;AAAA,IACpB,OAAO;AACN,WAAK,MAAM;AACX,WAAK,cAAc,KAAK;AAAA,IACzB;AAAA,EACD;AAAA,EAEO,IAAI,KAAsB;AAChC,UAAM,MAAM,KAAK,YAAY,GAAG;AAChC,QAAI,KAAK,MAAM,IAAI,GAAG,GAAG;AACxB,aAAO,KAAK,MAAM,IAAI,GAAG;AAAA,IAC1B;AAEA,UAAM,QAAQ,KAAK,IAAI,GAAG;AAC1B,SAAK,KAAK,IAAI,KAAK,KAAK;AACxB,SAAK,MAAM,IAAI,KAAK,KAAK;AACzB,WAAO;AAAA,EACR;AACD;",
  "names": []
}
