{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/resources.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from \"./charCode.js\";\nimport * as extpath from \"./extpath.js\";\nimport { Schemas } from \"./network.js\";\nimport * as paths from \"./path.js\";\nimport { isLinux, isWindows } from \"./platform.js\";\nimport { equalsIgnoreCase, compare as strCompare } from \"./strings.js\";\nimport { URI, uriToFsPath } from \"./uri.js\";\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(\n\t\turi1: URI | undefined,\n\t\turi2: URI | undefined,\n\t\tignoreFragment?: boolean,\n\t): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(\n\t\tbase: URI,\n\t\tparentCandidate: URI,\n\t\tignoreFragment?: boolean,\n\t): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) {}\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(\n\t\t\tthis.getComparisonKey(uri1, ignoreFragment),\n\t\t\tthis.getComparisonKey(uri2, ignoreFragment),\n\t\t);\n\t}\n\n\tisEqual(\n\t\turi1: URI | undefined,\n\t\turi2: URI | undefined,\n\t\tignoreFragment = false,\n\t): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (\n\t\t\tthis.getComparisonKey(uri1, ignoreFragment) ===\n\t\t\tthis.getComparisonKey(uri2, ignoreFragment)\n\t\t);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment = false): string {\n\t\treturn uri\n\t\t\t.with({\n\t\t\t\tpath: this._ignorePathCasing(uri)\n\t\t\t\t\t? uri.path.toLowerCase()\n\t\t\t\t\t: undefined,\n\t\t\t\tfragment: ignoreFragment ? null : undefined,\n\t\t\t})\n\t\t\t.toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(\n\t\tbase: URI,\n\t\tparentCandidate: URI,\n\t\tignoreFragment = false,\n\t): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn (\n\t\t\t\t\textpath.isEqualOrParent(\n\t\t\t\t\t\toriginalFSPath(base),\n\t\t\t\t\t\toriginalFSPath(parentCandidate),\n\t\t\t\t\t\tthis._ignorePathCasing(base),\n\t\t\t\t\t) &&\n\t\t\t\t\tbase.query === parentCandidate.query &&\n\t\t\t\t\t(ignoreFragment ||\n\t\t\t\t\t\tbase.fragment === parentCandidate.fragment)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn (\n\t\t\t\t\textpath.isEqualOrParent(\n\t\t\t\t\t\tbase.path,\n\t\t\t\t\t\tparentCandidate.path,\n\t\t\t\t\t\tthis._ignorePathCasing(base),\n\t\t\t\t\t\t\"/\",\n\t\t\t\t\t) &&\n\t\t\t\t\tbase.query === parentCandidate.query &&\n\t\t\t\t\t(ignoreFragment ||\n\t\t\t\t\t\tbase.fragment === parentCandidate.fragment)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (\n\t\t\t\tresource.authority &&\n\t\t\t\tdirname.length &&\n\t\t\t\tdirname.charCodeAt(0) !== CharCode.Slash\n\t\t\t) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`dirname(\"${resource.toString})) resulted in a relative path`,\n\t\t\t\t);\n\t\t\t\tdirname = \"/\"; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname,\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(\n\t\t\t\tpaths.normalize(originalFSPath(resource)),\n\t\t\t).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath,\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (\n\t\t\tfrom.scheme !== to.scheme ||\n\t\t\t!isEqualAuthority(from.authority, to.authority)\n\t\t) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(\n\t\t\t\toriginalFSPath(from),\n\t\t\t\toriginalFSPath(to),\n\t\t\t);\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || \"/\";\n\t\tconst toPath = to.path || \"/\";\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (\n\t\t\t\tconst len = Math.min(fromPath.length, toPath.length);\n\t\t\t\ti < len;\n\t\t\t\ti++\n\t\t\t) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tfromPath.charAt(i).toLowerCase() !==\n\t\t\t\t\t\ttoPath.charAt(i).toLowerCase()\n\t\t\t\t\t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path,\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path),\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === \"/\";\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn (\n\t\t\ta1 === a2 ||\n\t\t\t(a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2))\n\t\t);\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn (\n\t\t\t\tfsp.length > extpath.getRoot(fsp).length &&\n\t\t\t\tfsp[fsp.length - 1] === sep\n\t\t\t);\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (\n\t\t\t\tp.length > 1 &&\n\t\t\t\tp.charCodeAt(p.length - 1) === CharCode.Slash &&\n\t\t\t\t!/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)\n\t\t\t); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({\n\t\t\t\tpath: resource.path.substr(0, resource.path.length - 1),\n\t\t\t});\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep =\n\t\t\t\tfsp !== undefined &&\n\t\t\t\tfsp.length === extpath.getRoot(fsp).length &&\n\t\t\t\tfsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tsep = \"/\";\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep =\n\t\t\t\tp.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + \"/\" });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri((uri) => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri((_) => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator =\n\textUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator =\n\textUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator =\n\textUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(\n\titems: T[],\n\tresourceAccessor: (item: T) => URI,\n): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (\n\t\t\titems.some((otherItem, index) => {\n\t\t\t\tif (index === i) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn isEqualOrParent(\n\t\t\t\t\tcandidateResource,\n\t\t\t\t\tresourceAccessor(otherItem),\n\t\t\t\t);\n\t\t\t})\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\texport const META_DATA_LABEL = \"label\";\n\texport const META_DATA_DESCRIPTION = \"description\";\n\texport const META_DATA_SIZE = \"size\";\n\texport const META_DATA_MIME = \"mime\";\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(\n\t\t\tdataUri.path.indexOf(\";\") + 1,\n\t\t\tdataUri.path.lastIndexOf(\";\"),\n\t\t);\n\t\tmeta.split(\";\").forEach((property) => {\n\t\t\tconst [key, value] = property.split(\":\");\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(\";\"));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(\n\tresource: URI,\n\tauthority: string | undefined,\n\tlocalScheme: string,\n): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n"],
  "mappings": "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",
  "names": ["dirname", "relativePath", "distinctParents", "DataUri"]
}
