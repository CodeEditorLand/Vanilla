{
  "version": 3,
  "sources": ["../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/common/resources.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n"],
  "mappings": "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",
  "names": ["dirname", "relativePath", "distinctParents", "DataUri"]
}
