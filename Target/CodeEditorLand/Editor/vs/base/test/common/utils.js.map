{
  "version": 3,
  "sources": ["../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/test/common/utils.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, DisposableTracker, IDisposable, setDisposableTracker } from '../../common/lifecycle.js';\nimport { join } from '../../common/path.js';\nimport { isWindows } from '../../common/platform.js';\nimport { URI } from '../../common/uri.js';\n\nexport type ValueCallback<T = any> = (value: T | Promise<T>) => void;\n\nexport function toResource(this: any, path: string): URI {\n\tif (isWindows) {\n\t\treturn URI.file(join('C:\\\\', btoa(this.test.fullTitle()), path));\n\t}\n\n\treturn URI.file(join('/', btoa(this.test.fullTitle()), path));\n}\n\nexport function suiteRepeat(n: number, description: string, callback: (this: any) => void): void {\n\tfor (let i = 0; i < n; i++) {\n\t\tsuite(`${description} (iteration ${i})`, callback);\n\t}\n}\n\nexport function testRepeat(n: number, description: string, callback: (this: any) => any): void {\n\tfor (let i = 0; i < n; i++) {\n\t\ttest(`${description} (iteration ${i})`, callback);\n\t}\n}\n\nexport async function assertThrowsAsync(block: () => any, message: string | Error = 'Missing expected exception'): Promise<void> {\n\ttry {\n\t\tawait block();\n\t} catch {\n\t\treturn;\n\t}\n\n\tconst err = message instanceof Error ? message : new Error(message);\n\tthrow err;\n}\n\n/**\n * Use this function to ensure that all disposables are cleaned up at the end of each test in the current suite.\n *\n * Use `markAsSingleton` if disposable singletons are created lazily that are allowed to outlive the test.\n * Make sure that the singleton properly registers all child disposables so that they are excluded too.\n *\n * @returns A {@link DisposableStore} that can optionally be used to track disposables in the test.\n * This will be automatically disposed on test teardown.\n*/\nexport function ensureNoDisposablesAreLeakedInTestSuite(): Pick<DisposableStore, 'add'> {\n\tlet tracker: DisposableTracker | undefined;\n\tlet store: DisposableStore;\n\tsetup(() => {\n\t\tstore = new DisposableStore();\n\t\ttracker = new DisposableTracker();\n\t\tsetDisposableTracker(tracker);\n\t});\n\n\tteardown(function (this: import('mocha').Context) {\n\t\tstore.dispose();\n\t\tsetDisposableTracker(null);\n\t\tif (this.currentTest?.state !== 'failed') {\n\t\t\tconst result = tracker!.computeLeakingDisposables();\n\t\t\tif (result) {\n\t\t\t\tconsole.error(result.details);\n\t\t\t\tthrow new Error(`There are ${result.leaks.length} undisposed disposables!${result.details}`);\n\t\t\t}\n\t\t}\n\t});\n\n\t// Wrap store as the suite function is called before it's initialized\n\tconst testContext = {\n\t\tadd<T extends IDisposable>(o: T): T {\n\t\t\treturn store.add(o);\n\t\t}\n\t};\n\treturn testContext;\n}\n\nexport function throwIfDisposablesAreLeaked(body: () => void, logToConsole = true): void {\n\tconst tracker = new DisposableTracker();\n\tsetDisposableTracker(tracker);\n\tbody();\n\tsetDisposableTracker(null);\n\tcomputeLeakingDisposables(tracker, logToConsole);\n}\n\nexport async function throwIfDisposablesAreLeakedAsync(body: () => Promise<void>): Promise<void> {\n\tconst tracker = new DisposableTracker();\n\tsetDisposableTracker(tracker);\n\tawait body();\n\tsetDisposableTracker(null);\n\tcomputeLeakingDisposables(tracker);\n}\n\nfunction computeLeakingDisposables(tracker: DisposableTracker, logToConsole = true) {\n\tconst result = tracker.computeLeakingDisposables();\n\tif (result) {\n\t\tif (logToConsole) {\n\t\t\tconsole.error(result.details);\n\t\t}\n\t\tthrow new Error(`There are ${result.leaks.length} undisposed disposables!${result.details}`);\n\t}\n}\n"],
  "mappings": ";;AAKA,SAAS,iBAAiB,mBAAmB,aAAa,4BAA4B;AACtF,SAAS,YAAY;AACrB,SAAS,iBAAiB;AAC1B,SAAS,WAAW;AAIb,SAAS,WAAsB,MAAmB;AACxD,MAAI,WAAW;AACd,WAAO,IAAI,KAAK,KAAK,QAAQ,KAAK,KAAK,KAAK,UAAU,CAAC,GAAG,IAAI,CAAC;AAAA,EAChE;AAEA,SAAO,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,UAAU,CAAC,GAAG,IAAI,CAAC;AAC7D;AANgB;AAQT,SAAS,YAAY,GAAW,aAAqB,UAAqC;AAChG,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC3B,UAAM,GAAG,WAAW,eAAe,CAAC,KAAK,QAAQ;AAAA,EAClD;AACD;AAJgB;AAMT,SAAS,WAAW,GAAW,aAAqB,UAAoC;AAC9F,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC3B,SAAK,GAAG,WAAW,eAAe,CAAC,KAAK,QAAQ;AAAA,EACjD;AACD;AAJgB;AAMhB,eAAsB,kBAAkB,OAAkB,UAA0B,8BAA6C;AAChI,MAAI;AACH,UAAM,MAAM;AAAA,EACb,QAAQ;AACP;AAAA,EACD;AAEA,QAAM,MAAM,mBAAmB,QAAQ,UAAU,IAAI,MAAM,OAAO;AAClE,QAAM;AACP;AATsB;AAoBf,SAAS,0CAAwE;AACvF,MAAI;AACJ,MAAI;AACJ,QAAM,MAAM;AACX,YAAQ,IAAI,gBAAgB;AAC5B,cAAU,IAAI,kBAAkB;AAChC,yBAAqB,OAAO;AAAA,EAC7B,CAAC;AAED,WAAS,WAAyC;AACjD,UAAM,QAAQ;AACd,yBAAqB,IAAI;AACzB,QAAI,KAAK,aAAa,UAAU,UAAU;AACzC,YAAM,SAAS,QAAS,0BAA0B;AAClD,UAAI,QAAQ;AACX,gBAAQ,MAAM,OAAO,OAAO;AAC5B,cAAM,IAAI,MAAM,aAAa,OAAO,MAAM,MAAM,2BAA2B,OAAO,OAAO,EAAE;AAAA,MAC5F;AAAA,IACD;AAAA,EACD,CAAC;AAGD,QAAM,cAAc;AAAA,IACnB,IAA2B,GAAS;AACnC,aAAO,MAAM,IAAI,CAAC;AAAA,IACnB;AAAA,EACD;AACA,SAAO;AACR;AA5BgB;AA8BT,SAAS,4BAA4B,MAAkB,eAAe,MAAY;AACxF,QAAM,UAAU,IAAI,kBAAkB;AACtC,uBAAqB,OAAO;AAC5B,OAAK;AACL,uBAAqB,IAAI;AACzB,4BAA0B,SAAS,YAAY;AAChD;AANgB;AAQhB,eAAsB,iCAAiC,MAA0C;AAChG,QAAM,UAAU,IAAI,kBAAkB;AACtC,uBAAqB,OAAO;AAC5B,QAAM,KAAK;AACX,uBAAqB,IAAI;AACzB,4BAA0B,OAAO;AAClC;AANsB;AAQtB,SAAS,0BAA0B,SAA4B,eAAe,MAAM;AACnF,QAAM,SAAS,QAAQ,0BAA0B;AACjD,MAAI,QAAQ;AACX,QAAI,cAAc;AACjB,cAAQ,MAAM,OAAO,OAAO;AAAA,IAC7B;AACA,UAAM,IAAI,MAAM,aAAa,OAAO,MAAM,MAAM,2BAA2B,OAAO,OAAO,EAAE;AAAA,EAC5F;AACD;AARS;",
  "names": []
}
