import t from"assert";import{Emitter as h}from"../../common/event.js";import{DisposableStore as d,dispose as i,markAsSingleton as b,ReferenceCollection as E,SafeDisposable as w,toDisposable as r}from"../../common/lifecycle.js";import{ensureNoDisposablesAreLeakedInTestSuite as p,throwIfDisposablesAreLeaked as l}from"./utils.js";class n{isDisposed=!1;dispose(){this.isDisposed=!0}}suite("Lifecycle",()=>{test("dispose single disposable",()=>{const s=new n;t(!s.isDisposed),i(s),t(s.isDisposed)}),test("dispose disposable array",()=>{const s=new n,e=new n;t(!s.isDisposed),t(!e.isDisposed),i([s,e]),t(s.isDisposed),t(e.isDisposed)}),test("dispose disposables",()=>{const s=new n,e=new n;t(!s.isDisposed),t(!e.isDisposed),i(s),i(e),t(s.isDisposed),t(e.isDisposed)}),test("dispose array should dispose all if a child throws on dispose",()=>{const s=new Set;let e;try{i([r(()=>{s.add(1)}),r(()=>{throw new Error("I am error")}),r(()=>{s.add(3)})])}catch(o){e=o}t.ok(s.has(1)),t.ok(s.has(3)),t.strictEqual(e.message,"I am error")}),test("dispose array should rethrow composite error if multiple entries throw on dispose",()=>{const s=new Set;let e;try{i([r(()=>{s.add(1)}),r(()=>{throw new Error("I am error 1")}),r(()=>{throw new Error("I am error 2")}),r(()=>{s.add(4)})])}catch(o){e=o}t.ok(s.has(1)),t.ok(s.has(4)),t.ok(e instanceof AggregateError),t.strictEqual(e.errors.length,2),t.strictEqual(e.errors[0].message,"I am error 1"),t.strictEqual(e.errors[1].message,"I am error 2")}),test("Action bar has broken accessibility #100273",function(){const s=[{dispose(){}},{dispose(){}}],e=i(s);t.strictEqual(s.length,2),t.strictEqual(e.length,0),t.ok(s!==e);const a=new Set([{dispose(){}},{dispose(){}}]).values(),c=i(a);t.ok(a===c)}),test("SafeDisposable, dispose",function(){let s=0;const e=()=>s+=1,o=new w;o.set(e),o.dispose(),t.strictEqual(s,1)}),test("SafeDisposable, unset",function(){let s=0;const e=()=>s+=1,o=new w;o.set(e),o.unset(),o.dispose(),t.strictEqual(s,0)})}),suite("DisposableStore",()=>{p(),test("dispose should call all child disposes even if a child throws on dispose",()=>{const s=new Set,e=new d;e.add(r(()=>{s.add(1)})),e.add(r(()=>{throw new Error("I am error")})),e.add(r(()=>{s.add(3)}));let o;try{e.dispose()}catch(a){o=a}t.ok(s.has(1)),t.ok(s.has(3)),t.strictEqual(o.message,"I am error")}),test("dispose should throw composite error if multiple children throw on dispose",()=>{const s=new Set,e=new d;e.add(r(()=>{s.add(1)})),e.add(r(()=>{throw new Error("I am error 1")})),e.add(r(()=>{throw new Error("I am error 2")})),e.add(r(()=>{s.add(4)}));let o;try{e.dispose()}catch(a){o=a}t.ok(s.has(1)),t.ok(s.has(4)),t.ok(o instanceof AggregateError),t.strictEqual(o.errors.length,2),t.strictEqual(o.errors[0].message,"I am error 1"),t.strictEqual(o.errors[1].message,"I am error 2")}),test("delete should evict and dispose of the disposables",()=>{const s=new Set,e=[r(()=>{s.add(1)}),r(()=>{s.add(2)})],o=new d;o.add(e[0]),o.add(e[1]),o.delete(e[0]),t.ok(s.has(1)),t.ok(!s.has(2)),o.dispose(),t.ok(s.has(1)),t.ok(s.has(2))}),test("deleteAndLeak should evict and not dispose of the disposables",()=>{const s=new Set,e=[r(()=>{s.add(1)}),r(()=>{s.add(2)})],o=new d;o.add(e[0]),o.add(e[1]),o.deleteAndLeak(e[0]),t.ok(!s.has(1)),t.ok(!s.has(2)),o.dispose(),t.ok(!s.has(1)),t.ok(s.has(2)),e[0].dispose()})}),suite("Reference Collection",()=>{p();class s extends E{_count=0;get count(){return this._count}createReferencedObject(o){return this._count++,o.length}destroyReferencedObject(o,a){this._count--}}test("simple",()=>{const e=new s,o=e.acquire("test");t(o),t.strictEqual(o.object,4),t.strictEqual(e.count,1),o.dispose(),t.strictEqual(e.count,0);const a=e.acquire("test"),c=e.acquire("test");t.strictEqual(a.object,c.object),t.strictEqual(e.count,1);const u=e.acquire("monkey");t.strictEqual(u.object,6),t.strictEqual(e.count,2),a.dispose(),t.strictEqual(e.count,2),c.dispose(),t.strictEqual(e.count,1),u.dispose(),t.strictEqual(e.count,0)})});function m(s,e){try{s(),t.fail("Expected function to throw, but it did not.")}catch(o){t.ok(e(o))}}suite("No Leakage Utilities",()=>{suite("throwIfDisposablesAreLeaked",()=>{test("throws if an event subscription is not cleaned up",()=>{const s=new h;m(()=>{l(()=>{s.event(()=>{})},!1)},e=>e.message.indexOf("undisposed disposables")!==-1)}),test("throws if a disposable is not disposed",()=>{m(()=>{l(()=>{new d},!1)},s=>s.message.indexOf("undisposed disposables")!==-1)}),test("does not throw if all event subscriptions are cleaned up",()=>{const s=new h;l(()=>{s.event(()=>{}).dispose()})}),test("does not throw if all disposables are disposed",()=>{r(()=>{}),l(()=>{b(r(()=>{}));const s=new d;s.add(r(()=>{})),b(s),r(()=>{}).dispose()})})}),suite("ensureNoDisposablesAreLeakedInTest",()=>{p(),test("Basic Test",()=>{r(()=>{}).dispose()})})});
