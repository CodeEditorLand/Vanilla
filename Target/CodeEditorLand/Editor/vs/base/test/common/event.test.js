import r from"assert";import{stub as g}from"sinon";import{tail2 as A}from"../../common/arrays.js";import{DeferredPromise as w,timeout as l}from"../../common/async.js";import{CancellationToken as b}from"../../common/cancellation.js";import{errorHandler as T,setUnexpectedErrorHandler as q}from"../../common/errors.js";import{AsyncEmitter as h,DebounceEmitter as U,DynamicListEventMultiplexer as P,Emitter as a,Event as c,EventBufferer as D,EventMultiplexer as p,ListenerLeakError as _,ListenerRefusalError as M,MicrotaskEmitter as R,PauseableEmitter as E,Relay as k,createEventDeliveryQueue as W}from"../../common/event.js";import{DisposableStore as S,isDisposable as x,setDisposableTracker as L,DisposableTracker as C}from"../../common/lifecycle.js";import{observableValue as $,transaction as N}from"../../common/observable.js";import{MicrotaskDelay as O}from"../../common/symbols.js";import{runWithFakedTimers as y}from"./timeTravelScheduler.js";import{ensureNoDisposablesAreLeakedInTestSuite as v}from"./utils.js";var m;(e=>{class i{count=0;reset(){this.count=0}onEvent(){this.count+=1}}e.EventCounter=i;class n{_onDidChange=new a;onDidChange=this._onDidChange.event;setText(s){this._onDidChange.fire(s)}dispose(){this._onDidChange.dispose()}}e.Document3=n})(m||={}),suite("Event utils dispose",function(){const i=v();let n=new C;function e(t){if(Array.isArray(t)){const s=new Set(t),d=n.getTrackedDisposables();r.strictEqual(d.length,t.length);for(const o of d)r.ok(s.has(o))}else r.strictEqual(n.getTrackedDisposables().length,t)}setup(()=>{n=new C,L(n)}),teardown(function(){L(null)}),test("no leak with snapshot-utils",function(){const t=new S,s=i.add(new a),d=c.filter(s.event,f=>f%2===0,t);e(1);let o=0;const u=d(f=>o+=f);r.ok(x(u)),e(3),s.dispose(),t.dispose(),e([u])}),test("no leak with debounce-util",function(){const t=new S,s=i.add(new a),d=c.debounce(s.event,f=>0,void 0,void 0,void 0,void 0,t);e(1);let o=0;const u=d(f=>o+=f);r.ok(x(u)),e(3),s.dispose(),t.dispose(),e([u])})}),suite("Event",function(){const i=v(),n=new m.EventCounter;setup(()=>n.reset()),test("Emitter plain",function(){const e=i.add(new m.Document3),t=e.onDidChange(n.onEvent,n);e.setText("far"),e.setText("boo"),t.dispose(),e.setText("boo"),r.strictEqual(n.count,2)}),test("Emitter duplicate functions",()=>{const e=[],t=u=>e.push(`a${u}`),s=u=>e.push(`b${u}`),d=i.add(new a);i.add(d.event(t)),i.add(d.event(s));const o=d.event(t);d.fire("1"),r.deepStrictEqual(e,["a1","b1","a1"]),o.dispose(),e.length=0,d.fire("2"),r.deepStrictEqual(e,["a2","b2"])}),test("Emitter, dispose listener during emission",()=>{for(let e=1;e<4;e++){const t=i.add(new a),s=[],d=Array.from({length:25},(o,u)=>i.add(t.event(()=>{u%e===0&&d[u].dispose(),s.push(u)})));t.fire(),r.deepStrictEqual(s,Array.from({length:25},(o,u)=>u))}}),test("Emitter, dispose emitter during emission",()=>{const e=i.add(new a),t=[],s=Array.from({length:25},(d,o)=>i.add(e.event(()=>{o===10&&e.dispose(),t.push(o)})));e.fire(),s.forEach(d=>d.dispose()),r.deepStrictEqual(t,Array.from({length:11},(d,o)=>o))}),test("Emitter, shared delivery queue",()=>{const e=W(),t=i.add(new a({deliveryQueue:e})),s=i.add(new a({deliveryQueue:e})),d=[];i.add(t.event(o=>{d.push(`${o}a`),o===1&&s.fire(2)})),i.add(t.event(o=>{d.push(`${o}b`)})),i.add(s.event(o=>{d.push(`${o}c`),t.dispose()})),i.add(s.event(o=>{d.push(`${o}d`)})),t.fire(1),r.deepStrictEqual(d,["1a","1b","2c","2d"])}),test("Emitter, handles removal during 3",()=>{const e=g(),t=g(),s=i.add(new a);i.add(s.event(e));const d=s.event(()=>{d.dispose()});i.add(s.event(t)),s.fire("foo"),r.deepStrictEqual(t.args,[["foo"]]),r.deepStrictEqual(e.args,[["foo"]])}),test("Emitter, handles removal during 2",()=>{const e=g(),t=i.add(new a);i.add(t.event(e));const s=t.event(()=>{s.dispose()});t.fire("foo"),r.deepStrictEqual(e.args,[["foo"]])}),test("Emitter, bucket",function(){const e=[],t=i.add(new m.Document3),s=t.onDidChange(n.onEvent,n,e);for(t.setText("far"),t.setText("boo");e.length;)e.pop().dispose();t.setText("boo"),s.dispose(),t.setText("boo"),r.strictEqual(n.count,2)}),test("Emitter, store",function(){const e=i.add(new S),t=i.add(new m.Document3),s=t.onDidChange(n.onEvent,n,e);t.setText("far"),t.setText("boo"),e.clear(),t.setText("boo"),s.dispose(),t.setText("boo"),r.strictEqual(n.count,2)}),test("onFirstAdd|onLastRemove",()=>{let e=0,t=0;const s=i.add(new a({onWillAddFirstListener(){e+=1},onDidRemoveLastListener(){t+=1}}));r.strictEqual(e,0),r.strictEqual(t,0);let d=i.add(s.event(function(){}));const o=i.add(s.event(function(){}));r.strictEqual(e,1),r.strictEqual(t,0),d.dispose(),r.strictEqual(e,1),r.strictEqual(t,0),o.dispose(),r.strictEqual(e,1),r.strictEqual(t,1),d=i.add(s.event(function(){})),r.strictEqual(e,2),r.strictEqual(t,1)}),test("onWillRemoveListener",()=>{let e=0;const t=i.add(new a({onWillRemoveListener(){e+=1}}));r.strictEqual(e,0);let s=i.add(t.event(function(){}));r.strictEqual(e,0),s.dispose(),r.strictEqual(e,1),s=i.add(t.event(function(){})),r.strictEqual(e,1)}),test("throwingListener",()=>{const e=T.getUnexpectedErrorHandler();q(()=>null);try{const t=i.add(new a);let s=!1;i.add(t.event(function(){throw 9})),i.add(t.event(function(){s=!0})),t.fire(void 0),r.strictEqual(s,!0)}finally{q(e)}}),test("throwingListener (custom handler)",()=>{const e=[],t=i.add(new a({onListenerError(d){e.push(d)}}));let s=!1;i.add(t.event(function(){throw 9})),i.add(t.event(function(){s=!0})),t.fire(void 0),r.strictEqual(s,!0),r.deepStrictEqual(e,[9])}),test("throw ListenerLeakError",()=>{const e=new S,t=[],s=i.add(new a({onListenerError(u){t.push(u)},leakWarningThreshold:3}));for(let u=0;u<11;u++)s.event(()=>{},void 0,e);r.deepStrictEqual(t.length,5);const[d,o]=A(t);r.ok(o instanceof M);for(const u of d)r.ok(u instanceof _);e.dispose()}),test("reusing event function and context",function(){let e=0;function t(){e+=1}const s={},d=i.add(new a),o=d.event(t,s),u=d.event(t,s);d.fire(void 0),r.strictEqual(e,2),o.dispose(),d.fire(void 0),r.strictEqual(e,3),u.dispose(),d.fire(void 0),r.strictEqual(e,3)}),test("DebounceEmitter",async function(){return y({},async function(){let e=0,t=0;const s=new U({merge:o=>(e+=1,o.reduce((u,f)=>u+f))});i.add(s.event(o=>{t=o}));const d=c.toPromise(s.event);s.fire(1),s.fire(2),await d,r.strictEqual(e,1),r.strictEqual(t,3)})}),test("Microtask Emitter",e=>{let t=0;r.strictEqual(t,0);const s=new R,d=s.event(()=>{t++});s.fire(),r.strictEqual(t,0),s.fire(),r.strictEqual(t,0),setTimeout(()=>{r.strictEqual(t,3),e()},0),queueMicrotask(()=>{r.strictEqual(t,2),t++,d.dispose()})}),test("Emitter - In Order Delivery",function(){const e=i.add(new a),t=[];i.add(e.event(function(d){d==="e1"&&(e.fire("e2"),r.deepStrictEqual(t,["e1","e2"]))})),i.add(e.event(function(d){t.push(d)})),e.fire("e1"),r.deepStrictEqual(t,["e1","e2"])}),test("Emitter, - In Order Delivery 3x",function(){const e=i.add(new a),t=[];i.add(e.event(function(d){d==="e2"&&(e.fire("e3"),r.deepStrictEqual(t,["e1","e2","e3"]))})),i.add(e.event(function(d){d==="e1"&&(e.fire("e2"),r.deepStrictEqual(t,["e1","e2","e3"]))})),i.add(e.event(function(d){t.push(d)})),e.fire("e1"),r.deepStrictEqual(t,["e1","e2","e3"])}),test("Cannot read property '_actual' of undefined #142204",function(){i.add(new a).event(()=>{}).dispose.call(void 0)})}),suite("AsyncEmitter",function(){const i=v();test("event has waitUntil-function",async function(){const n=new h;i.add(n.event(e=>{r.strictEqual(e.foo,!0),r.strictEqual(e.bar,1),r.strictEqual(typeof e.waitUntil,"function")})),n.fireAsync({foo:!0,bar:1},b.None),n.dispose()}),test("sequential delivery",async function(){return y({},async function(){let n=0;const e=new h;i.add(e.event(t=>{t.waitUntil(l(10).then(s=>{r.strictEqual(n,0),n+=1}))})),i.add(e.event(t=>{t.waitUntil(l(1).then(s=>{r.strictEqual(n,1),n+=1}))})),await e.fireAsync({foo:!0},b.None),r.strictEqual(n,2)})}),test("sequential, in-order delivery",async function(){return y({},async function(){const n=[];let e=!1;const t=new h;i.add(t.event(s=>{s.waitUntil(l(10).then(async d=>{s.foo===1&&(await t.fireAsync({foo:2},b.None),r.deepStrictEqual(n,[1,2]),e=!0)}))})),i.add(t.event(s=>{n.push(s.foo),s.waitUntil(l(7))})),await t.fireAsync({foo:1},b.None),r.ok(e)})}),test("catch errors",async function(){const n=T.getUnexpectedErrorHandler();q(()=>null);let e=0;const t=new h;i.add(t.event(s=>{e+=1,s.waitUntil(new Promise((d,o)=>o(new Error)))})),i.add(t.event(s=>{e+=1,s.waitUntil(l(10)),s.waitUntil(l(20).then(()=>e++))})),await t.fireAsync({foo:!0},b.None).then(()=>{r.strictEqual(e,3)}).catch(s=>{console.log(s),r.ok(!1)}),q(n)})}),suite("PausableEmitter",function(){const i=v();test("basic",function(){const n=[],e=i.add(new E);i.add(e.event(t=>n.push(t))),e.fire(1),e.fire(2),r.deepStrictEqual(n,[1,2])}),test("pause/resume - no merge",function(){const n=[],e=i.add(new E);i.add(e.event(t=>n.push(t))),e.fire(1),e.fire(2),r.deepStrictEqual(n,[1,2]),e.pause(),e.fire(3),e.fire(4),r.deepStrictEqual(n,[1,2]),e.resume(),r.deepStrictEqual(n,[1,2,3,4]),e.fire(5),r.deepStrictEqual(n,[1,2,3,4,5])}),test("pause/resume - merge",function(){const n=[],e=i.add(new E({merge:t=>t.reduce((s,d)=>s+d,0)}));i.add(e.event(t=>n.push(t))),e.fire(1),e.fire(2),r.deepStrictEqual(n,[1,2]),e.pause(),e.fire(3),e.fire(4),r.deepStrictEqual(n,[1,2]),e.resume(),r.deepStrictEqual(n,[1,2,7]),e.fire(5),r.deepStrictEqual(n,[1,2,7,5])}),test("double pause/resume",function(){const n=[],e=i.add(new E);i.add(e.event(t=>n.push(t))),e.fire(1),e.fire(2),r.deepStrictEqual(n,[1,2]),e.pause(),e.pause(),e.fire(3),e.fire(4),r.deepStrictEqual(n,[1,2]),e.resume(),r.deepStrictEqual(n,[1,2]),e.resume(),r.deepStrictEqual(n,[1,2,3,4]),e.resume(),r.deepStrictEqual(n,[1,2,3,4])}),test("resume, no pause",function(){const n=[],e=i.add(new E);i.add(e.event(t=>n.push(t))),e.fire(1),e.fire(2),r.deepStrictEqual(n,[1,2]),e.resume(),e.fire(3),r.deepStrictEqual(n,[1,2,3])}),test("nested pause",function(){const n=[],e=i.add(new E);let t=!0;i.add(e.event(s=>{n.push(s),t&&(e.pause(),t=!1)})),i.add(e.event(s=>{n.push(s)})),e.pause(),e.fire(1),e.fire(2),r.deepStrictEqual(n,[]),e.resume(),r.deepStrictEqual(n,[1,1]),e.resume(),r.deepStrictEqual(n,[1,1,2,2]),e.fire(3),r.deepStrictEqual(n,[1,1,2,2,3,3])}),test("empty pause with merge",function(){const n=[],e=i.add(new E({merge:t=>t[0]}));i.add(e.event(t=>n.push(1))),e.pause(),e.resume(),r.deepStrictEqual(n,[])})}),suite("Event utils - ensureNoDisposablesAreLeakedInTestSuite",function(){v(),test("fromObservable",function(){const i=$("test",12),n=c.fromObservable(i),e=[],t=n(s=>{e.push(s)});i.set(3,void 0),i.set(13,void 0),i.set(3,void 0),i.set(33,void 0),i.set(1,void 0),N(s=>{i.set(334,s),i.set(99,s)}),r.deepStrictEqual(e,[3,13,3,33,1,99]),t.dispose()})}),suite("Event utils",()=>{const i=v();suite("EventBufferer",()=>{test("should not buffer when not wrapped",()=>{const n=new D,e=new m.EventCounter,t=i.add(new a),d=n.wrapEvent(t.event)(e.onEvent,e);r.strictEqual(e.count,0),t.fire(),r.strictEqual(e.count,1),t.fire(),r.strictEqual(e.count,2),t.fire(),r.strictEqual(e.count,3),d.dispose()}),test("should buffer when wrapped",()=>{const n=new D,e=new m.EventCounter,t=i.add(new a),d=n.wrapEvent(t.event)(e.onEvent,e);r.strictEqual(e.count,0),t.fire(),r.strictEqual(e.count,1),n.bufferEvents(()=>{t.fire(),r.strictEqual(e.count,1),t.fire(),r.strictEqual(e.count,1)}),r.strictEqual(e.count,3),t.fire(),r.strictEqual(e.count,4),d.dispose()}),test("once",()=>{const n=i.add(new a);let e=0,t=0,s=0;const d=n.event(()=>e++),o=c.once(n.event)(()=>t++),u=c.once(n.event)(()=>s++);r.strictEqual(e,0),r.strictEqual(t,0),r.strictEqual(s,0),u.dispose(),n.fire(),r.strictEqual(e,1),r.strictEqual(t,1),r.strictEqual(s,0),n.fire(),r.strictEqual(e,2),r.strictEqual(t,1),r.strictEqual(s,0),d.dispose(),o.dispose()})}),suite("buffer",()=>{test("should buffer events",()=>{const n=[],e=i.add(new a),t=e.event,s=c.buffer(t);e.fire(1),e.fire(2),e.fire(3),r.deepStrictEqual(n,[]);const d=s(o=>n.push(o));r.deepStrictEqual(n,[1,2,3]),e.fire(4),r.deepStrictEqual(n,[1,2,3,4]),d.dispose(),e.fire(5),r.deepStrictEqual(n,[1,2,3,4])}),test("should buffer events on next tick",async()=>{const n=[],e=i.add(new a),t=e.event,s=c.buffer(t,!0);e.fire(1),e.fire(2),e.fire(3),r.deepStrictEqual(n,[]);const d=s(o=>n.push(o));r.deepStrictEqual(n,[]),await l(10),e.fire(4),r.deepStrictEqual(n,[1,2,3,4]),d.dispose(),e.fire(5),r.deepStrictEqual(n,[1,2,3,4])}),test("should fire initial buffer events",()=>{const n=[],e=i.add(new a),t=e.event,s=c.buffer(t,!1,[-2,-1,0]);e.fire(1),e.fire(2),e.fire(3),r.deepStrictEqual(n,[]),i.add(s(d=>n.push(d))),r.deepStrictEqual(n,[-2,-1,0,1,2,3])})}),suite("EventMultiplexer",()=>{test("works",()=>{const n=[],e=new p;i.add(e.event(s=>n.push(s)));const t=i.add(new a);i.add(e.add(t.event)),r.deepStrictEqual(n,[]),t.fire(0),r.deepStrictEqual(n,[0])}),test("multiplexer dispose works",()=>{const n=[],e=new p;i.add(e.event(s=>n.push(s)));const t=i.add(new a);i.add(e.add(t.event)),r.deepStrictEqual(n,[]),t.fire(0),r.deepStrictEqual(n,[0]),e.dispose(),r.deepStrictEqual(n,[0]),t.fire(0),r.deepStrictEqual(n,[0])}),test("event dispose works",()=>{const n=[],e=new p;i.add(e.event(s=>n.push(s)));const t=i.add(new a);i.add(e.add(t.event)),r.deepStrictEqual(n,[]),t.fire(0),r.deepStrictEqual(n,[0]),t.dispose(),r.deepStrictEqual(n,[0]),t.fire(0),r.deepStrictEqual(n,[0])}),test("mutliplexer event dispose works",()=>{const n=[],e=new p;i.add(e.event(d=>n.push(d)));const t=i.add(new a),s=e.add(t.event);r.deepStrictEqual(n,[]),t.fire(0),r.deepStrictEqual(n,[0]),s.dispose(),r.deepStrictEqual(n,[0]),t.fire(0),r.deepStrictEqual(n,[0])}),test("hot start works",()=>{const n=[],e=new p;i.add(e.event(o=>n.push(o)));const t=i.add(new a);i.add(e.add(t.event));const s=i.add(new a);i.add(e.add(s.event));const d=i.add(new a);i.add(e.add(d.event)),t.fire(1),s.fire(2),d.fire(3),r.deepStrictEqual(n,[1,2,3])}),test("cold start works",()=>{const n=[],e=new p,t=i.add(new a);i.add(e.add(t.event));const s=i.add(new a);i.add(e.add(s.event));const d=i.add(new a);i.add(e.add(d.event)),i.add(e.event(o=>n.push(o))),t.fire(1),s.fire(2),d.fire(3),r.deepStrictEqual(n,[1,2,3])}),test("late add works",()=>{const n=[],e=new p,t=i.add(new a);i.add(e.add(t.event));const s=i.add(new a);i.add(e.add(s.event)),i.add(e.event(o=>n.push(o))),t.fire(1),s.fire(2);const d=i.add(new a);i.add(e.add(d.event)),d.fire(3),r.deepStrictEqual(n,[1,2,3])}),test("add dispose works",()=>{const n=[],e=new p,t=i.add(new a);i.add(e.add(t.event));const s=i.add(new a);i.add(e.add(s.event)),i.add(e.event(u=>n.push(u))),t.fire(1),s.fire(2);const d=i.add(new a),o=e.add(d.event);d.fire(3),r.deepStrictEqual(n,[1,2,3]),o.dispose(),d.fire(4),r.deepStrictEqual(n,[1,2,3]),s.fire(4),t.fire(5),r.deepStrictEqual(n,[1,2,3,4,5])})}),suite("DynamicListEventMultiplexer",()=>{let n,e;const t=[];class s{onTestEventEmitter=i.add(new a);onTestEvent=this.onTestEventEmitter.event}let d,o;setup(()=>{n=i.add(new a),e=i.add(new a),d=[new s,new s];for(const[u,f]of d.entries())i.add(f.onTestEvent(I=>`${u}:${I}`));o=new P(d,n.event,e.event,u=>u.onTestEvent),i.add(o.event(u=>t.push(u))),t.length=0}),teardown(()=>o.dispose()),test("should fire events for initial items",()=>{d[0].onTestEventEmitter.fire(1),d[1].onTestEventEmitter.fire(2),d[0].onTestEventEmitter.fire(3),d[1].onTestEventEmitter.fire(4),r.deepStrictEqual(t,[1,2,3,4])}),test("should fire events for added items",()=>{const u=new s;n.fire(u),u.onTestEventEmitter.fire(1),d[0].onTestEventEmitter.fire(2),d[1].onTestEventEmitter.fire(3),u.onTestEventEmitter.fire(4),r.deepStrictEqual(t,[1,2,3,4])}),test("should not fire events for removed items",()=>{e.fire(d[0]),d[0].onTestEventEmitter.fire(1),d[1].onTestEventEmitter.fire(2),d[0].onTestEventEmitter.fire(3),d[1].onTestEventEmitter.fire(4),r.deepStrictEqual(t,[2,4])})}),test("latch",()=>{const n=i.add(new a),e=c.latch(n.event),t=[],s=i.add(e(d=>t.push(d)));r.deepStrictEqual(t,[]),n.fire(1),r.deepStrictEqual(t,[1]),n.fire(2),r.deepStrictEqual(t,[1,2]),n.fire(2),r.deepStrictEqual(t,[1,2]),n.fire(1),r.deepStrictEqual(t,[1,2,1]),n.fire(1),r.deepStrictEqual(t,[1,2,1]),n.fire(3),r.deepStrictEqual(t,[1,2,1,3]),n.fire(3),r.deepStrictEqual(t,[1,2,1,3]),n.fire(3),r.deepStrictEqual(t,[1,2,1,3]),s.dispose()}),test("dispose is reentrant",()=>{const n=i.add(new a({onDidRemoveLastListener:()=>{n.dispose()}}));n.event(()=>{}).dispose()}),suite("fromPromise",()=>{test("not yet resolved",async function(){return new Promise(n=>{let e=new w;i.add(c.fromPromise(e.p)(t=>{r.strictEqual(t,1),e=new w,i.add(c.fromPromise(e.p)(()=>{n()})),e.error(void 0)})),e.complete(1)})}),test("already resolved",async function(){return new Promise(n=>{let e=new w;e.complete(1),i.add(c.fromPromise(e.p)(t=>{r.strictEqual(t,1),e=new w,e.error(void 0),i.add(c.fromPromise(e.p)(()=>{n()}))}))})})}),suite("Relay",()=>{test("should input work",()=>{const n=i.add(new a),e=i.add(new a),t=new k,s=[],d=u=>s.push(u),o=t.event(d);n.fire(1),r.deepStrictEqual(s,[]),t.input=n.event,n.fire(2),r.deepStrictEqual(s,[2]),t.input=e.event,n.fire(3),e.fire(4),r.deepStrictEqual(s,[2,4]),o.dispose(),n.fire(5),e.fire(6),r.deepStrictEqual(s,[2,4])}),test("should Relay dispose work",()=>{const n=i.add(new a),e=i.add(new a),t=new k,s=[],d=o=>s.push(o);i.add(t.event(d)),n.fire(1),r.deepStrictEqual(s,[]),t.input=n.event,n.fire(2),r.deepStrictEqual(s,[2]),t.input=e.event,n.fire(3),e.fire(4),r.deepStrictEqual(s,[2,4]),t.dispose(),n.fire(5),e.fire(6),r.deepStrictEqual(s,[2,4])})}),suite("accumulate",()=>{test("should not fire after a listener is disposed with undefined or []",async()=>{const n=i.add(new a),e=n.event,t=c.accumulate(e,0),s=[],d=[],o=i.add(t(u=>s.push(u)));i.add(t(u=>d.push(u))),n.fire(1),await l(1),r.deepStrictEqual(s,[[1]]),r.deepStrictEqual(d,[[1]]),o.dispose(),await l(1),r.deepStrictEqual(s,[[1]]),r.deepStrictEqual(d,[[1]],"should not fire after a listener is disposed with undefined or []")}),test("should accumulate a single event",async()=>{const n=i.add(new a),e=n.event,t=c.accumulate(e,0),s=await new Promise(o=>{i.add(t(o)),n.fire(1)});r.deepStrictEqual(s,[1]);const d=await new Promise(o=>{i.add(t(o)),n.fire(2)});r.deepStrictEqual(d,[2])}),test("should accumulate multiple events",async()=>{const n=i.add(new a),e=n.event,t=c.accumulate(e,0),s=await new Promise(o=>{i.add(t(o)),n.fire(1),n.fire(2),n.fire(3)});r.deepStrictEqual(s,[1,2,3]);const d=await new Promise(o=>{i.add(t(o)),n.fire(4),n.fire(5),n.fire(6),n.fire(7),n.fire(8)});r.deepStrictEqual(d,[4,5,6,7,8])})}),suite("debounce",()=>{test("simple",function(n){const e=i.add(new m.Document3),t=c.debounce(e.onDidChange,(d,o)=>(d?d.indexOf(o)<0&&d.push(o):d=[o],d),10);let s=0;i.add(t(d=>{s++,r.ok(d,"was not expecting keys."),s===1?(e.setText("4"),r.deepStrictEqual(d,["1","2","3"])):s===2&&(r.deepStrictEqual(d,["4"]),n())})),e.setText("1"),e.setText("2"),e.setText("3")}),test("microtask",function(n){const e=i.add(new m.Document3),t=c.debounce(e.onDidChange,(d,o)=>(d?d.indexOf(o)<0&&d.push(o):d=[o],d),O);let s=0;i.add(t(d=>{s++,r.ok(d,"was not expecting keys."),s===1?(e.setText("4"),r.deepStrictEqual(d,["1","2","3"])):s===2&&(r.deepStrictEqual(d,["4"]),n())})),e.setText("1"),e.setText("2"),e.setText("3")}),test("leading",async function(){const n=i.add(new a),e=c.debounce(n.event,(s,d)=>d,0,!0);let t=0;i.add(e(()=>{t++})),n.fire(),await l(1),r.strictEqual(t,1)}),test("leading (2)",async function(){const n=i.add(new a),e=c.debounce(n.event,(s,d)=>d,0,!0);let t=0;i.add(e(()=>{t++})),n.fire(),n.fire(),n.fire(),await l(1),r.strictEqual(t,2)}),test("leading reset",async function(){const n=i.add(new a),e=c.debounce(n.event,(s,d)=>s?s+1:1,0,!0),t=[];i.add(e(s=>t.push(s))),n.fire(1),n.fire(1),await l(1),r.deepStrictEqual(t,[1,1])}),test("should not flush events when a listener is disposed",async()=>{const n=i.add(new a),e=c.debounce(n.event,(d,o)=>d?d+1:1,0),t=[],s=i.add(e(d=>t.push(d)));n.fire(1),s.dispose(),n.fire(1),await l(1),r.deepStrictEqual(t,[])}),test("flushOnListenerRemove - should flush events when a listener is disposed",async()=>{const n=i.add(new a),e=c.debounce(n.event,(d,o)=>d?d+1:1,0,void 0,!0),t=[],s=i.add(e(d=>t.push(d)));n.fire(1),s.dispose(),n.fire(1),await l(1),r.deepStrictEqual(t,[1],"should fire with the first event, not the second (after listener dispose)")}),test("should flush events when the emitter is disposed",async()=>{const n=i.add(new a),e=c.debounce(n.event,(s,d)=>s?s+1:1,0),t=[];i.add(e(s=>t.push(s))),n.fire(1),n.dispose(),await l(1),r.deepStrictEqual(t,[1])})}),suite("chain2",()=>{let n,e;setup(()=>{n=i.add(new a),e=[]}),test("maps",()=>{const t=c.chain(n.event,s=>s.map(d=>d*2));i.add(t(s=>e.push(s))),n.fire(1),n.fire(2),n.fire(3),r.deepStrictEqual(e,[2,4,6])}),test("filters",()=>{const t=c.chain(n.event,s=>s.filter(d=>d%2===0));i.add(t(s=>e.push(s))),n.fire(1),n.fire(2),n.fire(3),n.fire(4),r.deepStrictEqual(e,[2,4])}),test("reduces",()=>{const t=c.chain(n.event,s=>s.reduce((d,o)=>d+o,0));i.add(t(s=>e.push(s))),n.fire(1),n.fire(2),n.fire(3),n.fire(4),r.deepStrictEqual(e,[1,3,6,10])}),test("latches",()=>{const t=c.chain(n.event,s=>s.latch());i.add(t(s=>e.push(s))),n.fire(1),n.fire(1),n.fire(2),n.fire(2),n.fire(3),n.fire(3),n.fire(1),r.deepStrictEqual(e,[1,2,3,1])}),test("does everything",()=>{const t=c.chain(n.event,s=>s.filter(d=>d%2===0).map(d=>d*2).reduce((d,o)=>d+o,0).latch());i.add(t(s=>e.push(s))),n.fire(1),n.fire(2),n.fire(3),n.fire(4),n.fire(0),r.deepStrictEqual(e,[4,12])})})});
