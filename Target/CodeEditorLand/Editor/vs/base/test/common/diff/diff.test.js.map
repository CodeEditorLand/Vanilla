{
  "version": 3,
  "sources": ["../../../../../../../../Dependency/CodeEditorLand/Editor/Source/vs/base/test/common/diff/diff.test.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport assert from 'assert';\nimport { IDiffChange, LcsDiff, StringDiffSequence } from '../../../common/diff/diff.js';\nimport { ensureNoDisposablesAreLeakedInTestSuite } from '../utils.js';\n\nfunction createArray<T>(length: number, value: T): T[] {\n\tconst r: T[] = [];\n\tfor (let i = 0; i < length; i++) {\n\t\tr[i] = value;\n\t}\n\treturn r;\n}\n\nfunction maskBasedSubstring(str: string, mask: boolean[]): string {\n\tlet r = '';\n\tfor (let i = 0; i < str.length; i++) {\n\t\tif (mask[i]) {\n\t\t\tr += str.charAt(i);\n\t\t}\n\t}\n\treturn r;\n}\n\nfunction assertAnswer(originalStr: string, modifiedStr: string, changes: IDiffChange[], answerStr: string, onlyLength: boolean = false): void {\n\tconst originalMask = createArray(originalStr.length, true);\n\tconst modifiedMask = createArray(modifiedStr.length, true);\n\n\tlet i, j, change;\n\tfor (i = 0; i < changes.length; i++) {\n\t\tchange = changes[i];\n\n\t\tif (change.originalLength) {\n\t\t\tfor (j = 0; j < change.originalLength; j++) {\n\t\t\t\toriginalMask[change.originalStart + j] = false;\n\t\t\t}\n\t\t}\n\n\t\tif (change.modifiedLength) {\n\t\t\tfor (j = 0; j < change.modifiedLength; j++) {\n\t\t\t\tmodifiedMask[change.modifiedStart + j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst originalAnswer = maskBasedSubstring(originalStr, originalMask);\n\tconst modifiedAnswer = maskBasedSubstring(modifiedStr, modifiedMask);\n\n\tif (onlyLength) {\n\t\tassert.strictEqual(originalAnswer.length, answerStr.length);\n\t\tassert.strictEqual(modifiedAnswer.length, answerStr.length);\n\t} else {\n\t\tassert.strictEqual(originalAnswer, answerStr);\n\t\tassert.strictEqual(modifiedAnswer, answerStr);\n\t}\n}\n\nfunction lcsInnerTest(originalStr: string, modifiedStr: string, answerStr: string, onlyLength: boolean = false): void {\n\tconst diff = new LcsDiff(new StringDiffSequence(originalStr), new StringDiffSequence(modifiedStr));\n\tconst changes = diff.ComputeDiff(false).changes;\n\tassertAnswer(originalStr, modifiedStr, changes, answerStr, onlyLength);\n}\n\nfunction stringPower(str: string, power: number): string {\n\tlet r = str;\n\tfor (let i = 0; i < power; i++) {\n\t\tr += r;\n\t}\n\treturn r;\n}\n\nfunction lcsTest(originalStr: string, modifiedStr: string, answerStr: string) {\n\tlcsInnerTest(originalStr, modifiedStr, answerStr);\n\tfor (let i = 2; i <= 5; i++) {\n\t\tlcsInnerTest(stringPower(originalStr, i), stringPower(modifiedStr, i), stringPower(answerStr, i), true);\n\t}\n}\n\nsuite('Diff', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('LcsDiff - different strings tests', function () {\n\t\tthis.timeout(10000);\n\t\tlcsTest('heLLo world', 'hello orlando', 'heo orld');\n\t\tlcsTest('abcde', 'acd', 'acd'); // simple\n\t\tlcsTest('abcdbce', 'bcede', 'bcde'); // skip\n\t\tlcsTest('abcdefgabcdefg', 'bcehafg', 'bceafg'); // long\n\t\tlcsTest('abcde', 'fgh', ''); // no match\n\t\tlcsTest('abcfabc', 'fabc', 'fabc');\n\t\tlcsTest('0azby0', '9axbzby9', 'azby');\n\t\tlcsTest('0abc00000', '9a1b2c399999', 'abc');\n\n\t\tlcsTest('fooBar', 'myfooBar', 'fooBar'); // all insertions\n\t\tlcsTest('fooBar', 'fooMyBar', 'fooBar'); // all insertions\n\t\tlcsTest('fooBar', 'fooBar', 'fooBar'); // identical sequences\n\t});\n});\n\nsuite('Diff - Ported from VS', () => {\n\tensureNoDisposablesAreLeakedInTestSuite();\n\n\ttest('using continue processing predicate to quit early', function () {\n\t\tconst left = 'abcdef';\n\t\tconst right = 'abxxcyyydzzzzezzzzzzzzzzzzzzzzzzzzf';\n\n\t\t// We use a long non-matching portion at the end of the right-side string, so the backwards tracking logic\n\t\t// doesn't get there first.\n\t\tlet predicateCallCount = 0;\n\n\t\tlet diff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert.strictEqual(predicateCallCount, 0);\n\n\t\t\tpredicateCallCount++;\n\n\t\t\tassert.strictEqual(leftIndex, 1);\n\n\t\t\t// cancel processing\n\t\t\treturn false;\n\t\t});\n\t\tlet changes = diff.ComputeDiff(true).changes;\n\n\t\tassert.strictEqual(predicateCallCount, 1);\n\n\t\t// Doesn't include 'c', 'd', or 'e', since we quit on the first request\n\t\tassertAnswer(left, right, changes, 'abf');\n\n\n\n\t\t// Cancel after the first match ('c')\n\t\tdiff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert(longestMatchSoFar <= 1); // We never see a match of length > 1\n\n\t\t\t// Continue processing as long as there hasn't been a match made.\n\t\t\treturn longestMatchSoFar < 1;\n\t\t});\n\t\tchanges = diff.ComputeDiff(true).changes;\n\n\t\tassertAnswer(left, right, changes, 'abcf');\n\n\n\n\t\t// Cancel after the second match ('d')\n\t\tdiff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert(longestMatchSoFar <= 2); // We never see a match of length > 2\n\n\t\t\t// Continue processing as long as there hasn't been a match made.\n\t\t\treturn longestMatchSoFar < 2;\n\t\t});\n\t\tchanges = diff.ComputeDiff(true).changes;\n\n\t\tassertAnswer(left, right, changes, 'abcdf');\n\n\n\n\t\t// Cancel *one iteration* after the second match ('d')\n\t\tlet hitSecondMatch = false;\n\t\tdiff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert(longestMatchSoFar <= 2); // We never see a match of length > 2\n\n\t\t\tconst hitYet = hitSecondMatch;\n\t\t\thitSecondMatch = longestMatchSoFar > 1;\n\t\t\t// Continue processing as long as there hasn't been a match made.\n\t\t\treturn !hitYet;\n\t\t});\n\t\tchanges = diff.ComputeDiff(true).changes;\n\n\t\tassertAnswer(left, right, changes, 'abcdf');\n\n\n\n\t\t// Cancel after the third and final match ('e')\n\t\tdiff = new LcsDiff(new StringDiffSequence(left), new StringDiffSequence(right), function (leftIndex, longestMatchSoFar) {\n\t\t\tassert(longestMatchSoFar <= 3); // We never see a match of length > 3\n\n\t\t\t// Continue processing as long as there hasn't been a match made.\n\t\t\treturn longestMatchSoFar < 3;\n\t\t});\n\t\tchanges = diff.ComputeDiff(true).changes;\n\n\t\tassertAnswer(left, right, changes, 'abcdef');\n\t});\n});\n"],
  "mappings": "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",
  "names": []
}
