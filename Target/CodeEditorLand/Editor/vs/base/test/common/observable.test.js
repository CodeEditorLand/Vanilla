import s from"assert";import{Emitter as A,Event as C}from"../../common/event.js";import{DisposableStore as f}from"../../common/lifecycle.js";import{autorun as b,derived as m,observableFromEvent as S,observableValue as p,transaction as g,keepObserved as q,waitForState as E,autorunHandleChanges as $,observableSignal as D}from"../../common/observable.js";import{BaseObservable as w}from"../../common/observableInternal/base.js";import{derivedDisposable as R}from"../../common/observableInternal/derived.js";import{ensureNoDisposablesAreLeakedInTestSuite as T}from"./utils.js";import{setUnexpectedErrorHandler as h}from"../../common/errors.js";suite("observables",()=>{const c=T();suite("tutorial",()=>{test("observable + autorun",()=>{const e=new u,t=p("myObservable",0);c.add(b(n=>{e.log(`myAutorun.run(myObservable: ${t.read(n)})`)})),s.deepStrictEqual(e.getAndClearEntries(),["myAutorun.run(myObservable: 0)"]),t.set(1,void 0),s.deepStrictEqual(e.getAndClearEntries(),["myAutorun.run(myObservable: 1)"]),t.set(1,void 0),s.deepStrictEqual(e.getAndClearEntries(),[]),g(n=>{t.set(2,n),s.deepStrictEqual(e.getAndClearEntries(),[]),t.set(3,n),s.deepStrictEqual(e.getAndClearEntries(),[])}),s.deepStrictEqual(e.getAndClearEntries(),["myAutorun.run(myObservable: 3)"])}),test("derived + autorun",()=>{const e=new u,t=p("myObservable1",0),n=p("myObservable2",0),r=m(a=>{const l=t.read(a),d=n.read(a),o=l+d;return e.log(`myDerived.recompute: ${l} + ${d} = ${o}`),o});c.add(b(a=>{e.log(`myAutorun(myDerived: ${r.read(a)})`)})),s.deepStrictEqual(e.getAndClearEntries(),["myDerived.recompute: 0 + 0 = 0","myAutorun(myDerived: 0)"]),t.set(1,void 0),s.deepStrictEqual(e.getAndClearEntries(),["myDerived.recompute: 1 + 0 = 1","myAutorun(myDerived: 1)"]),n.set(1,void 0),s.deepStrictEqual(e.getAndClearEntries(),["myDerived.recompute: 1 + 1 = 2","myAutorun(myDerived: 2)"]),g(a=>{t.set(5,a),s.deepStrictEqual(e.getAndClearEntries(),[]),n.set(5,a),s.deepStrictEqual(e.getAndClearEntries(),[])}),s.deepStrictEqual(e.getAndClearEntries(),["myDerived.recompute: 5 + 5 = 10","myAutorun(myDerived: 10)"]),g(a=>{t.set(6,a),s.deepStrictEqual(e.getAndClearEntries(),[]),n.set(4,a),s.deepStrictEqual(e.getAndClearEntries(),[])}),s.deepStrictEqual(e.getAndClearEntries(),["myDerived.recompute: 6 + 4 = 10"])}),test("read during transaction",()=>{const e=new u,t=p("myObservable1",0),n=p("myObservable2",0),r=m(a=>{const l=t.read(a),d=n.read(a),o=l+d;return e.log(`myDerived.recompute: ${l} + ${d} = ${o}`),o});c.add(b(a=>{e.log(`myAutorun(myDerived: ${r.read(a)})`)})),s.deepStrictEqual(e.getAndClearEntries(),["myDerived.recompute: 0 + 0 = 0","myAutorun(myDerived: 0)"]),g(a=>{t.set(-10,a),s.deepStrictEqual(e.getAndClearEntries(),[]),r.get(),s.deepStrictEqual(e.getAndClearEntries(),["myDerived.recompute: -10 + 0 = -10"]),n.set(10,a),s.deepStrictEqual(e.getAndClearEntries(),[])}),s.deepStrictEqual(e.getAndClearEntries(),["myDerived.recompute: -10 + 10 = 0","myAutorun(myDerived: 0)"])}),test("get without observers",()=>{const e=new u,t=p("myObservableValue1",0),n=m(o=>{const i=t.read(o),v=i%3;return e.log(`recompute1: ${i} % 3 = ${v}`),v}),r=m(o=>{const i=n.read(o),v=i*2;return e.log(`recompute2: ${i} * 2 = ${v}`),v}),a=m(o=>{const i=n.read(o),v=i*3;return e.log(`recompute3: ${i} * 3 = ${v}`),v}),l=m(o=>{const i=r.read(o),v=a.read(o),O=i+v;return e.log(`recompute4: ${i} + ${v} = ${O}`),O});s.deepStrictEqual(e.getAndClearEntries(),[]),t.set(1,void 0),s.deepStrictEqual(e.getAndClearEntries(),[]),e.log(`value: ${l.get()}`),s.deepStrictEqual(e.getAndClearEntries(),["recompute1: 1 % 3 = 1","recompute2: 1 * 2 = 2","recompute3: 1 * 3 = 3","recompute4: 2 + 3 = 5","value: 5"]),e.log(`value: ${l.get()}`),s.deepStrictEqual(e.getAndClearEntries(),["recompute1: 1 % 3 = 1","recompute2: 1 * 2 = 2","recompute3: 1 * 3 = 3","recompute4: 2 + 3 = 5","value: 5"]);const d=q(l);e.log(`value: ${l.get()}`),s.deepStrictEqual(e.getAndClearEntries(),["recompute1: 1 % 3 = 1","recompute2: 1 * 2 = 2","recompute3: 1 * 3 = 3","recompute4: 2 + 3 = 5","value: 5"]),e.log(`value: ${l.get()}`),s.deepStrictEqual(e.getAndClearEntries(),["value: 5"]),t.set(2,void 0),s.deepStrictEqual(e.getAndClearEntries(),[]),e.log(`value: ${l.get()}`),s.deepStrictEqual(e.getAndClearEntries(),["recompute1: 2 % 3 = 2","recompute2: 2 * 2 = 4","recompute3: 2 * 3 = 6","recompute4: 4 + 6 = 10","value: 10"]),e.log(`value: ${l.get()}`),s.deepStrictEqual(e.getAndClearEntries(),["value: 10"]),d.dispose(),e.log(`value: ${l.get()}`),s.deepStrictEqual(e.getAndClearEntries(),["recompute1: 2 % 3 = 2","recompute2: 2 * 2 = 4","recompute3: 2 * 3 = 6","recompute4: 4 + 6 = 10","value: 10"]),e.log(`value: ${l.get()}`),s.deepStrictEqual(e.getAndClearEntries(),["recompute1: 2 % 3 = 2","recompute2: 2 * 2 = 4","recompute3: 2 * 3 = 6","recompute4: 4 + 6 = 10","value: 10"])}),test("autorun that receives deltas of signals",()=>{const e=new u,t=D("signal"),n=$({createEmptyChangeSummary:()=>({msgs:[]}),handleChange(r,a){return r.didChange(t)&&a.msgs.push(r.change.msg),!0}},(r,a)=>{t.read(r),e.log("msgs: "+a.msgs.join(", "))});t.trigger(void 0,{msg:"foobar"}),g(r=>{t.trigger(r,{msg:"hello"}),t.trigger(r,{msg:"world"})}),s.deepStrictEqual(e.getAndClearEntries(),["msgs: ","msgs: foobar","msgs: hello, world"]),n.dispose()})}),test("topological order",()=>{const e=new u,t=p("myObservable1",0),n=p("myObservable2",0),r=m(d=>{const o=t.read(d),i=n.read(d),v=o+i;return e.log(`myComputed1.recompute(myObservable1: ${o} + myObservable2: ${i} = ${v})`),v}),a=m(d=>{const o=r.read(d),i=t.read(d),v=n.read(d),O=o+i+v;return e.log(`myComputed2.recompute(myComputed1: ${o} + myObservable1: ${i} + myObservable2: ${v} = ${O})`),O}),l=m(d=>{const o=a.read(d),i=t.read(d),v=n.read(d),O=o+i+v;return e.log(`myComputed3.recompute(myComputed2: ${o} + myObservable1: ${i} + myObservable2: ${v} = ${O})`),O});c.add(b(d=>{e.log(`myAutorun.run(myComputed3: ${l.read(d)})`)})),s.deepStrictEqual(e.getAndClearEntries(),["myComputed1.recompute(myObservable1: 0 + myObservable2: 0 = 0)","myComputed2.recompute(myComputed1: 0 + myObservable1: 0 + myObservable2: 0 = 0)","myComputed3.recompute(myComputed2: 0 + myObservable1: 0 + myObservable2: 0 = 0)","myAutorun.run(myComputed3: 0)"]),t.set(1,void 0),s.deepStrictEqual(e.getAndClearEntries(),["myComputed1.recompute(myObservable1: 1 + myObservable2: 0 = 1)","myComputed2.recompute(myComputed1: 1 + myObservable1: 1 + myObservable2: 0 = 2)","myComputed3.recompute(myComputed2: 2 + myObservable1: 1 + myObservable2: 0 = 3)","myAutorun.run(myComputed3: 3)"]),g(d=>{t.set(2,d),a.get(),s.deepStrictEqual(e.getAndClearEntries(),["myComputed1.recompute(myObservable1: 2 + myObservable2: 0 = 2)","myComputed2.recompute(myComputed1: 2 + myObservable1: 2 + myObservable2: 0 = 4)"]),t.set(3,d),a.get(),s.deepStrictEqual(e.getAndClearEntries(),["myComputed1.recompute(myObservable1: 3 + myObservable2: 0 = 3)","myComputed2.recompute(myComputed1: 3 + myObservable1: 3 + myObservable2: 0 = 6)"])}),s.deepStrictEqual(e.getAndClearEntries(),["myComputed3.recompute(myComputed2: 6 + myObservable1: 3 + myObservable2: 0 = 9)","myAutorun.run(myComputed3: 9)"])}),suite("from event",()=>{function e(){const t=new u;let n=0;const r=new A;let a=0;const l=S(d=>{const o=a++;t.log(`subscribed handler ${o}`);const i=r.event(d);return{dispose:()=>{t.log(`unsubscribed handler ${o}`),i.dispose()}}},()=>(t.log(`compute value ${n}`),n));return{log:t,setValue:d=>{n=d,r.fire()},observable:l}}test("Handle undefined",()=>{const{log:t,setValue:n,observable:r}=e();n(void 0);const a=b(l=>{r.read(l),t.log(`autorun, value: ${r.read(l)}`)});s.deepStrictEqual(t.getAndClearEntries(),["subscribed handler 0","compute value undefined","autorun, value: undefined"]),n(1),s.deepStrictEqual(t.getAndClearEntries(),["compute value 1","autorun, value: 1"]),a.dispose(),s.deepStrictEqual(t.getAndClearEntries(),["unsubscribed handler 0"])}),test("basic",()=>{const{log:t,setValue:n,observable:r}=e(),a=p("shouldReadObservable",!0),l=b(d=>{a.read(d)?(r.read(d),t.log(`autorun, should read: true, value: ${r.read(d)}`)):t.log("autorun, should read: false")});s.deepStrictEqual(t.getAndClearEntries(),["subscribed handler 0","compute value 0","autorun, should read: true, value: 0"]),t.log(`get value: ${r.get()}`),s.deepStrictEqual(t.getAndClearEntries(),["get value: 0"]),n(1),s.deepStrictEqual(t.getAndClearEntries(),["compute value 1","autorun, should read: true, value: 1"]),a.set(!1,void 0),s.deepStrictEqual(t.getAndClearEntries(),["autorun, should read: false","unsubscribed handler 0"]),a.set(!0,void 0),s.deepStrictEqual(t.getAndClearEntries(),["subscribed handler 1","compute value 1","autorun, should read: true, value: 1"]),l.dispose(),s.deepStrictEqual(t.getAndClearEntries(),["unsubscribed handler 1"])}),test("get without observers",()=>{const{log:t,observable:n}=e();s.deepStrictEqual(t.getAndClearEntries(),[]),t.log(`get value: ${n.get()}`),s.deepStrictEqual(t.getAndClearEntries(),["compute value 0","get value: 0"]),t.log(`get value: ${n.get()}`),s.deepStrictEqual(t.getAndClearEntries(),["compute value 0","get value: 0"])})}),test("reading derived in transaction unsubscribes unnecessary observables",()=>{const e=new u,t=p("shouldReadMyObs1",!0),n=new y("myObs1",0,e),r=m(a=>(e.log("myComputed.recompute"),t.read(a)?n.read(a):1));c.add(b(a=>{const l=r.read(a);e.log(`myAutorun: ${l}`)})),s.deepStrictEqual(e.getAndClearEntries(),["myComputed.recompute","myObs1.firstObserverAdded","myObs1.get","myAutorun: 0"]),g(a=>{n.set(1,a),s.deepStrictEqual(e.getAndClearEntries(),["myObs1.set (value 1)"]),t.set(!1,a),s.deepStrictEqual(e.getAndClearEntries(),[]),r.get(),s.deepStrictEqual(e.getAndClearEntries(),["myComputed.recompute","myObs1.lastObserverRemoved"])}),s.deepStrictEqual(e.getAndClearEntries(),["myAutorun: 1"])}),test("avoid recomputation of deriveds that are no longer read",()=>{const e=new u,t=new y("myObsShouldRead",!0,e),n=new y("myObs1",0,e),r=m(a=>{const l=n.read(a),d=l%10;return e.log(`myComputed1(myObs1: ${l}): Computed ${d}`),l});c.add(b(a=>{if(t.read(a)){const d=r.read(a);e.log(`myAutorun(shouldRead: true, myComputed1: ${d}): run`)}else e.log("myAutorun(shouldRead: false): run")})),s.deepStrictEqual(e.getAndClearEntries(),["myObsShouldRead.firstObserverAdded","myObsShouldRead.get","myObs1.firstObserverAdded","myObs1.get","myComputed1(myObs1: 0): Computed 0","myAutorun(shouldRead: true, myComputed1: 0): run"]),g(a=>{t.set(!1,a),n.set(1,a),s.deepStrictEqual(e.getAndClearEntries(),["myObsShouldRead.set (value false)","myObs1.set (value 1)"])}),s.deepStrictEqual(e.getAndClearEntries(),["myObsShouldRead.get","myAutorun(shouldRead: false): run","myObs1.lastObserverRemoved"]),g(a=>{t.set(!0,a),s.deepStrictEqual(e.getAndClearEntries(),["myObsShouldRead.set (value true)"])}),s.deepStrictEqual(e.getAndClearEntries(),["myObsShouldRead.get","myObs1.firstObserverAdded","myObs1.get","myComputed1(myObs1: 1): Computed 1","myAutorun(shouldRead: true, myComputed1: 1): run"])}),suite("autorun rerun on neutral change",()=>{test("autorun reruns on neutral observable double change",()=>{const e=new u,t=p("myObservable",0);c.add(b(n=>{e.log(`myAutorun.run(myObservable: ${t.read(n)})`)})),s.deepStrictEqual(e.getAndClearEntries(),["myAutorun.run(myObservable: 0)"]),g(n=>{t.set(2,n),s.deepStrictEqual(e.getAndClearEntries(),[]),t.set(0,n),s.deepStrictEqual(e.getAndClearEntries(),[])}),s.deepStrictEqual(e.getAndClearEntries(),["myAutorun.run(myObservable: 0)"])}),test("autorun does not rerun on indirect neutral observable double change",()=>{const e=new u,t=p("myObservable",0),n=m(r=>{const a=t.read(r);return e.log(`myDerived.read(myObservable: ${a})`),a});c.add(b(r=>{e.log(`myAutorun.run(myDerived: ${n.read(r)})`)})),s.deepStrictEqual(e.getAndClearEntries(),["myDerived.read(myObservable: 0)","myAutorun.run(myDerived: 0)"]),g(r=>{t.set(2,r),s.deepStrictEqual(e.getAndClearEntries(),[]),t.set(0,r),s.deepStrictEqual(e.getAndClearEntries(),[])}),s.deepStrictEqual(e.getAndClearEntries(),["myDerived.read(myObservable: 0)"])}),test("autorun reruns on indirect neutral observable double change when changes propagate",()=>{const e=new u,t=p("myObservable",0),n=m(r=>{const a=t.read(r);return e.log(`myDerived.read(myObservable: ${a})`),a});c.add(b(r=>{e.log(`myAutorun.run(myDerived: ${n.read(r)})`)})),s.deepStrictEqual(e.getAndClearEntries(),["myDerived.read(myObservable: 0)","myAutorun.run(myDerived: 0)"]),g(r=>{t.set(2,r),s.deepStrictEqual(e.getAndClearEntries(),[]),n.get(),s.deepStrictEqual(e.getAndClearEntries(),["myDerived.read(myObservable: 2)"]),t.set(0,r),s.deepStrictEqual(e.getAndClearEntries(),[])}),s.deepStrictEqual(e.getAndClearEntries(),["myDerived.read(myObservable: 0)","myAutorun.run(myDerived: 0)"])})}),test("self-disposing autorun",()=>{const e=new u,t=new y("myObservable1",0,e),n=new y("myObservable2",0,e),r=new y("myObservable3",0,e),a=b(l=>{t.read(l)>=2&&(s.deepStrictEqual(e.getAndClearEntries(),["myObservable1.set (value 2)","myObservable1.get"]),n.read(l),s.deepStrictEqual(e.getAndClearEntries(),["myObservable2.firstObserverAdded","myObservable2.get"]),a.dispose(),s.deepStrictEqual(e.getAndClearEntries(),["myObservable1.lastObserverRemoved","myObservable2.lastObserverRemoved"]),r.read(l),s.deepStrictEqual(e.getAndClearEntries(),["myObservable3.get"]))});s.deepStrictEqual(e.getAndClearEntries(),["myObservable1.firstObserverAdded","myObservable1.get"]),t.set(1,void 0),s.deepStrictEqual(e.getAndClearEntries(),["myObservable1.set (value 1)","myObservable1.get"]),t.set(2,void 0),s.deepStrictEqual(e.getAndClearEntries(),[])}),test("changing observables in endUpdate",()=>{const e=new u,t=new y("myObservable1",0,e),n=new y("myObservable2",0,e),r=m(l=>{const d=t.read(l);return e.log(`myDerived1.read(myObservable: ${d})`),d}),a=m(l=>{const d=n.read(l);return d===1&&r.read(l),e.log(`myDerived2.read(myObservable: ${d})`),d});c.add(b(l=>{const d=r.read(l),o=a.read(l);e.log(`myAutorun.run(myDerived1: ${d}, myDerived2: ${o})`)})),g(l=>{n.set(1,l),t.set(1,l)})}),test("set dependency in derived",()=>{const e=new u,t=new y("myObservable",0,e),n=m(r=>{let a=t.read(r);const l=a;return e.log(`myComputed(myObservable: ${l}): start computing`),a%3!==0&&(a++,t.set(a,void 0)),e.log(`myComputed(myObservable: ${l}): finished computing`),a});c.add(b(r=>{const a=n.read(r);e.log(`myAutorun(myComputed: ${a})`)})),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.firstObserverAdded","myObservable.get","myComputed(myObservable: 0): start computing","myComputed(myObservable: 0): finished computing","myAutorun(myComputed: 0)"]),t.set(1,void 0),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.set (value 1)","myObservable.get","myComputed(myObservable: 1): start computing","myObservable.set (value 2)","myComputed(myObservable: 1): finished computing","myObservable.get","myComputed(myObservable: 2): start computing","myObservable.set (value 3)","myComputed(myObservable: 2): finished computing","myObservable.get","myComputed(myObservable: 3): start computing","myComputed(myObservable: 3): finished computing","myAutorun(myComputed: 3)"])}),test("set dependency in autorun",()=>{const e=new u,t=new y("myObservable",0,e);c.add(b(n=>{const r=t.read(n);e.log(`myAutorun(myObservable: ${r}): start`),r!==0&&r<4&&t.set(r+1,void 0),e.log(`myAutorun(myObservable: ${r}): end`)})),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.firstObserverAdded","myObservable.get","myAutorun(myObservable: 0): start","myAutorun(myObservable: 0): end"]),t.set(1,void 0),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.set (value 1)","myObservable.get","myAutorun(myObservable: 1): start","myObservable.set (value 2)","myAutorun(myObservable: 1): end","myObservable.get","myAutorun(myObservable: 2): start","myObservable.set (value 3)","myAutorun(myObservable: 2): end","myObservable.get","myAutorun(myObservable: 3): start","myObservable.set (value 4)","myAutorun(myObservable: 3): end","myObservable.get","myAutorun(myObservable: 4): start","myAutorun(myObservable: 4): end"])}),test("get in transaction between sets",()=>{const e=new u,t=new y("myObservable",0,e),n=m(a=>{const l=t.read(a);return e.log(`myDerived1(myObservable: ${l}): start computing`),l}),r=m(a=>{const l=n.read(a);return e.log(`myDerived2(myDerived1: ${l}): start computing`),l});c.add(b(a=>{const l=r.read(a);e.log(`myAutorun(myDerived2: ${l})`)})),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.firstObserverAdded","myObservable.get","myDerived1(myObservable: 0): start computing","myDerived2(myDerived1: 0): start computing","myAutorun(myDerived2: 0)"]),g(a=>{t.set(1,a),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.set (value 1)"]),r.get(),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.get","myDerived1(myObservable: 1): start computing","myDerived2(myDerived1: 1): start computing"]),t.set(2,a),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.set (value 2)"])}),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.get","myDerived1(myObservable: 2): start computing","myDerived2(myDerived1: 2): start computing","myAutorun(myDerived2: 2)"])}),test("bug: Dont reset states",()=>{const e=new u,t=new y("myObservable1",0,e),n=new y("myObservable2",0,e),r=m(l=>{const d=n.read(l);return e.log(`myDerived2.computed(myObservable2: ${d})`),d%10}),a=m(l=>{const d=t.read(l),o=r.read(l);return e.log(`myDerived3.computed(myDerived1: ${d}, myDerived2: ${o})`),`${d} + ${o}`});c.add(b(l=>{const d=a.read(l);e.log(`myAutorun(myDerived3: ${d})`)})),s.deepStrictEqual(e.getAndClearEntries(),["myObservable1.firstObserverAdded","myObservable1.get","myObservable2.firstObserverAdded","myObservable2.get","myDerived2.computed(myObservable2: 0)","myDerived3.computed(myDerived1: 0, myDerived2: 0)","myAutorun(myDerived3: 0 + 0)"]),g(l=>{t.set(1,l),s.deepStrictEqual(e.getAndClearEntries(),["myObservable1.set (value 1)"]),n.set(10,l),s.deepStrictEqual(e.getAndClearEntries(),["myObservable2.set (value 10)"])}),s.deepStrictEqual(e.getAndClearEntries(),["myObservable1.get","myObservable2.get","myDerived2.computed(myObservable2: 10)","myDerived3.computed(myDerived1: 1, myDerived2: 0)","myAutorun(myDerived3: 1 + 0)"])}),test("bug: Add observable in endUpdate",()=>{const e=p("myObservable1",0),t=p("myObservable2",0),n=m(l=>e.read(l)),r=m(l=>t.read(l)),a=m(l=>{n.read(l)===1&&r.read(l)});c.add(b(l=>{a.read(l)})),c.add(b(l=>{r.read(l)})),g(l=>{e.set(1,l),t.set(1,l)})}),test("bug: fromObservableLight doesnt subscribe",()=>{const e=new u,t=new y("myObservable",0,e),n=m(a=>{const l=t.read(a);return e.log(`myDerived.computed(myObservable2: ${l})`),l%10}),r=C.fromObservableLight(n);e.log("event created"),r(()=>{e.log("event fired")}),t.set(1,void 0),s.deepStrictEqual(e.getAndClearEntries(),["event created","myObservable.firstObserverAdded","myObservable.get","myDerived.computed(myObservable2: 0)","myObservable.set (value 1)","myObservable.get","myDerived.computed(myObservable2: 1)","event fired"])}),test("bug: Event.fromObservable always should get events",()=>{const e=new A,t=new u;let n=0;const r=S(e.event,()=>n);n++,e.fire(1);const l=C.fromObservable(r)(d=>{t.log(`event fired ${d}`)});n++,e.fire(2),s.deepStrictEqual(t.getAndClearEntries(),["event fired 2"]),n++,e.fire(3),s.deepStrictEqual(t.getAndClearEntries(),["event fired 3"]),l.dispose()}),test("dont run autorun after dispose",()=>{const e=new u,t=new y("myObservable",0,e),n=b(r=>{const a=t.read(r);e.log("autorun, myObservable:"+a)});g(r=>{t.set(1,r),n.dispose()}),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.firstObserverAdded","myObservable.get","autorun, myObservable:0","myObservable.set (value 1)","myObservable.lastObserverRemoved"])}),suite("waitForState",()=>{test("resolve",async()=>{const e=new u,t=new y("myObservable",{state:"initializing"},e),n=E(t,r=>r.state==="ready",r=>r.state==="error").then(r=>{e.log(`resolved ${JSON.stringify(r)}`)},r=>{e.log(`rejected ${JSON.stringify(r)}`)});s.deepStrictEqual(e.getAndClearEntries(),["myObservable.firstObserverAdded","myObservable.get"]),t.set({state:"ready"},void 0),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.set (value [object Object])","myObservable.get","myObservable.lastObserverRemoved"]),await n,s.deepStrictEqual(e.getAndClearEntries(),['resolved {"state":"ready"}'])}),test("resolveImmediate",async()=>{const e=new u,t=new y("myObservable",{state:"ready"},e),n=E(t,r=>r.state==="ready",r=>r.state==="error").then(r=>{e.log(`resolved ${JSON.stringify(r)}`)},r=>{e.log(`rejected ${JSON.stringify(r)}`)});s.deepStrictEqual(e.getAndClearEntries(),["myObservable.firstObserverAdded","myObservable.get","myObservable.lastObserverRemoved"]),t.set({state:"error"},void 0),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.set (value [object Object])"]),await n,s.deepStrictEqual(e.getAndClearEntries(),['resolved {"state":"ready"}'])}),test("reject",async()=>{const e=new u,t=new y("myObservable",{state:"initializing"},e),n=E(t,r=>r.state==="ready",r=>r.state==="error").then(r=>{e.log(`resolved ${JSON.stringify(r)}`)},r=>{e.log(`rejected ${JSON.stringify(r)}`)});s.deepStrictEqual(e.getAndClearEntries(),["myObservable.firstObserverAdded","myObservable.get"]),t.set({state:"error"},void 0),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.set (value [object Object])","myObservable.get","myObservable.lastObserverRemoved"]),await n,s.deepStrictEqual(e.getAndClearEntries(),['rejected {"state":"error"}'])}),test("derived as lazy",()=>{const e=new f,t=new u;let n=0;const r=R(()=>{const a=n++;return t.log("myDerived "+a),{dispose:()=>t.log(`disposed ${a}`)}});r.get(),s.deepStrictEqual(t.getAndClearEntries(),["myDerived 0","disposed 0"]),r.get(),s.deepStrictEqual(t.getAndClearEntries(),["myDerived 1","disposed 1"]),r.keepObserved(e),s.deepStrictEqual(t.getAndClearEntries(),[]),r.get(),s.deepStrictEqual(t.getAndClearEntries(),["myDerived 2"]),r.get(),s.deepStrictEqual(t.getAndClearEntries(),[]),e.dispose(),s.deepStrictEqual(t.getAndClearEntries(),["disposed 2"])})}),test("observableValue",()=>{const e=new u,t=p("myObservable1",0),n=p("myObservable2",0),r=b(a=>{const l=t.read(a),d=n.read(a);e.log("autorun, myObservable1:"+l+", myObservable2:"+d)});s.deepStrictEqual(e.getAndClearEntries(),["autorun, myObservable1:0, myObservable2:0"]),t.set(0,void 0),s.deepStrictEqual(e.getAndClearEntries(),[]),n.set(0,void 0,{message:"change1"}),s.deepStrictEqual(e.getAndClearEntries(),["autorun, myObservable1:0, myObservable2:0"]),r.dispose()}),suite("autorun error handling",()=>{test("immediate throw",()=>{const e=new u;h(r=>{e.log(`error: ${r.message}`)});const t=new y("myObservable",0,e),n=b(r=>{throw t.read(r),new Error("foobar")});s.deepStrictEqual(e.getAndClearEntries(),["myObservable.firstObserverAdded","myObservable.get","error: foobar"]),t.set(1,void 0),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.set (value 1)","myObservable.get","error: foobar"]),n.dispose()}),test("late throw",()=>{const e=new u;h(r=>{e.log(`error: ${r.message}`)});const t=new y("myObservable",0,e),n=b(r=>{if(t.read(r)>=1)throw new Error("foobar")});s.deepStrictEqual(e.getAndClearEntries(),["myObservable.firstObserverAdded","myObservable.get"]),t.set(1,void 0),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.set (value 1)","myObservable.get","error: foobar"]),t.set(2,void 0),s.deepStrictEqual(e.getAndClearEntries(),["myObservable.set (value 2)","myObservable.get","error: foobar"]),n.dispose()})})});class B{constructor(e,t){this.debugName=e;this.log=t}count=0;beginUpdate(e){this.count++,this.log.log(`${this.debugName}.beginUpdate (count ${this.count})`)}endUpdate(e){this.log.log(`${this.debugName}.endUpdate (count ${this.count})`),this.count--}handleChange(e,t){this.log.log(`${this.debugName}.handleChange (count ${this.count})`)}handlePossibleChange(e){this.log.log(`${this.debugName}.handlePossibleChange`)}}class y extends w{constructor(t,n,r){super();this.debugName=t;this.log=r;this.value=n}value;onFirstObserverAdded(){this.log.log(`${this.debugName}.firstObserverAdded`)}onLastObserverRemoved(){this.log.log(`${this.debugName}.lastObserverRemoved`)}get(){return this.log.log(`${this.debugName}.get`),this.value}set(t,n,r){if(this.value!==t){if(!n){g(a=>{this.set(t,a,r)},()=>`Setting ${this.debugName}`);return}this.log.log(`${this.debugName}.set (value ${t})`),this.value=t;for(const a of this.observers)n.updateObserver(a,this),a.handleChange(this,r)}}toString(){return`${this.debugName}: ${this.value}`}}class u{entries=[];log(e){this.entries.push(e)}getAndClearEntries(){const e=[...this.entries];return this.entries.length=0,e}}export{y as LoggingObservableValue,B as LoggingObserver};
