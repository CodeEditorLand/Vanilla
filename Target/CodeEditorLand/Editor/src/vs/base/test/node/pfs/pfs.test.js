import t from"assert";import*as e from"fs";import{tmpdir as u}from"os";import{timeout as h}from"../../../common/async.js";import{VSBuffer as D}from"../../../common/buffer.js";import{randomPath as c}from"../../../common/extpath.js";import{FileAccess as v}from"../../../common/network.js";import{basename as b,dirname as H,join as i,sep as C}from"../../../common/path.js";import{isWindows as x}from"../../../common/platform.js";import{configureFlushOnWrite as F,Promises as l,RimRafMode as d,rimrafSync as p,SymlinkSupport as k,writeFileSync as L}from"../../../node/pfs.js";import{ensureNoDisposablesAreLeakedInTestSuite as q}from"../../common/utils.js";import{flakySuite as O,getRandomTestPath as j}from"../testUtils.js";import{isESM as E}from"../../../common/amd.js";F(!1),O("PFS",function(){let s;setup(()=>(s=j(u(),"vsctests","pfs"),e.promises.mkdir(s,{recursive:!0}))),teardown(()=>l.rm(s)),test("writeFile",async()=>{const r=i(s,"writefile.txt");t.ok(!await l.exists(r)),await l.writeFile(r,"Hello World",null),t.strictEqual((await e.promises.readFile(r)).toString(),"Hello World")}),test("writeFile - parallel write on different files works",async()=>{const r=i(s,"writefile1.txt"),n=i(s,"writefile2.txt"),o=i(s,"writefile3.txt"),a=i(s,"writefile4.txt"),m=i(s,"writefile5.txt");await Promise.all([l.writeFile(r,"Hello World 1",null),l.writeFile(n,"Hello World 2",null),l.writeFile(o,"Hello World 3",null),l.writeFile(a,"Hello World 4",null),l.writeFile(m,"Hello World 5",null)]),t.strictEqual(e.readFileSync(r).toString(),"Hello World 1"),t.strictEqual(e.readFileSync(n).toString(),"Hello World 2"),t.strictEqual(e.readFileSync(o).toString(),"Hello World 3"),t.strictEqual(e.readFileSync(a).toString(),"Hello World 4"),t.strictEqual(e.readFileSync(m).toString(),"Hello World 5")}),test("writeFile - parallel write on same files works and is sequentalized",async()=>{const r=i(s,"writefile.txt");await Promise.all([l.writeFile(r,"Hello World 1",void 0),l.writeFile(r,"Hello World 2",void 0),h(10).then(()=>l.writeFile(r,"Hello World 3",void 0)),l.writeFile(r,"Hello World 4",void 0),h(10).then(()=>l.writeFile(r,"Hello World 5",void 0))]),t.strictEqual(e.readFileSync(r).toString(),"Hello World 5")}),test("rimraf - simple - unlink",async()=>{e.writeFileSync(i(s,"somefile.txt"),"Contents"),e.writeFileSync(i(s,"someOtherFile.txt"),"Contents"),await l.rm(s),t.ok(!e.existsSync(s))}),test("rimraf - simple - move",async()=>{e.writeFileSync(i(s,"somefile.txt"),"Contents"),e.writeFileSync(i(s,"someOtherFile.txt"),"Contents"),await l.rm(s,d.MOVE),t.ok(!e.existsSync(s))}),test("rimraf - simple - move (with moveToPath)",async()=>{e.writeFileSync(i(s,"somefile.txt"),"Contents"),e.writeFileSync(i(s,"someOtherFile.txt"),"Contents"),await l.rm(s,d.MOVE,i(H(s),`${b(s)}.vsctmp`)),t.ok(!e.existsSync(s))}),test("rimraf - path does not exist - move",async()=>{const r=i(s,"unknown-move");await l.rm(r,d.MOVE)}),test("rimraf - path does not exist - unlink",async()=>{const r=i(s,"unknown-unlink");await l.rm(r,d.UNLINK)}),test("rimraf - recursive folder structure - unlink",async()=>{e.writeFileSync(i(s,"somefile.txt"),"Contents"),e.writeFileSync(i(s,"someOtherFile.txt"),"Contents"),e.mkdirSync(i(s,"somefolder")),e.writeFileSync(i(s,"somefolder","somefile.txt"),"Contents"),await l.rm(s),t.ok(!e.existsSync(s))}),test("rimraf - recursive folder structure - move",async()=>{e.writeFileSync(i(s,"somefile.txt"),"Contents"),e.writeFileSync(i(s,"someOtherFile.txt"),"Contents"),e.mkdirSync(i(s,"somefolder")),e.writeFileSync(i(s,"somefolder","somefile.txt"),"Contents"),await l.rm(s,d.MOVE),t.ok(!e.existsSync(s))}),test("rimraf - simple ends with dot - move",async()=>{e.writeFileSync(i(s,"somefile.txt"),"Contents"),e.writeFileSync(i(s,"someOtherFile.txt"),"Contents"),await l.rm(s,d.MOVE),t.ok(!e.existsSync(s))}),test("rimraf - simple ends with dot slash/backslash - move",async()=>{e.writeFileSync(i(s,"somefile.txt"),"Contents"),e.writeFileSync(i(s,"someOtherFile.txt"),"Contents"),await l.rm(`${s}${C}`,d.MOVE),t.ok(!e.existsSync(s))}),test("rimrafSync - swallows file not found error",function(){const r=i(s,"not-existing");p(r),t.ok(!e.existsSync(r))}),test("rimrafSync - simple",async()=>{e.writeFileSync(i(s,"somefile.txt"),"Contents"),e.writeFileSync(i(s,"someOtherFile.txt"),"Contents"),p(s),t.ok(!e.existsSync(s))}),test("rimrafSync - recursive folder structure",async()=>{e.writeFileSync(i(s,"somefile.txt"),"Contents"),e.writeFileSync(i(s,"someOtherFile.txt"),"Contents"),e.mkdirSync(i(s,"somefolder")),e.writeFileSync(i(s,"somefolder","somefile.txt"),"Contents"),p(s),t.ok(!e.existsSync(s))}),(E?test:test.skip)("copy, rename and delete",async()=>{const r=v.asFileUri("vs/base/test/node/pfs/fixtures").fsPath,n=i(u(),"vsctests","pfs"),o=c(n),a=c(n);await l.copy(r,o,{preserveSymlinks:!0}),t.ok(e.existsSync(o)),t.ok(e.existsSync(i(o,"index.html"))),t.ok(e.existsSync(i(o,"site.css"))),t.ok(e.existsSync(i(o,"examples"))),t.ok(e.statSync(i(o,"examples")).isDirectory()),t.ok(e.existsSync(i(o,"examples","small.jxs"))),await l.rename(o,a),t.ok(!e.existsSync(o)),t.ok(e.existsSync(a)),t.ok(e.existsSync(i(a,"index.html"))),t.ok(e.existsSync(i(a,"site.css"))),t.ok(e.existsSync(i(a,"examples"))),t.ok(e.statSync(i(a,"examples")).isDirectory()),t.ok(e.existsSync(i(a,"examples","small.jxs"))),await l.rename(i(a,"index.html"),i(a,"index_moved.html")),t.ok(!e.existsSync(i(a,"index.html"))),t.ok(e.existsSync(i(a,"index_moved.html"))),await l.rm(n),t.ok(!e.existsSync(n))}),(E?test:test.skip)("rename without retry",async()=>{const r=v.asFileUri("vs/base/test/node/pfs/fixtures").fsPath,n=i(u(),"vsctests","pfs"),o=c(n),a=c(n);await l.copy(r,o,{preserveSymlinks:!0}),await l.rename(o,a,!1),t.ok(!e.existsSync(o)),t.ok(e.existsSync(a)),t.ok(e.existsSync(i(a,"index.html"))),t.ok(e.existsSync(i(a,"site.css"))),t.ok(e.existsSync(i(a,"examples"))),t.ok(e.statSync(i(a,"examples")).isDirectory()),t.ok(e.existsSync(i(a,"examples","small.jxs"))),await l.rename(i(a,"index.html"),i(a,"index_moved.html"),!1),t.ok(!e.existsSync(i(a,"index.html"))),t.ok(e.existsSync(i(a,"index_moved.html"))),await l.rm(n),t.ok(!e.existsSync(n))}),test("copy handles symbolic links",async()=>{const r=c(s),n=c(s),o=c(s);if(await e.promises.mkdir(r,{recursive:!0}),e.symlinkSync(r,n,"junction"),!x){await l.copy(n,o,{preserveSymlinks:!0}),t.ok(e.existsSync(o));const{symbolicLink:a}=await k.stat(o);t.ok(a),t.ok(!a.dangling);const m=await e.promises.readlink(o);t.strictEqual(m,r),await l.rm(o),await l.copy(n,o,{preserveSymlinks:!1}),t.ok(e.existsSync(o));const{symbolicLink:y}=await k.stat(o);t.ok(!y)}if(await l.rm(o),await l.rm(r),await l.copy(n,o,{preserveSymlinks:!0}),x)t.ok(!e.existsSync(o));else{const{symbolicLink:a}=await k.stat(o);t.ok(a?.dangling)}}),test("copy handles symbolic links when the reference is inside source",async()=>{const r=i(c(s),"copy-test"),n=i(r,"link-test"),o=i(n,"md5"),a=i(o,"md5.js");await e.promises.mkdir(o,{recursive:!0}),await l.writeFile(a,"Hello from MD5");const m=i(n,"md5-linked");e.symlinkSync(o,m,"junction");const y=i(r,"link-test copy"),w=i(y,"md5"),g=i(w,"md5.js"),S=i(y,"md5-linked");if(!x){await l.copy(n,y,{preserveSymlinks:!0}),t.ok(e.existsSync(y)),t.ok(e.existsSync(w)),t.ok(e.existsSync(g)),t.ok(e.existsSync(S)),t.ok(e.lstatSync(S).isSymbolicLink());const W=await e.promises.readlink(S);t.strictEqual(W,w),await l.rm(y)}await l.copy(n,y,{preserveSymlinks:!1}),t.ok(e.existsSync(y)),t.ok(e.existsSync(w)),t.ok(e.existsSync(g)),t.ok(e.existsSync(S)),t.ok(e.lstatSync(S).isDirectory())}),test("readDirsInDir",async()=>{e.mkdirSync(i(s,"somefolder1")),e.mkdirSync(i(s,"somefolder2")),e.mkdirSync(i(s,"somefolder3")),e.writeFileSync(i(s,"somefile.txt"),"Contents"),e.writeFileSync(i(s,"someOtherFile.txt"),"Contents");const r=await l.readDirsInDir(s);t.strictEqual(r.length,3),t.ok(r.indexOf("somefolder1")!==-1),t.ok(r.indexOf("somefolder2")!==-1),t.ok(r.indexOf("somefolder3")!==-1)}),test("stat link",async()=>{const r=c(s),n=c(s);await e.promises.mkdir(r,{recursive:!0}),e.symlinkSync(r,n,"junction");let o=await k.stat(r);t.ok(!o?.symbolicLink),o=await k.stat(n),t.ok(o?.symbolicLink),t.ok(!o?.symbolicLink?.dangling)}),test("stat link (non existing target)",async()=>{const r=c(s),n=c(s);await e.promises.mkdir(r,{recursive:!0}),e.symlinkSync(r,n,"junction"),await l.rm(r);const o=await k.stat(n);t.ok(o?.symbolicLink),t.ok(o?.symbolicLink?.dangling)}),test("readdir",async()=>{if(typeof process.versions.electron<"u"){const r=c(i(s,"pfs")),n=i(r,"\xF6\xE4\xFC");await e.promises.mkdir(n,{recursive:!0}),t.ok(e.existsSync(n));const o=await l.readdir(r);t.strictEqual(o.some(a=>a==="\xF6\xE4\xFC"),!0)}}),test("readdir (with file types)",async()=>{if(typeof process.versions.electron<"u"){const r=i(s,"\xF6\xE4\xFC");await e.promises.mkdir(r,{recursive:!0}),await l.writeFile(i(s,"somefile.txt"),"contents"),t.ok(e.existsSync(r));const n=await l.readdir(s,{withFileTypes:!0});t.strictEqual(n.some(o=>o.name==="\xF6\xE4\xFC"),!0),t.strictEqual(n.some(o=>o.isDirectory()),!0),t.strictEqual(n.some(o=>o.name==="somefile.txt"),!0),t.strictEqual(n.some(o=>o.isFile()),!0)}}),test("writeFile (string)",async()=>{const r="Hello World",n=new Array(102400).join(`Large String
`);return f(r,r,n,n)}),test("writeFile (string) - flush on write",async()=>{F(!0);try{const r="Hello World",n=new Array(102400).join(`Large String
`);return await f(r,r,n,n)}finally{F(!1)}}),test("writeFile (Buffer)",async()=>{const r="Hello World",n=new Array(102400).join(`Large String
`);return f(Buffer.from(r),r,Buffer.from(n),n)}),test("writeFile (UInt8Array)",async()=>{const r="Hello World",n=new Array(102400).join(`Large String
`);return f(D.fromString(r).buffer,r,D.fromString(n).buffer,n)});async function f(r,n,o,a){const m=i(s,"flushed.txt");t.ok(e.existsSync(s)),await l.writeFile(m,r),t.strictEqual(e.readFileSync(m).toString(),n),await l.writeFile(m,o),t.strictEqual(e.readFileSync(m).toString(),a)}test("writeFile (string, error handling)",async()=>{const r=i(s,"flushed.txt");e.mkdirSync(r);let n;try{await l.writeFile(r,"Hello World")}catch(o){n=o}t.ok(n)}),test("writeFileSync",async()=>{const r=i(s,"flushed.txt");L(r,"Hello World"),t.strictEqual(e.readFileSync(r).toString(),"Hello World");const n=new Array(100*1024).join(`Large String
`);L(r,n),t.strictEqual(e.readFileSync(r).toString(),n)}),q()});
