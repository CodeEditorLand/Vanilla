import n from"assert";import{CancellationToken as l,CancellationTokenSource as o}from"../../common/cancellation.js";import{ensureNoDisposablesAreLeakedInTestSuite as a}from"./utils.js";suite("CancellationToken",function(){const s=a();test("None",()=>{n.strictEqual(l.None.isCancellationRequested,!1),n.strictEqual(typeof l.None.onCancellationRequested,"function")}),test("cancel before token",function(){const e=new o;return n.strictEqual(e.token.isCancellationRequested,!1),e.cancel(),n.strictEqual(e.token.isCancellationRequested,!0),new Promise(t=>{e.token.onCancellationRequested(()=>t())})}),test("cancel happens only once",function(){const e=new o;n.strictEqual(e.token.isCancellationRequested,!1);let t=0;function c(){t+=1}s.add(e.token.onCancellationRequested(c)),e.cancel(),e.cancel(),n.strictEqual(t,1)}),test("cancel calls all listeners",function(){let e=0;const t=new o;s.add(t.token.onCancellationRequested(()=>e++)),s.add(t.token.onCancellationRequested(()=>e++)),s.add(t.token.onCancellationRequested(()=>e++)),t.cancel(),n.strictEqual(e,3)}),test("token stays the same",function(){let e=new o,t=e.token;n.ok(t===e.token),e.cancel(),n.ok(t===e.token),e.cancel(),n.ok(t===e.token),e=new o,e.cancel(),t=e.token,n.ok(t===e.token)}),test("dispose calls no listeners",function(){let e=0;const t=new o;s.add(t.token.onCancellationRequested(()=>e++)),t.dispose(),t.cancel(),n.strictEqual(e,0)}),test("dispose calls no listeners (unless told to cancel)",function(){let e=0;const t=new o;s.add(t.token.onCancellationRequested(()=>e++)),t.dispose(!0),n.strictEqual(e,1)}),test("dispose does not cancel",function(){const e=new o;e.dispose(),n.strictEqual(e.token.isCancellationRequested,!1)}),test("parent cancels child",function(){const e=new o,t=new o(e.token);let c=0;s.add(t.token.onCancellationRequested(()=>c++)),e.cancel(),n.strictEqual(c,1),n.strictEqual(t.token.isCancellationRequested,!0),n.strictEqual(e.token.isCancellationRequested,!0),t.dispose(),e.dispose()})});
