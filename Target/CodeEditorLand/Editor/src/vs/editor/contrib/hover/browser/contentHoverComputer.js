import{coalesce as l}from"../../../../base/common/arrays.js";import"../../../../base/common/cancellation.js";import"../../../browser/editorBrowser.js";import"../../../common/model.js";import"./hoverOperation.js";import{HoverAnchorType as p}from"./hoverTypes.js";import{AsyncIterableObject as a}from"../../../../base/common/async.js";class s{constructor(r,e){this._editor=r;this._participants=e}static _getLineDecorations(r,e){if(e.type!==p.Range&&!e.supportsMarkerHover)return[];const t=r.getModel(),o=e.range.startLineNumber;if(o>t.getLineCount())return[];const n=t.getLineMaxColumn(o);return r.getLineDecorations(o).filter(i=>{if(i.options.isWholeLine)return!0;const c=i.range.startLineNumber===o?i.range.startColumn:1,u=i.range.endLineNumber===o?i.range.endColumn:n;if(i.options.showIfCollapsed){if(c>e.range.startColumn+1||e.range.endColumn-1>u)return!1}else if(c>e.range.startColumn||e.range.endColumn>u)return!1;return!0})}computeAsync(r,e){const t=r.anchor;if(!this._editor.hasModel()||!t)return a.EMPTY;const o=s._getLineDecorations(this._editor,t);return a.merge(this._participants.map(n=>n.computeAsync?n.computeAsync(t,o,e):a.EMPTY))}computeSync(r){if(!this._editor.hasModel())return[];const e=r.anchor,t=s._getLineDecorations(this._editor,e);let o=[];for(const n of this._participants)o=o.concat(n.computeSync(e,t));return l(o)}}export{s as ContentHoverComputer};
