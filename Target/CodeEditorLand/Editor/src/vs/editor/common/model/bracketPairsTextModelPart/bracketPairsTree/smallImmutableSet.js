const l=[];class r{constructor(e,t){this.items=e;this.additionalItems=t}static cache=new Array(129);static create(e,t){if(e<=128&&t.length===0){let i=r.cache[e];return i||(i=new r(e,t),r.cache[e]=i),i}return new r(e,t)}static empty=r.create(0,l);static getEmpty(){return this.empty}add(e,t){const i=t.getKey(e);let s=i>>5;if(s===0){const a=1<<i|this.items;return a===this.items?this:r.create(a,this.additionalItems)}s--;const n=this.additionalItems.slice(0);for(;n.length<s;)n.push(0);return n[s]|=1<<(i&31),r.create(this.items,n)}has(e,t){const i=t.getKey(e);let s=i>>5;return s===0?(this.items&1<<i)!==0:(s--,((this.additionalItems[s]||0)&1<<(i&31))!==0)}merge(e){const t=this.items|e.items;if(this.additionalItems===l&&e.additionalItems===l)return t===this.items?this:t===e.items?e:r.create(t,l);const i=[];for(let s=0;s<Math.max(this.additionalItems.length,e.additionalItems.length);s++){const n=this.additionalItems[s]||0,a=e.additionalItems[s]||0;i.push(n|a)}return r.create(t,i)}intersects(e){if(this.items&e.items)return!0;for(let t=0;t<Math.min(this.additionalItems.length,e.additionalItems.length);t++)if(this.additionalItems[t]&e.additionalItems[t])return!0;return!1}equals(e){if(this.items!==e.items||this.additionalItems.length!==e.additionalItems.length)return!1;for(let t=0;t<this.additionalItems.length;t++)if(this.additionalItems[t]!==e.additionalItems[t])return!1;return!0}}const d={getKey(m){return m}};class u{items=new Map;getKey(e){let t=this.items.get(e);return t===void 0&&(t=this.items.size,this.items.set(e,t)),t}reverseLookup(e){return[...this.items].find(([t,i])=>i===e)?.[0]}reverseLookupSet(e){const t=[];for(const[i]of this.items)e.has(i,this)&&t.push(i);return t}keys(){return this.items.keys()}}export{u as DenseKeyProvider,r as SmallImmutableSet,d as identityKeyProvider};
