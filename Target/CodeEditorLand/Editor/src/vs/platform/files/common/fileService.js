var G=Object.defineProperty;var K=Object.getOwnPropertyDescriptor;var N=(E,v,e,i)=>{for(var t=i>1?void 0:i?K(v,e):v,r=E.length-1,a;r>=0;r--)(a=E[r])&&(t=(i?a(v,e,t):a(t))||t);return i&&t&&G(v,e,t),t},Q=(E,v)=>(e,i)=>v(e,i,E);import{coalesce as J}from"../../../base/common/arrays.js";import{Promises as b,ResourceQueue as X}from"../../../base/common/async.js";import{bufferedStreamToBuffer as ee,bufferToReadable as ie,newWriteableBufferStream as te,readableToBuffer as re,streamToBuffer as D,VSBuffer as h}from"../../../base/common/buffer.js";import{CancellationToken as ae,CancellationTokenSource as oe}from"../../../base/common/cancellation.js";import{Emitter as y}from"../../../base/common/event.js";import{hash as se}from"../../../base/common/hash.js";import{Iterable as ne}from"../../../base/common/iterator.js";import{Disposable as le,DisposableStore as q,dispose as C,toDisposable as O}from"../../../base/common/lifecycle.js";import{TernarySearchTree as de}from"../../../base/common/ternarySearchTree.js";import{Schemas as he}from"../../../base/common/network.js";import{mark as fe}from"../../../base/common/performance.js";import{extUri as ce,extUriIgnorePathCase as pe,isAbsolutePath as me}from"../../../base/common/resources.js";import{consumeStream as ye,isReadableBufferedStream as g,isReadableStream as B,listenStream as Fe,newWriteableStream as ue,peekReadable as Ie,peekStream as ve,transform as we}from"../../../base/common/stream.js";import"../../../base/common/uri.js";import{localize as d}from"../../../nls.js";import{ensureFileSystemProviderError as w,etag as z,ETAG_DISABLED as T,FileChangesEvent as Re,FileOperation as F,FileOperationError as c,FileOperationEvent as R,FileOperationResult as p,FilePermission as _,FileSystemProviderCapabilities as u,FileSystemProviderErrorCode as x,FileType as P,hasFileAtomicReadCapability as M,hasFileFolderCopyCapability as H,hasFileReadStreamCapability as V,hasOpenReadWriteCloseCapability as I,hasReadWriteCapability as m,NotModifiedSinceFileOperationError as A,toFileOperationResult as j,toFileSystemProviderErrorCode as k,hasFileCloneCapability as Se,TooLargeFileOperationError as L,hasFileAtomicDeleteCapability as be,hasFileAtomicWriteCapability as Y}from"./files.js";import{readFileIntoStream as Ce}from"./io.js";import{ILogService as Pe}from"../../log/common/log.js";import{ErrorNoTelemetry as Ee}from"../../../base/common/errors.js";let S=class extends le{constructor(e){super();this.logService=e}BUFFER_SIZE=256*1024;_onDidChangeFileSystemProviderRegistrations=this._register(new y);onDidChangeFileSystemProviderRegistrations=this._onDidChangeFileSystemProviderRegistrations.event;_onWillActivateFileSystemProvider=this._register(new y);onWillActivateFileSystemProvider=this._onWillActivateFileSystemProvider.event;_onDidChangeFileSystemProviderCapabilities=this._register(new y);onDidChangeFileSystemProviderCapabilities=this._onDidChangeFileSystemProviderCapabilities.event;provider=new Map;registerProvider(e,i){if(this.provider.has(e))throw new Error(`A filesystem provider for the scheme '${e}' is already registered.`);fe(`code/registerFilesystem/${e}`);const t=new q;return this.provider.set(e,i),this._onDidChangeFileSystemProviderRegistrations.fire({added:!0,scheme:e,provider:i}),t.add(i.onDidChangeFile(r=>{const a=new Re(r,!this.isPathCaseSensitive(i));this.internalOnDidFilesChange.fire(a),a.hasCorrelation()||this._onDidUncorrelatedFilesChange.fire(a)})),typeof i.onDidWatchError=="function"&&t.add(i.onDidWatchError(r=>this._onDidWatchError.fire(new Error(r)))),t.add(i.onDidChangeCapabilities(()=>this._onDidChangeFileSystemProviderCapabilities.fire({provider:i,scheme:e}))),O(()=>{this._onDidChangeFileSystemProviderRegistrations.fire({added:!1,scheme:e,provider:i}),this.provider.delete(e),C(t)})}getProvider(e){return this.provider.get(e)}async activateProvider(e){const i=[];this._onWillActivateFileSystemProvider.fire({scheme:e,join(t){i.push(t)}}),!this.provider.has(e)&&await b.settled(i)}async canHandleResource(e){return await this.activateProvider(e.scheme),this.hasProvider(e)}hasProvider(e){return this.provider.has(e.scheme)}hasCapability(e,i){const t=this.provider.get(e.scheme);return!!(t&&t.capabilities&i)}listCapabilities(){return ne.map(this.provider,([e,i])=>({scheme:e,capabilities:i.capabilities}))}async withProvider(e){if(!me(e))throw new c(d("invalidPath","Unable to resolve filesystem provider with relative file path '{0}'",this.resourceForError(e)),p.FILE_INVALID_PATH);await this.activateProvider(e.scheme);const i=this.provider.get(e.scheme);if(!i){const t=new Ee;throw t.message=d("noProviderFound","ENOPRO: No file system provider found for resource '{0}'",e.toString()),t}return i}async withReadProvider(e){const i=await this.withProvider(e);if(I(i)||m(i)||V(i))return i;throw new Error(`Filesystem provider for scheme '${e.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`)}async withWriteProvider(e){const i=await this.withProvider(e);if(I(i)||m(i))return i;throw new Error(`Filesystem provider for scheme '${e.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`)}_onDidRunOperation=this._register(new y);onDidRunOperation=this._onDidRunOperation.event;async resolve(e,i){try{return await this.doResolveFile(e,i)}catch(t){throw k(t)===x.FileNotFound?new c(d("fileNotFoundError","Unable to resolve nonexistent file '{0}'",this.resourceForError(e)),p.FILE_NOT_FOUND):w(t)}}async doResolveFile(e,i){const t=await this.withProvider(e),r=this.isPathCaseSensitive(t),a=i?.resolveTo,o=i?.resolveSingleChildDescendants,s=i?.resolveMetadata,n=await t.stat(e);let l;return this.toFileStat(t,e,n,void 0,!!s,(f,W)=>(l||(l=de.forUris(()=>!r),l.set(e,!0),a&&l.fill(!0,a)),l.get(f.resource)||l.findSuperstr(f.resource.with({query:null,fragment:null}))?!0:f.isDirectory&&o?W===1:!1))}async toFileStat(e,i,t,r,a,o){const{providerExtUri:s}=this.getExtUri(e),n={resource:i,name:s.basename(i),isFile:(t.type&P.File)!==0,isDirectory:(t.type&P.Directory)!==0,isSymbolicLink:(t.type&P.SymbolicLink)!==0,mtime:t.mtime,ctime:t.ctime,size:t.size,readonly:!!((t.permissions??0)&_.Readonly)||!!(e.capabilities&u.Readonly),locked:!!((t.permissions??0)&_.Locked),etag:z({mtime:t.mtime,size:t.size}),children:void 0};if(n.isDirectory&&o(n,r)){try{const l=await e.readdir(i),f=await b.settled(l.map(async([W,$])=>{try{const U=s.joinPath(i,W),Z=a?await e.stat(U):{type:$};return await this.toFileStat(e,U,Z,l.length,a,o)}catch(U){return this.logService.trace(U),null}}));n.children=J(f)}catch(l){this.logService.trace(l),n.children=[]}return n}return n}async resolveAll(e){return b.settled(e.map(async i=>{try{return{stat:await this.doResolveFile(i.resource,i.options),success:!0}}catch(t){return this.logService.trace(t),{stat:void 0,success:!1}}}))}async stat(e){const i=await this.withProvider(e),t=await i.stat(e);return this.toFileStat(i,e,t,void 0,!0,()=>!1)}async exists(e){const i=await this.withProvider(e);try{return!!await i.stat(e)}catch{return!1}}async canCreateFile(e,i){try{await this.doValidateCreateFile(e,i)}catch(t){return t}return!0}async doValidateCreateFile(e,i){if(!i?.overwrite&&await this.exists(e))throw new c(d("fileExists","Unable to create file '{0}' that already exists when overwrite flag is not set",this.resourceForError(e)),p.FILE_MODIFIED_SINCE,i)}async createFile(e,i=h.fromString(""),t){await this.doValidateCreateFile(e,t);const r=await this.writeFile(e,i);return this._onDidRunOperation.fire(new R(e,F.CREATE,r)),r}async writeFile(e,i,t){const r=this.throwIfFileSystemIsReadonly(await this.withWriteProvider(e),e),{providerExtUri:a}=this.getExtUri(r);let o=t;if(Y(r)&&!o?.atomic){const s=r.enforceAtomicWriteFile?.(e);s&&(o={...t,atomic:s})}try{await this.validateWriteFile(r,e,o)||await this.mkdirp(r,a.dirname(e));let n;if(m(r)&&!(i instanceof h))if(B(i)){const l=await ve(i,3);l.ended?n=h.concat(l.buffer):n=l}else n=Ie(i,l=>h.concat(l),3);else n=i;!I(r)||m(r)&&n instanceof h||m(r)&&Y(r)&&o?.atomic?await this.doWriteUnbuffered(r,e,o,n):await this.doWriteBuffered(r,e,o,n instanceof h?ie(n):n),this._onDidRunOperation.fire(new R(e,F.WRITE))}catch(s){throw new c(d("err.write","Unable to write file '{0}' ({1})",this.resourceForError(e),w(s).toString()),j(s),o)}return this.resolve(e,{resolveMetadata:!0})}async validateWriteFile(e,i,t){const r=!!t?.unlock;if(r&&!(e.capabilities&u.FileWriteUnlock))throw new Error(d("writeFailedUnlockUnsupported","Unable to unlock file '{0}' because provider does not support it.",this.resourceForError(i)));if(!!t?.atomic){if(!(e.capabilities&u.FileAtomicWrite))throw new Error(d("writeFailedAtomicUnsupported1","Unable to atomically write file '{0}' because provider does not support it.",this.resourceForError(i)));if(!(e.capabilities&u.FileReadWrite))throw new Error(d("writeFailedAtomicUnsupported2","Unable to atomically write file '{0}' because provider does not support unbuffered writes.",this.resourceForError(i)));if(r)throw new Error(d("writeFailedAtomicUnlock","Unable to unlock file '{0}' because atomic write is enabled.",this.resourceForError(i)))}let o;try{o=await e.stat(i)}catch{return}if(o.type&P.Directory)throw new c(d("fileIsDirectoryWriteError","Unable to write file '{0}' that is actually a directory",this.resourceForError(i)),p.FILE_IS_DIRECTORY,t);if(this.throwIfFileIsReadonly(i,o),typeof t?.mtime=="number"&&typeof t.etag=="string"&&t.etag!==T&&typeof o.mtime=="number"&&typeof o.size=="number"&&t.mtime<o.mtime&&t.etag!==z({mtime:t.mtime,size:o.size}))throw new c(d("fileModifiedError","File Modified Since"),p.FILE_MODIFIED_SINCE,t);return o}async readFile(e,i,t){const r=await this.withReadProvider(e);return i?.atomic?this.doReadFileAtomic(r,e,i,t):this.doReadFile(r,e,i,t)}async doReadFileAtomic(e,i,t,r){return new Promise((a,o)=>{this.writeQueue.queueFor(i,async()=>{try{const s=await this.doReadFile(e,i,t,r);a(s)}catch(s){o(s)}},this.getExtUri(e).providerExtUri)})}async doReadFile(e,i,t,r){const a=await this.doReadFileStream(e,i,{...t,preferUnbuffered:!0},r);return{...a,value:await D(a.value)}}async readFileStream(e,i,t){const r=await this.withReadProvider(e);return this.doReadFileStream(r,e,i,t)}async doReadFileStream(e,i,t,r){const a=new oe(r);let o=t;M(e)&&e.enforceAtomicReadFile?.(i)&&(o={...t,atomic:!0});const s=this.validateReadFile(i,o).then(l=>l,l=>{throw a.dispose(!0),l});let n;try{return typeof o?.etag=="string"&&o.etag!==T&&await s,o?.atomic&&M(e)||!(I(e)||V(e))||m(e)&&o?.preferUnbuffered?n=this.readFileUnbuffered(e,i,o):V(e)?n=this.readFileStreamed(e,i,a.token,o):n=this.readFileBuffered(e,i,a.token,o),n.on("end",()=>a.dispose()),n.on("error",()=>a.dispose()),{...await s,value:n}}catch(l){throw n&&await ye(n),this.restoreReadError(l,i,o)}}restoreReadError(e,i,t){const r=d("err.read","Unable to read file '{0}' ({1})",this.resourceForError(i),w(e).toString());return e instanceof A?new A(r,e.stat,t):e instanceof L?new L(r,e.fileOperationResult,e.size,e.options):new c(r,j(e),t)}readFileStreamed(e,i,t,r=Object.create(null)){const a=e.readFileStream(i,r,t);return we(a,{data:o=>o instanceof h?o:h.wrap(o),error:o=>this.restoreReadError(o,i,r)},o=>h.concat(o))}readFileBuffered(e,i,t,r=Object.create(null)){const a=te();return Ce(e,i,a,o=>o,{...r,bufferSize:this.BUFFER_SIZE,errorTransformer:o=>this.restoreReadError(o,i,r)},t),a}readFileUnbuffered(e,i,t){const r=ue(a=>h.concat(a));return(async()=>{try{let a;t?.atomic&&M(e)?a=await e.readFile(i,{atomic:!0}):a=await e.readFile(i),typeof t?.position=="number"&&(a=a.slice(t.position)),typeof t?.length=="number"&&(a=a.slice(0,t.length)),this.validateReadFileLimits(i,a.byteLength,t),r.end(h.wrap(a))}catch(a){r.error(a),r.end()}})(),r}async validateReadFile(e,i){const t=await this.resolve(e,{resolveMetadata:!0});if(t.isDirectory)throw new c(d("fileIsDirectoryReadError","Unable to read file '{0}' that is actually a directory",this.resourceForError(e)),p.FILE_IS_DIRECTORY,i);if(typeof i?.etag=="string"&&i.etag!==T&&i.etag===t.etag)throw new A(d("fileNotModifiedError","File not modified since"),t,i);return this.validateReadFileLimits(e,t.size,i),t}validateReadFileLimits(e,i,t){if(typeof t?.limits?.size=="number"&&i>t.limits.size)throw new L(d("fileTooLargeError","Unable to read file '{0}' that is too large to open",this.resourceForError(e)),p.FILE_TOO_LARGE,i,t)}async canMove(e,i,t){return this.doCanMoveCopy(e,i,"move",t)}async canCopy(e,i,t){return this.doCanMoveCopy(e,i,"copy",t)}async doCanMoveCopy(e,i,t,r){if(e.toString()!==i.toString())try{const a=t==="move"?this.throwIfFileSystemIsReadonly(await this.withWriteProvider(e),e):await this.withReadProvider(e),o=this.throwIfFileSystemIsReadonly(await this.withWriteProvider(i),i);await this.doValidateMoveCopy(a,e,o,i,t,r)}catch(a){return a}return!0}async move(e,i,t){const r=this.throwIfFileSystemIsReadonly(await this.withWriteProvider(e),e),a=this.throwIfFileSystemIsReadonly(await this.withWriteProvider(i),i),o=await this.doMoveCopy(r,e,a,i,"move",!!t),s=await this.resolve(i,{resolveMetadata:!0});return this._onDidRunOperation.fire(new R(e,o==="move"?F.MOVE:F.COPY,s)),s}async copy(e,i,t){const r=await this.withReadProvider(e),a=this.throwIfFileSystemIsReadonly(await this.withWriteProvider(i),i),o=await this.doMoveCopy(r,e,a,i,"copy",!!t),s=await this.resolve(i,{resolveMetadata:!0});return this._onDidRunOperation.fire(new R(e,o==="copy"?F.COPY:F.MOVE,s)),s}async doMoveCopy(e,i,t,r,a,o){if(i.toString()===r.toString())return a;const{exists:s,isSameResourceWithDifferentPathCase:n}=await this.doValidateMoveCopy(e,i,t,r,a,o);if(s&&!n&&o&&await this.del(r,{recursive:!0}),await this.mkdirp(t,this.getExtUri(t).providerExtUri.dirname(r)),a==="copy"){if(e===t&&H(e))await e.copy(i,r,{overwrite:o});else{const l=await this.resolve(i);l.isDirectory?await this.doCopyFolder(e,l,t,r):await this.doCopyFile(e,i,t,r)}return a}else return e===t?(await e.rename(i,r,{overwrite:o}),a):(await this.doMoveCopy(e,i,t,r,"copy",o),await this.del(i,{recursive:!0}),"copy")}async doCopyFile(e,i,t,r){if(I(e)&&I(t))return this.doPipeBuffered(e,i,t,r);if(I(e)&&m(t))return this.doPipeBufferedToUnbuffered(e,i,t,r);if(m(e)&&I(t))return this.doPipeUnbufferedToBuffered(e,i,t,r);if(m(e)&&m(t))return this.doPipeUnbuffered(e,i,t,r)}async doCopyFolder(e,i,t,r){await t.mkdir(r),Array.isArray(i.children)&&await b.settled(i.children.map(async a=>{const o=this.getExtUri(t).providerExtUri.joinPath(r,a.name);return a.isDirectory?this.doCopyFolder(e,await this.resolve(a.resource),t,o):this.doCopyFile(e,a.resource,t,o)}))}async doValidateMoveCopy(e,i,t,r,a,o){let s=!1;if(e===t){const{providerExtUri:l,isPathCaseSensitive:f}=this.getExtUri(e);if(f||(s=l.isEqual(i,r)),s&&a==="copy")throw new Error(d("unableToMoveCopyError1","Unable to copy when source '{0}' is same as target '{1}' with different path case on a case insensitive file system",this.resourceForError(i),this.resourceForError(r)));if(!s&&l.isEqualOrParent(r,i))throw new Error(d("unableToMoveCopyError2","Unable to move/copy when source '{0}' is parent of target '{1}'.",this.resourceForError(i),this.resourceForError(r)))}const n=await this.exists(r);if(n&&!s){if(!o)throw new c(d("unableToMoveCopyError3","Unable to move/copy '{0}' because target '{1}' already exists at destination.",this.resourceForError(i),this.resourceForError(r)),p.FILE_MOVE_CONFLICT);if(e===t){const{providerExtUri:l}=this.getExtUri(e);if(l.isEqualOrParent(i,r))throw new Error(d("unableToMoveCopyError4","Unable to move/copy '{0}' into '{1}' since a file would replace the folder it is contained in.",this.resourceForError(i),this.resourceForError(r)))}}return{exists:n,isSameResourceWithDifferentPathCase:s}}getExtUri(e){const i=this.isPathCaseSensitive(e);return{providerExtUri:i?ce:pe,isPathCaseSensitive:i}}isPathCaseSensitive(e){return!!(e.capabilities&u.PathCaseSensitive)}async createFolder(e){const i=this.throwIfFileSystemIsReadonly(await this.withProvider(e),e);await this.mkdirp(i,e);const t=await this.resolve(e,{resolveMetadata:!0});return this._onDidRunOperation.fire(new R(e,F.CREATE,t)),t}async mkdirp(e,i){const t=[],{providerExtUri:r}=this.getExtUri(e);for(;!r.isEqual(i,r.dirname(i));)try{if(!((await e.stat(i)).type&P.Directory))throw new Error(d("mkdirExistsError","Unable to create folder '{0}' that already exists but is not a directory",this.resourceForError(i)));break}catch(a){if(k(a)!==x.FileNotFound)throw a;t.push(r.basename(i)),i=r.dirname(i)}for(let a=t.length-1;a>=0;a--){i=r.joinPath(i,t[a]);try{await e.mkdir(i)}catch(o){if(k(o)!==x.FileExists)throw o}}}async canDelete(e,i){try{await this.doValidateDelete(e,i)}catch(t){return t}return!0}async doValidateDelete(e,i){const t=this.throwIfFileSystemIsReadonly(await this.withProvider(e),e),r=!!i?.useTrash;if(r&&!(t.capabilities&u.Trash))throw new Error(d("deleteFailedTrashUnsupported","Unable to delete file '{0}' via trash because provider does not support it.",this.resourceForError(e)));const a=i?.atomic;if(a&&!(t.capabilities&u.FileAtomicDelete))throw new Error(d("deleteFailedAtomicUnsupported","Unable to delete file '{0}' atomically because provider does not support it.",this.resourceForError(e)));if(r&&a)throw new Error(d("deleteFailedTrashAndAtomicUnsupported","Unable to atomically delete file '{0}' because using trash is enabled.",this.resourceForError(e)));let o;try{o=await t.stat(e)}catch{}if(o)this.throwIfFileIsReadonly(e,o);else throw new c(d("deleteFailedNotFound","Unable to delete nonexistent file '{0}'",this.resourceForError(e)),p.FILE_NOT_FOUND);if(!!!i?.recursive){const n=await this.resolve(e);if(n.isDirectory&&Array.isArray(n.children)&&n.children.length>0)throw new Error(d("deleteFailedNonEmptyFolder","Unable to delete non-empty folder '{0}'.",this.resourceForError(e)))}return t}async del(e,i){const t=await this.doValidateDelete(e,i);let r=i;if(be(t)&&!r?.atomic){const n=t.enforceAtomicDelete?.(e);n&&(r={...i,atomic:n})}const a=!!r?.useTrash,o=!!r?.recursive,s=r?.atomic??!1;await t.delete(e,{recursive:o,useTrash:a,atomic:s}),this._onDidRunOperation.fire(new R(e,F.DELETE))}async cloneFile(e,i){const t=await this.withProvider(e),r=this.throwIfFileSystemIsReadonly(await this.withWriteProvider(i),i);if(!(t===r&&this.getExtUri(t).providerExtUri.isEqual(e,i)))return t===r&&Se(t)?t.cloneFile(e,i):(await this.mkdirp(r,this.getExtUri(r).providerExtUri.dirname(i)),t===r&&H(t)?this.writeQueue.queueFor(e,()=>t.copy(e,i,{overwrite:!0}),this.getExtUri(t).providerExtUri):this.writeQueue.queueFor(e,()=>this.doCopyFile(t,e,r,i),this.getExtUri(t).providerExtUri))}internalOnDidFilesChange=this._register(new y);_onDidUncorrelatedFilesChange=this._register(new y);onDidFilesChange=this._onDidUncorrelatedFilesChange.event;_onDidWatchError=this._register(new y);onDidWatchError=this._onDidWatchError.event;activeWatchers=new Map;static WATCHER_CORRELATION_IDS=0;createWatcher(e,i){return this.watch(e,{...i,correlationId:S.WATCHER_CORRELATION_IDS++})}watch(e,i={recursive:!1,excludes:[]}){const t=new q;let r=!1,a=()=>{r=!0};t.add(O(()=>a())),(async()=>{try{const s=await this.doWatch(e,i);r?C(s):a=()=>C(s)}catch(s){this.logService.error(s)}})();const o=i.correlationId;if(typeof o=="number"){const s=t.add(new y);return t.add(this.internalOnDidFilesChange.event(l=>{l.correlates(o)&&s.fire(l)})),{onDidChange:s.event,dispose:()=>t.dispose()}}return t}async doWatch(e,i){const t=await this.withProvider(e),r=se([this.getExtUri(t).providerExtUri.getComparisonKey(e),i]);let a=this.activeWatchers.get(r);return a||(a={count:0,disposable:t.watch(e,i)},this.activeWatchers.set(r,a)),a.count+=1,O(()=>{a&&(a.count--,a.count===0&&(C(a.disposable),this.activeWatchers.delete(r)))})}dispose(){super.dispose();for(const[,e]of this.activeWatchers)C(e.disposable);this.activeWatchers.clear()}writeQueue=this._register(new X);async doWriteBuffered(e,i,t,r){return this.writeQueue.queueFor(i,async()=>{const a=await e.open(i,{create:!0,unlock:t?.unlock??!1});try{B(r)||g(r)?await this.doWriteStreamBufferedQueued(e,a,r):await this.doWriteReadableBufferedQueued(e,a,r)}catch(o){throw w(o)}finally{await e.close(a)}},this.getExtUri(e).providerExtUri)}async doWriteStreamBufferedQueued(e,i,t){let r=0,a;if(g(t)){if(t.buffer.length>0){const o=h.concat(t.buffer);await this.doWriteBuffer(e,i,o,o.byteLength,r,0),r+=o.byteLength}if(t.ended)return;a=t.stream}else a=t;return new Promise((o,s)=>{Fe(a,{onData:async n=>{a.pause();try{await this.doWriteBuffer(e,i,n,n.byteLength,r,0)}catch(l){return s(l)}r+=n.byteLength,setTimeout(()=>a.resume())},onError:n=>s(n),onEnd:()=>o()})})}async doWriteReadableBufferedQueued(e,i,t){let r=0,a;for(;(a=t.read())!==null;)await this.doWriteBuffer(e,i,a,a.byteLength,r,0),r+=a.byteLength}async doWriteBuffer(e,i,t,r,a,o){let s=0;for(;s<r;){const n=await e.write(i,a+s,t.buffer,o+s,r-s);s+=n}}async doWriteUnbuffered(e,i,t,r){return this.writeQueue.queueFor(i,()=>this.doWriteUnbufferedQueued(e,i,t,r),this.getExtUri(e).providerExtUri)}async doWriteUnbufferedQueued(e,i,t,r){let a;r instanceof h?a=r:B(r)?a=await D(r):g(r)?a=await ee(r):a=re(r),await e.writeFile(i,a.buffer,{create:!0,overwrite:!0,unlock:t?.unlock??!1,atomic:t?.atomic??!1})}async doPipeBuffered(e,i,t,r){return this.writeQueue.queueFor(r,()=>this.doPipeBufferedQueued(e,i,t,r),this.getExtUri(t).providerExtUri)}async doPipeBufferedQueued(e,i,t,r){let a,o;try{a=await e.open(i,{create:!1}),o=await t.open(r,{create:!0,unlock:!1});const s=h.alloc(this.BUFFER_SIZE);let n=0,l=0,f=0;do f=await e.read(a,n,s.buffer,l,s.byteLength-l),await this.doWriteBuffer(t,o,s,f,n,l),n+=f,l+=f,l===s.byteLength&&(l=0);while(f>0)}catch(s){throw w(s)}finally{await b.settled([typeof a=="number"?e.close(a):Promise.resolve(),typeof o=="number"?t.close(o):Promise.resolve()])}}async doPipeUnbuffered(e,i,t,r){return this.writeQueue.queueFor(r,()=>this.doPipeUnbufferedQueued(e,i,t,r),this.getExtUri(t).providerExtUri)}async doPipeUnbufferedQueued(e,i,t,r){return t.writeFile(r,await e.readFile(i),{create:!0,overwrite:!0,unlock:!1,atomic:!1})}async doPipeUnbufferedToBuffered(e,i,t,r){return this.writeQueue.queueFor(r,()=>this.doPipeUnbufferedToBufferedQueued(e,i,t,r),this.getExtUri(t).providerExtUri)}async doPipeUnbufferedToBufferedQueued(e,i,t,r){const a=await t.open(r,{create:!0,unlock:!1});try{const o=await e.readFile(i);await this.doWriteBuffer(t,a,h.wrap(o),o.byteLength,0,0)}catch(o){throw w(o)}finally{await t.close(a)}}async doPipeBufferedToUnbuffered(e,i,t,r){const a=await D(this.readFileBuffered(e,i,ae.None));await this.doWriteUnbuffered(t,r,void 0,a)}throwIfFileSystemIsReadonly(e,i){if(e.capabilities&u.Readonly)throw new c(d("err.readonly","Unable to modify read-only file '{0}'",this.resourceForError(i)),p.FILE_PERMISSION_DENIED);return e}throwIfFileIsReadonly(e,i){if((i.permissions??0)&_.Readonly)throw new c(d("err.readonly","Unable to modify read-only file '{0}'",this.resourceForError(e)),p.FILE_PERMISSION_DENIED)}resourceForError(e){return e.scheme===he.file?e.fsPath:e.toString(!0)}};S=N([Q(0,Pe)],S);export{S as FileService};
