import{Emitter as g}from"../../../base/common/event.js";import{Iterable as l}from"../../../base/common/iterator.js";import"../../../base/common/jsonSchema.js";import{toDisposable as p}from"../../../base/common/lifecycle.js";import{LinkedList as C}from"../../../base/common/linkedList.js";import{validateConstraints as I}from"../../../base/common/types.js";import"../../action/common/action.js";import{createDecorator as f}from"../../instantiation/common/instantiation.js";const y=f("commandService"),s=new class{_commands=new Map;_onDidRegisterCommand=new g;onDidRegisterCommand=this._onDidRegisterCommand.event;registerCommand(n,e){if(!n)throw new Error("invalid command");if(typeof n=="string"){if(!e)throw new Error("invalid command");return this.registerCommand({id:n,handler:e})}if(n.metadata&&Array.isArray(n.metadata.args)){const a=[];for(const o of n.metadata.args)a.push(o.constraint);const c=n.handler;n.handler=function(o,...m){return I(m,a),c(o,...m)}}const{id:t}=n;let r=this._commands.get(t);r||(r=new C,this._commands.set(t,r));const i=r.unshift(n),d=p(()=>{i(),this._commands.get(t)?.isEmpty()&&this._commands.delete(t)});return this._onDidRegisterCommand.fire(t),d}registerCommandAlias(n,e){return s.registerCommand(n,(t,...r)=>t.get(y).executeCommand(e,...r))}getCommand(n){const e=this._commands.get(n);if(!(!e||e.isEmpty()))return l.first(e)}getCommands(){const n=new Map;for(const e of this._commands.keys()){const t=this.getCommand(e);t&&n.set(e,t)}return n}};s.registerCommand("noop",()=>{});export{s as CommandsRegistry,y as ICommandService};
