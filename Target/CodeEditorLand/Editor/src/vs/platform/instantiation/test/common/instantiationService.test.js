var U=Object.defineProperty;var V=Object.getOwnPropertyDescriptor;var v=(e,n,c,o)=>{for(var s=o>1?void 0:o?V(n,c):n,i=e.length-1,r;i>=0;i--)(r=e[i])&&(s=(o?r(n,c,s):r(s))||s);return o&&s&&U(n,c,s),s},l=(e,n)=>(c,o)=>n(c,o,e);import t from"assert";import{Emitter as x}from"../../../../base/common/event.js";import{dispose as N}from"../../../../base/common/lifecycle.js";import{ensureNoDisposablesAreLeakedInTestSuite as Y}from"../../../../base/test/common/utils.js";import{SyncDescriptor as f}from"../../common/descriptors.js";import{createDecorator as w,IInstantiationService as j}from"../../common/instantiation.js";import{InstantiationService as u}from"../../common/instantiationService.js";import{ServiceCollection as d}from"../../common/serviceCollection.js";const a=w("service1");class B{c=1}const p=w("service2");class D{d=!0}const G=w("service3");class O{s="farboo"}const S=w("dependentService");let m=class{constructor(n){t.strictEqual(n.c,1)}name="farboo"};m=v([l(0,a)],m);let y=class{constructor(n){t.ok(n),t.strictEqual(n.c,1)}};y=v([l(0,a)],y);let b=class{constructor(n,c){t.ok(n instanceof B),t.ok(c instanceof D)}};b=v([l(0,a),l(1,p)],b);let g=class{constructor(n,c){t.ok(n),t.ok(c),t.strictEqual(c.c,1)}};g=v([l(1,a)],g);let A=class{constructor(n){t.ok(n),t.strictEqual(n.name,"farboo")}};A=v([l(0,S)],A);let q=class{constructor(n,c){t.ok(n),t.strictEqual(n.name,"farboo"),t.ok(c),t.strictEqual(c.c,1)}};q=v([l(0,S),l(1,a)],q);let F=class{c=1;constructor(n){}};F=v([l(0,p)],F);let R=class{d=!0;constructor(n){}};R=v([l(0,a)],R),suite("Instantiation Service",()=>{test("service collection, cannot overwrite",function(){const e=new d;let n=e.set(a,null);t.strictEqual(n,void 0),n=e.set(a,new B),t.strictEqual(n,null)}),test("service collection, add/has",function(){const e=new d;e.set(a,null),t.ok(e.has(a)),e.set(p,null),t.ok(e.has(a)),t.ok(e.has(p))}),test("@Param - simple clase",function(){const e=new d,n=new u(e);e.set(a,new B),e.set(p,new D),e.set(G,new O),n.createInstance(y)}),test("@Param - fixed args",function(){const e=new d,n=new u(e);e.set(a,new B),e.set(p,new D),e.set(G,new O),n.createInstance(g,!0)}),test("service collection is live",function(){const e=new d;e.set(a,new B);const n=new u(e);n.createInstance(y),e.set(p,new D),n.createInstance(b),n.invokeFunction(function(c){t.ok(c.get(a)),t.ok(c.get(p))})}),test("SyncDesc - no dependencies",function(){const e=new d,n=new u(e);e.set(a,new f(B)),n.invokeFunction(c=>{const o=c.get(a);t.ok(o),t.strictEqual(o.c,1);const s=c.get(a);t.ok(o===s)})}),test("SyncDesc - service with service dependency",function(){const e=new d,n=new u(e);e.set(a,new f(B)),e.set(S,new f(m)),n.invokeFunction(c=>{const o=c.get(S);t.ok(o),t.strictEqual(o.name,"farboo")})}),test("SyncDesc - target depends on service future",function(){const e=new d,n=new u(e);e.set(a,new f(B)),e.set(S,new f(m));const c=n.createInstance(A);t.ok(c instanceof A);const o=n.createInstance(q);t.ok(o instanceof q)}),test("SyncDesc - explode on loop",function(){const e=new d,n=new u(e);e.set(a,new f(F)),e.set(p,new f(R)),t.throws(()=>{n.invokeFunction(c=>{c.get(a)})}),t.throws(()=>{n.invokeFunction(c=>{c.get(p)})});try{n.invokeFunction(c=>{c.get(a)})}catch(c){t.ok(c.name),t.ok(c.message)}}),test("Invoke - get services",function(){const e=new d,n=new u(e);e.set(a,new B),e.set(p,new D);function c(o){return t.ok(o.get(a)instanceof B),t.strictEqual(o.get(a).c,1),!0}t.strictEqual(n.invokeFunction(c),!0)}),test("Invoke - get service, optional",function(){const e=new d([a,new B]),n=new u(e);function c(o){return t.ok(o.get(a)instanceof B),t.throws(()=>o.get(p)),!0}t.strictEqual(n.invokeFunction(c),!0)}),test("Invoke - keeping accessor NOT allowed",function(){const e=new d,n=new u(e);e.set(a,new B),e.set(p,new D);let c;function o(s){return t.ok(s.get(a)instanceof B),t.strictEqual(s.get(a).c,1),c=s,!0}t.strictEqual(n.invokeFunction(o),!0),t.throws(()=>c.get(p))}),test("Invoke - throw error",function(){const e=new d,n=new u(e);e.set(a,new B),e.set(p,new D);function c(o){throw new Error}t.throws(()=>n.invokeFunction(c))}),test("Create child",function(){let e=0;const n=class{c=1;constructor(){e+=1}};let c=new u(new d([a,new f(n)]));c.createInstance(y);let o=c.createChild(new d([p,new D]));o.createInstance(y),t.strictEqual(e,1),e=0,c=new u(new d([a,new f(n)])),o=c.createChild(new d([p,new D])),c.createInstance(y),o.createInstance(y),t.strictEqual(e,1)}),test("Remote window / integration tests is broken #105562",function(){const e=w("service1");let n=class{constructor(h){const E=h.invokeFunction(_=>_.get(c));t.ok(E)}};n=v([l(0,j)],n);const c=w("service2");class o{constructor(){}}const s=w("service21");let i=class{constructor(h,E){this.service2=h;this.service1=E}};i=v([l(0,c),l(1,e)],i);const I=new u(new d([e,new f(n)],[c,new f(o)],[s,new f(i)])).invokeFunction(k=>k.get(s));t.ok(I)}),test("Sync/Async dependency loop",async function(){const e=w("A"),n=w("B");let c=class{constructor(r){this.b=r}doIt(){return this.b.b()}};c=v([l(0,n)],c);let o=class{_serviceBrand;prop;constructor(r){this.prop=r.createInstance(c)}doIt(){return this.prop.doIt()}};o=v([l(0,j)],o);let s=class{_serviceBrand;constructor(r){t.ok(r)}b(){return!0}};s=v([l(0,e)],s);{const i=new u(new d([e,new f(o)],[n,new f(s)]),!0,void 0,!0);try{i.invokeFunction(r=>r.get(e)),t.ok(!1)}catch(r){t.ok(r instanceof Error),t.ok(r.message.includes("RECURSIVELY"))}}{const i=new u(new d([e,new f(o,void 0,!0)],[n,new f(s,void 0)]),!0,void 0,!0);i.invokeFunction(k=>k.get(e)).doIt();const I=i._globalGraph?.findCycleSlow();t.strictEqual(I,"A -> B -> A")}}),test("Delayed and events",function(){const e=w("A");let n=!1;class c{_serviceBrand;_doIt=0;_onDidDoIt=new x;onDidDoIt=this._onDidDoIt.event;constructor(){n=!0}doIt(){this._doIt+=1,this._onDidDoIt.fire(this)}}const o=new u(new d([e,new f(c,void 0,!0)]),!0,void 0,!0);let s=class{constructor(z){this.a=z}};s=v([l(0,e)],s);const i=o.createInstance(s);let r=0;const I=_=>{t.ok(_ instanceof c),r++},k=i.a.onDidDoIt(I),h=i.a.onDidDoIt(I);t.strictEqual(n,!1),t.strictEqual(r,0),h.dispose(),i.a.doIt(),t.strictEqual(n,!0),t.strictEqual(r,1);const E=i.a.onDidDoIt(I);i.a.doIt(),t.strictEqual(r,3),N([k,E])}),test("Capture event before init, use after init",function(){const e=w("A");let n=!1;class c{_serviceBrand;_doIt=0;_onDidDoIt=new x;onDidDoIt=this._onDidDoIt.event;constructor(){n=!0}doIt(){this._doIt+=1,this._onDidDoIt.fire(this)}noop(){}}const o=new u(new d([e,new f(c,void 0,!0)]),!0,void 0,!0);let s=class{constructor(_){this.a=_}};s=v([l(0,e)],s);const i=o.createInstance(s);let r=0;const I=E=>{t.ok(E instanceof c),r++},k=i.a.onDidDoIt;t.strictEqual(n,!1),i.a.noop(),t.strictEqual(n,!0);const h=k(I);i.a.doIt(),t.strictEqual(r,1),N(h)}),test("Dispose early event listener",function(){const e=w("A");let n=!1;class c{_serviceBrand;_doIt=0;_onDidDoIt=new x;onDidDoIt=this._onDidDoIt.event;constructor(){n=!0}doIt(){this._doIt+=1,this._onDidDoIt.fire(this)}}const o=new u(new d([e,new f(c,void 0,!0)]),!0,void 0,!0);let s=class{constructor(E){this.a=E}};s=v([l(0,e)],s);const i=o.createInstance(s);let r=0;const I=h=>{t.ok(h instanceof c),r++},k=i.a.onDidDoIt(I);t.strictEqual(n,!1),t.strictEqual(r,0),i.a.doIt(),t.strictEqual(n,!0),t.strictEqual(r,1),N(k),i.a.doIt(),t.strictEqual(r,1)}),test("Dispose services it created",function(){let e=!1,n=!1;const c=w("A");class o{_serviceBrand;value=1;dispose(){e=!0}}const s=w("B");class i{_serviceBrand;value=1;dispose(){n=!0}}const r=new u(new d([c,new f(o,void 0,!0)],[s,new i]),!0,void 0,!0);let I=class{constructor(E,_){this.a=E;this.b=_;t.strictEqual(E.value,_.value)}};I=v([l(0,c),l(1,s)],I);const k=r.createInstance(I);r.dispose(),t.ok(k),t.strictEqual(e,!0),t.strictEqual(n,!1)}),test("Disposed service cannot be used anymore",function(){const e=w("B");class n{_serviceBrand;value=1}const c=new u(new d([e,new n]),!0,void 0,!0);let o=class{constructor(r){this.b=r;t.strictEqual(r.value,1)}};o=v([l(0,e)],o);const s=c.createInstance(o);t.ok(s),c.dispose(),t.throws(()=>c.createInstance(o)),t.throws(()=>c.invokeFunction(i=>{})),t.throws(()=>c.createChild(new d))}),test("Child does not dispose parent",function(){const e=w("B");class n{_serviceBrand;value=1}const c=new u(new d([e,new n]),!0,void 0,!0),o=c.createChild(new d);let s=class{constructor(r){this.b=r;t.strictEqual(r.value,1)}};s=v([l(0,e)],s),t.ok(c.createInstance(s)),t.ok(o.createInstance(s)),o.dispose(),t.ok(c.createInstance(s)),t.throws(()=>o.createInstance(s))}),test("Parent does dispose children",function(){const e=w("B");class n{_serviceBrand;value=1}const c=new u(new d([e,new n]),!0,void 0,!0),o=c.createChild(new d);let s=class{constructor(r){this.b=r;t.strictEqual(r.value,1)}};s=v([l(0,e)],s),t.ok(c.createInstance(s)),t.ok(o.createInstance(s)),c.dispose(),t.throws(()=>o.createInstance(s)),t.throws(()=>c.createInstance(s))}),Y()});
