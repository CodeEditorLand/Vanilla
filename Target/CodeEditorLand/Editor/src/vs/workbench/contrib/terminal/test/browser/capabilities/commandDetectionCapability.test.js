import{deepStrictEqual as c,ok as w}from"assert";import{importAMDNodeModule as p}from"../../../../../../amdX.js";import{ensureNoDisposablesAreLeakedInTestSuite as u}from"../../../../../../base/test/common/utils.js";import"../../../../../../platform/terminal/common/capabilities/capabilities.js";import{CommandDetectionCapability as C}from"../../../../../../platform/terminal/common/capabilities/commandDetectionCapability.js";import{writeP as i}from"../../../browser/terminalTestHelpers.js";import{workbenchInstantiationService as b}from"../../../../../test/browser/workbenchTestServices.js";class x extends C{clearCommands(){this._commands.length=0}}suite("CommandDetectionCapability",()=>{const d=u();let n,a,s;function t(o){c(a.commands.map(e=>e.command),o.map(e=>e.command)),c(a.commands.map(e=>e.cwd),o.map(e=>e.cwd)),c(a.commands.map(e=>e.exitCode),o.map(e=>e.exitCode)),c(a.commands.map(e=>e.marker?.line),o.map(e=>e.marker?.line));for(const e of a.commands)w(Math.abs(Date.now()-e.timestamp)<2e3);c(s,a.commands),s.length=0,a.clearCommands()}async function m(o,e,l,h,f){h!==void 0&&a.setCwd(h),a.handlePromptStart(),await i(n,`\r${o}`),a.handleCommandStart(),await i(n,e),a.handleCommandExecuted(),await i(n,`\r
${l}\r
`),a.handleCommandFinished(f)}async function r(o){a.handlePromptStart(),await i(n,`\r${o}`),a.handleCommandStart()}setup(async()=>{const o=(await p("@xterm/xterm","lib/xterm.js")).Terminal;n=d.add(new o({allowProposedApi:!0,cols:80}));const e=b(void 0,d);a=d.add(e.createInstance(x,n)),s=[],d.add(a.onCommandFinished(l=>s.push(l))),t([])}),test("should not add commands when no capability methods are triggered",async()=>{await i(n,`foo\r
bar\r
`),t([]),await i(n,`baz\r
`),t([])}),test("should add commands for expected capability method calls",async()=>{await m("$ ","echo foo","foo",void 0,0),await r("$ "),t([{command:"echo foo",exitCode:0,cwd:void 0,marker:{line:0}}])}),test("should trim the command when command executed appears on the following line",async()=>{await m("$ ",`echo foo\r
`,"foo",void 0,0),await r("$ "),t([{command:"echo foo",exitCode:0,cwd:void 0,marker:{line:0}}])}),suite("cwd",()=>{test("should add cwd to commands when it's set",async()=>{await m("$ ","echo foo","foo","/home",0),await m("$ ","echo bar","bar","/home/second",0),await r("$ "),t([{command:"echo foo",exitCode:0,cwd:"/home",marker:{line:0}},{command:"echo bar",exitCode:0,cwd:"/home/second",marker:{line:2}}])}),test("should add old cwd to commands if no cwd sequence is output",async()=>{await m("$ ","echo foo","foo","/home",0),await m("$ ","echo bar","bar",void 0,0),await r("$ "),t([{command:"echo foo",exitCode:0,cwd:"/home",marker:{line:0}},{command:"echo bar",exitCode:0,cwd:"/home",marker:{line:2}}])}),test("should use an undefined cwd if it's not set initially",async()=>{await m("$ ","echo foo","foo",void 0,0),await m("$ ","echo bar","bar","/home",0),await r("$ "),t([{command:"echo foo",exitCode:0,cwd:void 0,marker:{line:0}},{command:"echo bar",exitCode:0,cwd:"/home",marker:{line:2}}])})})});
