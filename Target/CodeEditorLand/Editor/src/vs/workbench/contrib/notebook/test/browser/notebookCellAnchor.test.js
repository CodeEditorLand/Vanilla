import n from"assert";import"../../../../../base/common/scrollable.js";import{TestConfigurationService as C}from"../../../../../platform/configuration/test/common/testConfigurationService.js";import{CellFocusMode as s}from"../../browser/notebookBrowser.js";import{NotebookCellAnchor as p}from"../../browser/view/notebookCellAnchor.js";import{Emitter as f}from"../../../../../base/common/event.js";import"../../common/notebookExecutionStateService.js";import{CellKind as m,NotebookCellExecutionState as g,NotebookSetting as h}from"../../common/notebookCommon.js";import"../../browser/viewModel/codeCellViewModel.js";import{ensureNoDisposablesAreLeakedInTestSuite as v}from"../../../../../base/test/common/utils.js";import"../../../../../base/browser/ui/list/listView.js";suite("NotebookCellAnchor",()=>{const a=v();let i,r,c,d,e,l;setup(()=>{r=new C,c=new f,d=new f;const o={getCellExecution:()=>({state:g.Executing})};e={cellKind:m.Code,onDidStopExecution:d.event},i={focusMode:s.Container},l=a.add(new p(o,r,c.event))});class u{focusedCellTop=100;focusedCellHeight=50;renderTop=0;renderHeight=150;element(t){return i}elementTop(t){return this.focusedCellTop}elementHeight(t){return this.focusedCellHeight}getScrollTop(){return this.renderTop}}test("Basic anchoring",async function(){i.focusMode=s.Editor;const o=new u;n(l.shouldAnchor(o,1,-10,e),"should anchor if cell editor is focused"),n(l.shouldAnchor(o,1,10,e),"should anchor if cell editor is focused"),r.setUserConfiguration(h.scrollToRevealCell,"none"),n(l.shouldAnchor(o,1,10,e),"should anchor if cell editor is focused"),r.setUserConfiguration(h.scrollToRevealCell,"fullCell"),i.focusMode=s.Container,n(l.shouldAnchor(o,1,10,e),"should anchor if cell is growing"),i.focusMode=s.Output,n(l.shouldAnchor(o,1,10,e),"should anchor if cell is growing"),n(!l.shouldAnchor(o,1,-10,e),"should not anchor if not growing and editor not focused"),r.setUserConfiguration(h.scrollToRevealCell,"none"),n(!l.shouldAnchor(o,1,10,e),"should not anchor if scroll on execute is disabled")}),test("Anchor during execution until user scrolls up",async function(){const o=new u,t={oldScrollTop:100,scrollTop:150},w={oldScrollTop:200,scrollTop:150};n(l.shouldAnchor(o,1,10,e)),c.fire(t),n(l.shouldAnchor(o,1,10,e),"cell should still be anchored after scrolling down"),c.fire(w),n(!l.shouldAnchor(o,1,10,e),"cell should not be anchored after scrolling up"),i.focusMode=s.Editor,n(l.shouldAnchor(o,1,10,e),"cell should anchor again if the editor is focused"),i.focusMode=s.Container,d.fire(),n(l.shouldAnchor(o,1,10,e),"cell should anchor for new execution")}),test("Only anchor during when the focused cell will be pushed out of view",async function(){const o=new u;o.focusedCellTop=50;const t=o;n(!l.shouldAnchor(t,1,10,e),"should not anchor if focused cell will still be fully visible after resize"),i.focusMode=s.Editor,n(l.shouldAnchor(t,1,10,e),"cell should always anchor if the editor is focused"),n(l.shouldAnchor(t,1,150,e),"cell should be anchored if focused cell will be pushed out of view"),o.focusedCellTop=110,n(l.shouldAnchor(t,1,10,e),"cell should be anchored if focused cell will be pushed out of view")})});
