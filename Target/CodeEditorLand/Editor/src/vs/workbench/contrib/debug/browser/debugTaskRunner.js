var z=Object.defineProperty;var W=Object.getOwnPropertyDescriptor;var A=(g,c,e,i)=>{for(var r=i>1?void 0:i?W(c,e):c,n=g.length-1,t;n>=0;n--)(t=g[n])&&(r=(i?t(c,e,r):t(r))||r);return i&&r&&z(c,e,r),r},k=(g,c)=>(e,i)=>c(e,i,g);import{Action as B}from"../../../../base/common/actions.js";import{disposableTimeout as I}from"../../../../base/common/async.js";import{CancellationTokenSource as D}from"../../../../base/common/cancellation.js";import{createErrorWithActions as F}from"../../../../base/common/errorMessage.js";import{Emitter as N,Event as P}from"../../../../base/common/event.js";import{DisposableStore as O}from"../../../../base/common/lifecycle.js";import C from"../../../../base/common/severity.js";import*as a from"../../../../nls.js";import{ICommandService as K}from"../../../../platform/commands/common/commands.js";import{IConfigurationService as V}from"../../../../platform/configuration/common/configuration.js";import{IDialogService as G}from"../../../../platform/dialogs/common/dialogs.js";import{IMarkerService as U,MarkerSeverity as Y}from"../../../../platform/markers/common/markers.js";import{IProgressService as q,ProgressLocation as J}from"../../../../platform/progress/common/progress.js";import{IStorageService as H,StorageScope as R,StorageTarget as j}from"../../../../platform/storage/common/storage.js";import"../../../../platform/workspace/common/workspace.js";import{DEBUG_CONFIGURE_COMMAND_ID as _,DEBUG_CONFIGURE_LABEL as Q}from"./debugCommands.js";import"../common/debug.js";import{Markers as x}from"../../markers/common/markers.js";import{ConfiguringTask as X,CustomTask as Z,TaskEventKind as S}from"../../tasks/common/tasks.js";import{ITaskService as $}from"../../tasks/common/taskService.js";import{IViewsService as ee}from"../../../services/views/common/viewsService.js";const E=(g,c)=>P.once(P.filter(g,c));var re=(e=>(e[e.Failure=0]="Failure",e[e.Success=1]="Success",e))(re||{});const L="debug.taskerrorchoice",M=a.localize("abort","Abort"),ie=a.localize({key:"debugAnyway",comment:["&& denotes a mnemonic"]},"&&Debug Anyway"),te=a.localize("debugAnywayNoMemo","Debug Anyway");let T=class{constructor(c,e,i,r,n,t,u,l){this.taskService=c;this.markerService=e;this.configurationService=i;this.viewsService=r;this.dialogService=n;this.storageService=t;this.commandService=u;this.progressService=l}globalCancellation=new D;cancel(){this.globalCancellation.dispose(!0),this.globalCancellation=new D}dispose(){this.globalCancellation.dispose(!0)}async runTaskAndCheckErrors(c,e){try{const i=await this.runTask(c,e,this.globalCancellation.token);if(i&&(i.exitCode===void 0||i.cancelled))return 0;const r=e?this.markerService.read({severities:Y.Error,take:2}).length:0,n=i&&i.exitCode===0,t=i&&i.exitCode!==0,u=this.configurationService.getValue("debug").onTaskErrors;if(n||u==="debugAnyway"||r===0&&!t)return 1;if(u==="showErrors")return await this.viewsService.openView(x.MARKERS_VIEW_ID,!0),Promise.resolve(0);if(u==="abort")return Promise.resolve(0);const l=typeof e=="string"?e:e?e.name:"",p=r>1?a.localize("preLaunchTaskErrors","Errors exist after running preLaunchTask '{0}'.",l):r===1?a.localize("preLaunchTaskError","Error exists after running preLaunchTask '{0}'.",l):i&&typeof i.exitCode=="number"?a.localize("preLaunchTaskExitCode","The preLaunchTask '{0}' terminated with exit code {1}.",l,i.exitCode):a.localize("preLaunchTaskTerminated","The preLaunchTask '{0}' terminated.",l);let h;(f=>(f[f.DebugAnyway=1]="DebugAnyway",f[f.ShowErrors=2]="ShowErrors",f[f.Cancel=0]="Cancel"))(h||={});const{result:m,checkboxChecked:y}=await this.dialogService.prompt({type:C.Warning,message:p,buttons:[{label:ie,run:()=>1},{label:a.localize({key:"showErrors",comment:["&& denotes a mnemonic"]},"&&Show Errors"),run:()=>2}],cancelButton:{label:M,run:()=>0},checkbox:{label:a.localize("remember","Remember my choice in user settings")}}),o=m===1,s=m===0;return y&&this.configurationService.updateValue("debug.onTaskErrors",m===1?"debugAnyway":s?"abort":"showErrors"),s?Promise.resolve(0):o?1:(await this.viewsService.openView(x.MARKERS_VIEW_ID,!0),Promise.resolve(0))}catch(i){const r=this.taskService.configureAction(),n=JSON.parse(this.storageService.get(L,R.WORKSPACE,"{}"));let t=-1,u;if((m=>(m[m.DebugAnyway=0]="DebugAnyway",m[m.ConfigureTask=1]="ConfigureTask",m[m.Cancel=2]="Cancel"))(u||={}),n[i.message]!==void 0)t=n[i.message];else{const{result:l,checkboxChecked:p}=await this.dialogService.prompt({type:C.Error,message:i.message,buttons:[{label:a.localize({key:"debugAnyway",comment:["&& denotes a mnemonic"]},"&&Debug Anyway"),run:()=>0},{label:r.label,run:()=>1}],cancelButton:{run:()=>2},checkbox:{label:a.localize("rememberTask","Remember my choice for this task")}});t=l,p&&(n[i.message]=t,this.storageService.store(L,JSON.stringify(n),R.WORKSPACE,j.MACHINE))}return t===1&&await r.run(),t===0?1:0}}async runTask(c,e,i=this.globalCancellation.token){if(!e)return Promise.resolve(null);if(!c)return Promise.reject(new Error(a.localize("invalidTaskReference","Task '{0}' can not be referenced from a launch configuration that is in a different workspace folder.",typeof e=="string"?e:e.type)));const r=await this.taskService.getTask(c,e);if(!r){const o=typeof e=="string"?a.localize("DebugTaskNotFoundWithTaskId","Could not find the task '{0}'.",e):a.localize("DebugTaskNotFound","Could not find the specified task.");return Promise.reject(F(o,[new B(_,Q,void 0,!0,()=>this.commandService.executeCommand(_))]))}let n=!1;const t=new O,u=o=>o.getKey()??o.getMapKey(),l=u(r),p=new Promise(o=>t.add(E(this.taskService.onDidStateChange,s=>(s.kind===S.Inactive||s.kind===S.ProcessEnded&&s.exitCode===void 0)&&u(s.__task)===l)(s=>{n=!0,o(s.kind===S.ProcessEnded?{exitCode:s.exitCode}:null)})));t.add(E(this.taskService.onDidStateChange,o=>(o.kind===S.Active||o.kind===S.DependsOnStarted)&&u(o.__task)===l)(()=>{n=!0}));const h=t.add(new N);t.add(E(this.taskService.onDidStateChange,o=>o.kind===S.AcquiredInput&&u(o.__task)===l)(()=>h.fire()));const m=this.taskService.getActiveTasks().then(async o=>{if(o.find(d=>u(d)===l))return h.fire(),(await this.taskService.getBusyTasks()).find(v=>u(v)===l)?(n=!0,p):Promise.resolve(null);const s=this.taskService.run(r);return r.configurationProperties.isBackground?p:s.then(d=>d??null)}),y=new Promise((o,s)=>{m.then(d=>{n=!0,o(d)},d=>s(d)),t.add(i.onCancellationRequested(()=>{o({exitCode:void 0,cancelled:!0}),this.taskService.terminate(r).catch(()=>{})})),t.add(h.event(()=>{const d=r.configurationProperties.isBackground?5e3:1e4;t.add(I(()=>{if(!n){const v=a.localize("taskNotTracked","The task '{0}' has not exited and doesn't have a 'problemMatcher' defined. Make sure to define a problem matcher for watch tasks.",typeof e=="string"?e:JSON.stringify(e));s({severity:C.Error,message:v})}},d)),t.add(I(()=>{const v=a.localize("runningTask","Waiting for preLaunchTask '{0}'...",r.configurationProperties.name),w=[te,M],f=r instanceof Z||r instanceof X;f&&w.splice(1,0,a.localize("configureTask","Configure Task")),this.progressService.withProgress({location:J.Notification,title:v,buttons:w},()=>y.catch(()=>{}),b=>{b===void 0||(b===0?o({exitCode:0}):(o({exitCode:void 0,cancelled:!0}),this.taskService.terminate(r).catch(()=>{}),f&&b===1&&this.taskService.openConfig(r)))})},1e4))}))});return y.finally(()=>t.dispose())}};T=A([k(0,$),k(1,U),k(2,V),k(3,ee),k(4,G),k(5,H),k(6,K),k(7,q)],T);export{T as DebugTaskRunner,re as TaskRunResult};
