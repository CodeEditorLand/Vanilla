import{ok as T}from"assert";import{Emitter as S}from"../../../../../base/common/event.js";import{Disposable as k}from"../../../../../base/common/lifecycle.js";import{ensureNoDisposablesAreLeakedInTestSuite as v}from"../../../../../base/test/common/utils.js";import"../../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js";import{TestConfigurationService as h}from"../../../../../platform/configuration/test/common/testConfigurationService.js";import{TestInstantiationService as y}from"../../../../../platform/instantiation/test/common/instantiationServiceMock.js";import{ACTIVE_TASK_STATUS as u,FAILED_TASK_STATUS as I,SUCCEEDED_TASK_STATUS as l,TaskTerminalStatus as b}from"../../browser/taskTerminalStatus.js";import"../../common/problemCollectors.js";import{CommonTask as f,TaskEventKind as a,TaskRunType as g}from"../../common/tasks.js";import"../../common/taskService.js";import"../../../terminal/browser/terminal.js";import{TerminalStatusList as C}from"../../../terminal/browser/terminalStatusList.js";import"../../../terminal/common/terminal.js";class w{_onDidStateChange=new S;get onDidStateChange(){return this._onDidStateChange.event}triggerStateChange(t){this._onDidStateChange.fire(t)}}class E{async playSignal(t){}}class L extends k{statusList=this._register(new C(new h));constructor(){super()}dispose(){super.dispose()}}class P extends f{constructor(){super("test",void 0,void 0,{},{},{kind:"",label:""})}getFolderId(){throw new Error("Method not implemented.")}fromObject(t){throw new Error("Method not implemented.")}}class D extends k{_onDidFindFirstMatch=new S;onDidFindFirstMatch=this._onDidFindFirstMatch.event;_onDidFindErrors=new S;onDidFindErrors=this._onDidFindErrors.event;_onDidRequestInvalidateLastMarker=new S;onDidRequestInvalidateLastMarker=this._onDidRequestInvalidateLastMarker.event}suite("Task Terminal Status",()=>{let s,t,d,e,r,n,c;const o=v();setup(()=>{s=o.add(new y),t=new w,c=new E,d=o.add(new b(t,c)),e=o.add(s.createInstance(L)),r=s.createInstance(P),n=o.add(s.createInstance(D))}),test("Should add failed status when there is an exit code on task end",async()=>{d.addTerminal(r,e,n),t.triggerStateChange({kind:a.ProcessStarted}),i(e.statusList,u),t.triggerStateChange({kind:a.Inactive}),i(e.statusList,l),t.triggerStateChange({kind:a.End}),await p(async()=>Promise.resolve(),()=>e?.statusList.primary?.id===I.id,"terminal status should be updated")}),test("Should add active status when a non-background task is run for a second time in the same terminal",()=>{d.addTerminal(r,e,n),t.triggerStateChange({kind:a.ProcessStarted}),i(e.statusList,u),t.triggerStateChange({kind:a.Inactive}),i(e.statusList,l),t.triggerStateChange({kind:a.ProcessStarted,runType:g.SingleRun}),i(e.statusList,u),t.triggerStateChange({kind:a.Inactive}),i(e.statusList,l)}),test("Should drop status when a background task exits",async()=>{d.addTerminal(r,e,n),t.triggerStateChange({kind:a.ProcessStarted,runType:g.Background}),i(e.statusList,u),t.triggerStateChange({kind:a.Inactive}),i(e.statusList,l),t.triggerStateChange({kind:a.ProcessEnded,exitCode:0}),await p(async()=>Promise.resolve(),()=>e?.statusList.statuses?.includes(l)===!1,"terminal should have dropped status")}),test("Should add succeeded status when a non-background task exits",()=>{d.addTerminal(r,e,n),t.triggerStateChange({kind:a.ProcessStarted,runType:g.SingleRun}),i(e.statusList,u),t.triggerStateChange({kind:a.Inactive}),i(e.statusList,l),t.triggerStateChange({kind:a.ProcessEnded,exitCode:0}),i(e.statusList,l)})});function i(s,t){T(s.statuses.length===1,"# of statuses"),T(s.primary?.id===t.id,"ID"),T(s.primary?.severity===t.severity,"Severity")}async function p(s,t,d,e=200,r=10){let n=1,c="";for(;;){if(n>e)throw new Error(`Timeout: ${d} after ${e*r/1e3} seconds.\r${c}`);let o;try{if(o=await s(),t(o))return o;c="Did not pass accept function"}catch(m){c=Array.isArray(m.stack)?m.stack.join(`
`):m.stack}await new Promise(m=>setTimeout(m,r)),n++}}
