import t from"assert";import{Event as C,Emitter as P}from"../../../../../base/common/event.js";import{URI as g}from"../../../../../base/common/uri.js";import{StoredFileWorkingCopy as O,StoredFileWorkingCopyState as s,isStoredFileWorkingCopySaveEvent as F}from"../../common/storedFileWorkingCopy.js";import{bufferToStream as w,newWriteableBufferStream as H,streamToBuffer as T,VSBuffer as S}from"../../../../../base/common/buffer.js";import{CancellationToken as D}from"../../../../../base/common/cancellation.js";import{Disposable as x,DisposableStore as N}from"../../../../../base/common/lifecycle.js";import{getLastResolvedFileStat as k,TestServiceAccessor as b,workbenchInstantiationService as M}from"../../../../test/browser/workbenchTestServices.js";import"../../../../../platform/instantiation/common/instantiation.js";import{basename as _}from"../../../../../base/common/resources.js";import{FileChangesEvent as q,FileChangeType as m,FileOperationError as f,FileOperationResult as p,NotModifiedSinceFileOperationError as R}from"../../../../../platform/files/common/files.js";import{SaveReason as v,SaveSourceRegistry as B}from"../../../../common/editor.js";import{Promises as A,timeout as U}from"../../../../../base/common/async.js";import{consumeReadable as G,consumeStream as Y,isReadableStream as X}from"../../../../../base/common/stream.js";import{runWithFakedTimers as I}from"../../../../../base/test/common/timeTravelScheduler.js";import{ensureNoDisposablesAreLeakedInTestSuite as L}from"../../../../../base/test/common/utils.js";import"../../common/fileWorkingCopy.js";import{assertIsDefined as j}from"../../../../../base/common/types.js";class V extends x{constructor(n,c){super();this.resource=n;this.contents=c}_onDidChangeContent=this._register(new P);onDidChangeContent=this._onDidChangeContent.event;_onWillDispose=this._register(new P);onWillDispose=this._onWillDispose.event;fireContentChangeEvent(n){this._onDidChangeContent.fire(n)}updateContents(n){this.doUpdate(n)}throwOnSnapshot=!1;setThrowOnSnapshot(){this.throwOnSnapshot=!0}async snapshot(n,c){if(this.throwOnSnapshot)throw new Error("Fail");const a=H();return a.end(S.fromString(this.contents)),a}async update(n,c){this.doUpdate((await T(n)).toString())}doUpdate(n){this.contents=n,this.versionId++,this._onDidChangeContent.fire({isRedoing:!1,isUndoing:!1})}versionId=0;pushedStackElement=!1;pushStackElement(){this.pushedStackElement=!0}dispose(){this._onWillDispose.fire(),super.dispose()}}class z extends V{saveCounter=0;throwOnSave=!1;saveOperation=void 0;async save(o,n){if(this.throwOnSave)throw new Error("Fail");if(this.saveOperation&&await this.saveOperation,n.isCancellationRequested)throw new Error("Canceled");return this.saveCounter++,{resource:this.resource,ctime:0,etag:"",isDirectory:!1,isFile:!0,mtime:0,name:"resource2",size:0,isSymbolicLink:!1,readonly:!1,locked:!1,children:void 0}}}class J{async createModel(o,n,c){return new V(o,(await T(n)).toString())}}class K{async createModel(o,n,c){return new z(o,(await T(n)).toString())}}suite("StoredFileWorkingCopy (with custom save)",function(){const h=new K,o=new N;let n,c,a;setup(()=>{n=M(void 0,o),c=n.createInstance(b);const e=g.file("test/resource");a=o.add(new O("testStoredFileWorkingCopyType",e,_(e),h,d=>a.resolve(d),c.fileService,c.logService,c.workingCopyFileService,c.filesConfigurationService,c.workingCopyBackupService,c.workingCopyService,c.notificationService,c.workingCopyEditorService,c.editorService,c.elevatedFileService,c.progressService))}),teardown(()=>{o.clear()}),test("save (custom implemented)",async()=>{let e=0,d;o.add(a.onDidSave(r=>{e++,d=r}));let E=0;o.add(a.onDidSaveError(()=>{E++})),await a.save(),t.strictEqual(e,0),t.strictEqual(E,0),await a.resolve(),a.model?.updateContents("hello save"),await a.save(),t.strictEqual(e,1),t.strictEqual(E,0),t.strictEqual(a.isDirty(),!1),t.strictEqual(d.reason,v.EXPLICIT),t.ok(d.stat),t.ok(F(d)),t.strictEqual(a.model?.pushedStackElement,!0),t.strictEqual(a.model.saveCounter,1),a.model?.updateContents("hello save error"),a.model.throwOnSave=!0,await a.save(),t.strictEqual(E,1),t.strictEqual(a.hasState(s.ERROR),!0)}),test("save cancelled (custom implemented)",async()=>{let e=0,d;o.add(a.onDidSave(u=>{e++,d=u}));let E=0;o.add(a.onDidSaveError(()=>{E++})),await a.resolve();let r;a.model.saveOperation=new Promise(u=>r=u),a.model?.updateContents("first");const i=a.save();a.model?.updateContents("second");const l=a.save();r(),await i,await l,t.strictEqual(e,1),t.strictEqual(E,0),t.strictEqual(a.isDirty(),!1),t.strictEqual(d.reason,v.EXPLICIT),t.ok(d.stat),t.ok(F(d)),t.strictEqual(a.model?.pushedStackElement,!0),t.strictEqual(a.model.saveCounter,1)}),L()}),suite("StoredFileWorkingCopy",function(){const h=new J,o=new N,n=g.file("test/resource");let c,a,e;function d(r=n){const i=new O("testStoredFileWorkingCopyType",r,_(r),h,l=>i.resolve(l),a.fileService,a.logService,a.workingCopyFileService,a.filesConfigurationService,a.workingCopyBackupService,a.workingCopyService,a.notificationService,a.workingCopyEditorService,a.editorService,a.elevatedFileService,a.progressService);return i}setup(()=>{c=M(void 0,o),a=c.createInstance(b),e=o.add(d())}),teardown(()=>{e.dispose();for(const r of a.workingCopyService.workingCopies)r.dispose();o.clear()}),test("registers with working copy service",async()=>{t.strictEqual(a.workingCopyService.workingCopies.length,1),e.dispose(),t.strictEqual(a.workingCopyService.workingCopies.length,0)}),test("orphaned tracking",async()=>I({},async()=>{t.strictEqual(e.hasState(s.ORPHAN),!1);let r=C.toPromise(e.onDidChangeOrphaned);a.fileService.notExistsSet.set(n,!0),a.fileService.fireFileChanges(new q([{resource:n,type:m.DELETED}],!1)),await r,t.strictEqual(e.hasState(s.ORPHAN),!0),r=C.toPromise(e.onDidChangeOrphaned),a.fileService.notExistsSet.delete(n),a.fileService.fireFileChanges(new q([{resource:n,type:m.ADDED}],!1)),await r,t.strictEqual(e.hasState(s.ORPHAN),!1)})),test("dirty / modified",async()=>{t.strictEqual(e.isModified(),!1),t.strictEqual(e.isDirty(),!1),t.strictEqual(e.hasState(s.DIRTY),!1),await e.resolve(),t.strictEqual(e.isResolved(),!0);let r=0;o.add(e.onDidChangeDirty(()=>{r++}));let i=0;o.add(e.onDidChangeContent(()=>{i++}));let l=0;o.add(e.onDidSave(()=>{l++})),e.model?.updateContents("hello dirty"),t.strictEqual(i,1),t.strictEqual(e.isModified(),!0),t.strictEqual(e.isDirty(),!0),t.strictEqual(e.hasState(s.DIRTY),!0),t.strictEqual(r,1),await e.save(),t.strictEqual(e.isModified(),!1),t.strictEqual(e.isDirty(),!1),t.strictEqual(e.hasState(s.DIRTY),!1),t.strictEqual(r,2),t.strictEqual(l,1),await e.resolve({contents:w(S.fromString("hello dirty stream"))}),t.strictEqual(i,2),t.strictEqual(e.isModified(),!0),t.strictEqual(e.isDirty(),!0),t.strictEqual(e.hasState(s.DIRTY),!0),t.strictEqual(r,3),await e.revert({soft:!0}),t.strictEqual(e.isModified(),!1),t.strictEqual(e.isDirty(),!1),t.strictEqual(e.hasState(s.DIRTY),!1),t.strictEqual(r,4),e.markModified(),t.strictEqual(e.isModified(),!0),t.strictEqual(e.isDirty(),!0),t.strictEqual(e.hasState(s.DIRTY),!0),t.strictEqual(r,5),await e.revert(),t.strictEqual(e.isModified(),!1),t.strictEqual(e.isDirty(),!1),t.strictEqual(e.hasState(s.DIRTY),!1),t.strictEqual(r,6)}),test("dirty - working copy marks non-dirty when undo reaches saved version ID",async()=>{await e.resolve(),e.model?.updateContents("hello saved state"),await e.save(),t.strictEqual(e.isDirty(),!1),e.model?.updateContents("changing content once"),t.strictEqual(e.isDirty(),!0),e.model.versionId--,e.model?.fireContentChangeEvent({isRedoing:!1,isUndoing:!0}),t.strictEqual(e.isDirty(),!1)}),test("resolve (without backup)",async()=>{let r=0;o.add(e.onDidResolve(()=>{r++})),await e.resolve(),t.strictEqual(e.isResolved(),!0),t.strictEqual(r,1),t.strictEqual(e.model?.contents,"Hello Html"),e.model?.updateContents("hello resolve"),t.strictEqual(e.isDirty(),!0),await e.resolve(),t.strictEqual(r,1),t.strictEqual(e.model?.contents,"hello resolve"),await e.resolve({contents:w(S.fromString("hello initial contents"))}),t.strictEqual(e.isDirty(),!0),t.strictEqual(e.model?.contents,"hello initial contents"),t.strictEqual(r,2);const i=e.save();await e.resolve(),await i,t.strictEqual(e.isDirty(),!1),t.strictEqual(e.model?.contents,"hello initial contents"),t.strictEqual(r,2),e.dispose(),await e.resolve(),t.strictEqual(e.isDisposed(),!0),t.strictEqual(r,2)}),test("resolve (with backup)",async()=>{await e.resolve({contents:w(S.fromString("hello backup"))});const r=await e.backup(D.None);await a.workingCopyBackupService.backup(e,r.content,void 0,r.meta),t.strictEqual(a.workingCopyBackupService.hasBackupSync(e),!0),e.dispose(),e=d(),await e.resolve(),t.strictEqual(e.isDirty(),!0),t.strictEqual(e.isReadonly(),!1),t.strictEqual(e.model?.contents,"hello backup"),e.model.updateContents("hello updated"),await e.save(),await e.resolve(),t.strictEqual(e.isDirty(),!1),t.strictEqual(e.model?.contents,"Hello Html")}),test("resolve (with backup, preserves metadata and orphaned state)",async()=>I({},async()=>{await e.resolve({contents:w(S.fromString("hello backup"))});const r=C.toPromise(e.onDidChangeOrphaned);a.fileService.notExistsSet.set(n,!0),a.fileService.fireFileChanges(new q([{resource:n,type:m.DELETED}],!1)),await r,t.strictEqual(e.hasState(s.ORPHAN),!0);const i=await e.backup(D.None);await a.workingCopyBackupService.backup(e,i.content,void 0,i.meta),t.strictEqual(a.workingCopyBackupService.hasBackupSync(e),!0),e.dispose(),e=d(),await e.resolve(),t.strictEqual(e.hasState(s.ORPHAN),!0);const l=await e.backup(D.None);t.deepStrictEqual(i.meta,l.meta)})),test("resolve (updates orphaned state accordingly)",async()=>I({},async()=>{await e.resolve();const r=C.toPromise(e.onDidChangeOrphaned);a.fileService.notExistsSet.set(n,!0),a.fileService.fireFileChanges(new q([{resource:n,type:m.DELETED}],!1)),await r,t.strictEqual(e.hasState(s.ORPHAN),!0),a.fileService.notExistsSet.delete(n),await e.resolve({forceReadFromFile:!0}),t.strictEqual(e.hasState(s.ORPHAN),!1);try{a.fileService.readShouldThrowError=new f("file not found",p.FILE_NOT_FOUND),await e.resolve(),t.strictEqual(e.hasState(s.ORPHAN),!0)}finally{a.fileService.readShouldThrowError=void 0}})),test("stat.readonly and stat.locked can change when decreased mtime is ignored",async function(){await e.resolve();const r=j(k(e));try{a.fileService.readShouldThrowError=new R("error",{...r,mtime:r.mtime-1,readonly:!r.readonly,locked:!r.locked}),await e.resolve()}finally{a.fileService.readShouldThrowError=void 0}t.strictEqual(k(e)?.mtime,r.mtime,"mtime should not decrease"),t.notStrictEqual(k(e)?.readonly,r.readonly,"readonly should have changed despite simultaneous attempt to decrease mtime"),t.notStrictEqual(k(e)?.locked,r.locked,"locked should have changed despite simultaneous attempt to decrease mtime")}),test("resolve (FILE_NOT_MODIFIED_SINCE can be handled for resolved working copies)",async()=>{await e.resolve();try{a.fileService.readShouldThrowError=new f("file not modified since",p.FILE_NOT_MODIFIED_SINCE),await e.resolve()}finally{a.fileService.readShouldThrowError=void 0}t.strictEqual(e.model?.contents,"Hello Html")}),test("resolve (FILE_NOT_MODIFIED_SINCE still updates readonly state)",async()=>{let r=0;o.add(e.onDidChangeReadonly(()=>r++)),await e.resolve(),t.strictEqual(e.isReadonly(),!1);const i=await a.fileService.resolve(e.resource,{resolveMetadata:!0});try{a.fileService.readShouldThrowError=new R("file not modified since",{...i,readonly:!0}),await e.resolve()}finally{a.fileService.readShouldThrowError=void 0}t.strictEqual(!!e.isReadonly(),!0),t.strictEqual(r,1);try{a.fileService.readShouldThrowError=new R("file not modified since",{...i,readonly:!1}),await e.resolve()}finally{a.fileService.readShouldThrowError=void 0}t.strictEqual(e.isReadonly(),!1),t.strictEqual(r,2)}),test("resolve does not alter content when model content changed in parallel",async()=>{await e.resolve();const r=e.resolve();e.model?.updateContents("changed content"),await r,t.strictEqual(e.isDirty(),!0),t.strictEqual(e.model?.contents,"changed content")}),test("backup",async()=>{await e.resolve(),e.model?.updateContents("hello backup");const r=await e.backup(D.None);t.ok(r.meta);let i;r.content instanceof S?i=r.content.toString():X(r.content)?i=(await Y(r.content,l=>S.concat(l))).toString():r.content&&(i=G(r.content,l=>S.concat(l)).toString()),t.strictEqual(i,"hello backup")}),test("save (no errors) - simple",async()=>{let r=0,i;o.add(e.onDidSave(u=>{r++,i=u}));let l=0;o.add(e.onDidSaveError(()=>{l++})),await e.save(),t.strictEqual(r,0),t.strictEqual(l,0),await e.resolve(),e.model?.updateContents("hello save"),await e.save(),t.strictEqual(r,1),t.strictEqual(l,0),t.strictEqual(e.isDirty(),!1),t.strictEqual(i.reason,v.EXPLICIT),t.ok(i.stat),t.ok(F(i)),t.strictEqual(e.model?.pushedStackElement,!0)}),test("save (no errors) - save reason",async()=>{let r=0,i;o.add(e.onDidSave(y=>{r++,i=y}));let l=0;o.add(e.onDidSaveError(()=>{l++})),await e.resolve(),e.model?.updateContents("hello save");const u=B.registerSource("testSource","Hello Save");await e.save({reason:v.AUTO,source:u}),t.strictEqual(r,1),t.strictEqual(l,0),t.strictEqual(e.isDirty(),!1),t.strictEqual(i.reason,v.AUTO),t.strictEqual(i.source,u)}),test("save (no errors) - multiple",async()=>{let r=0;o.add(e.onDidSave(l=>{r++}));let i=0;o.add(e.onDidSaveError(()=>{i++})),await e.resolve(),e.model?.updateContents("hello save"),await A.settled([e.save({reason:v.AUTO}),e.save({reason:v.EXPLICIT}),e.save({reason:v.WINDOW_CHANGE})]),t.strictEqual(r,1),t.strictEqual(i,0),t.strictEqual(e.isDirty(),!1)}),test("save (no errors) - multiple, cancellation",async()=>{let r=0;o.add(e.onDidSave(y=>{r++}));let i=0;o.add(e.onDidSaveError(()=>{i++})),await e.resolve(),e.model?.updateContents("hello save");const l=e.save();e.model?.updateContents("hello save more");const u=e.save();await A.settled([l,u]),t.strictEqual(r,1),t.strictEqual(i,0),t.strictEqual(e.isDirty(),!1)}),test("save (no errors) - not forced but not dirty",async()=>{let r=0;o.add(e.onDidSave(l=>{r++}));let i=0;o.add(e.onDidSaveError(()=>{i++})),await e.resolve(),await e.save(),t.strictEqual(r,0),t.strictEqual(i,0),t.strictEqual(e.isDirty(),!1)}),test("save (no errors) - forced but not dirty",async()=>{let r=0;o.add(e.onDidSave(l=>{r++}));let i=0;o.add(e.onDidSaveError(()=>{i++})),await e.resolve(),await e.save({force:!0}),t.strictEqual(r,1),t.strictEqual(i,0),t.strictEqual(e.isDirty(),!1)}),test("save (no errors) - save clears orphaned",async()=>I({},async()=>{let r=0;o.add(e.onDidSave(u=>{r++}));let i=0;o.add(e.onDidSaveError(()=>{i++})),await e.resolve();const l=C.toPromise(e.onDidChangeOrphaned);a.fileService.notExistsSet.set(n,!0),a.fileService.fireFileChanges(new q([{resource:n,type:m.DELETED}],!1)),await l,t.strictEqual(e.hasState(s.ORPHAN),!0),await e.save({force:!0}),t.strictEqual(r,1),t.strictEqual(i,0),t.strictEqual(e.isDirty(),!1),t.strictEqual(e.hasState(s.ORPHAN),!1)})),test("save (errors)",async()=>{let r=0;o.add(e.onDidSave(l=>{r++}));let i=0;o.add(e.onDidSaveError(()=>{i++})),await e.resolve();try{a.fileService.writeShouldThrowError=new f("write error",p.FILE_PERMISSION_DENIED),await e.save({force:!0})}finally{a.fileService.writeShouldThrowError=void 0}t.strictEqual(r,0),t.strictEqual(i,1),t.strictEqual(e.hasState(s.ERROR),!0),t.strictEqual(e.hasState(s.SAVED),!1),t.strictEqual(e.hasState(s.PENDING_SAVE),!1),t.strictEqual(e.hasState(s.CONFLICT),!1),t.strictEqual(e.isDirty(),!0),await e.save({reason:v.AUTO}),t.strictEqual(r,0),t.strictEqual(i,1),t.strictEqual(e.hasState(s.ERROR),!0),t.strictEqual(e.hasState(s.SAVED),!1),t.strictEqual(e.hasState(s.PENDING_SAVE),!1),t.strictEqual(e.hasState(s.CONFLICT),!1),t.strictEqual(e.isDirty(),!0),await e.save({reason:v.EXPLICIT}),t.strictEqual(r,1),t.strictEqual(i,1),t.strictEqual(e.hasState(s.ERROR),!1),t.strictEqual(e.hasState(s.SAVED),!0),t.strictEqual(e.hasState(s.PENDING_SAVE),!1),t.strictEqual(e.hasState(s.CONFLICT),!1),t.strictEqual(e.isDirty(),!1);try{a.fileService.writeShouldThrowError=new f("write error conflict",p.FILE_MODIFIED_SINCE),await e.save({force:!0})}catch{}finally{a.fileService.writeShouldThrowError=void 0}t.strictEqual(r,1),t.strictEqual(i,2),t.strictEqual(e.hasState(s.ERROR),!0),t.strictEqual(e.hasState(s.SAVED),!1),t.strictEqual(e.hasState(s.PENDING_SAVE),!1),t.strictEqual(e.hasState(s.CONFLICT),!0),t.strictEqual(e.isDirty(),!0),await e.save({reason:v.EXPLICIT}),t.strictEqual(r,2),t.strictEqual(i,2),t.strictEqual(e.hasState(s.ERROR),!1),t.strictEqual(e.hasState(s.SAVED),!0),t.strictEqual(e.hasState(s.PENDING_SAVE),!1),t.strictEqual(e.hasState(s.CONFLICT),!1),t.strictEqual(e.isDirty(),!1)}),test("save (errors, bubbles up with `ignoreErrorHandler`)",async()=>{await e.resolve();let r;try{a.fileService.writeShouldThrowError=new f("write error",p.FILE_PERMISSION_DENIED),await e.save({force:!0,ignoreErrorHandler:!0})}catch(i){r=i}finally{a.fileService.writeShouldThrowError=void 0}t.ok(r)}),test("save - returns false when save fails",async function(){await e.resolve();try{a.fileService.writeShouldThrowError=new f("write error",p.FILE_PERMISSION_DENIED);const i=await e.save({force:!0});t.strictEqual(i,!1)}finally{a.fileService.writeShouldThrowError=void 0}const r=await e.save({force:!0});t.strictEqual(r,!0)}),test("save participant",async()=>{await e.resolve(),t.strictEqual(a.workingCopyFileService.hasSaveParticipants,!1);let r=0;const i=a.workingCopyFileService.addSaveParticipant({participate:async l=>{e===l&&r++}});t.strictEqual(a.workingCopyFileService.hasSaveParticipants,!0),await e.save({force:!0}),t.strictEqual(r,1),await e.save({force:!0,skipSaveParticipants:!0}),t.strictEqual(r,1),i.dispose(),t.strictEqual(a.workingCopyFileService.hasSaveParticipants,!1),await e.save({force:!0}),t.strictEqual(r,1)}),test("Save Participant, calling save from within is unsupported but does not explode (sync save)",async function(){await e.resolve(),await E(e,!1)}),test("Save Participant, calling save from within is unsupported but does not explode (async save)",async function(){await e.resolve(),await E(e,!0)});async function E(r,i){const l=g.file("testFrom");t.strictEqual(a.workingCopyFileService.hasSaveParticipants,!1);const u=a.workingCopyFileService.addSaveParticipant({participate:async(y,W)=>{i&&await U(10),await r.save({force:!0})}});t.strictEqual(a.workingCopyFileService.hasSaveParticipants,!0),await r.save({force:!0,from:l}),u.dispose()}test("Save Participant carries context",async function(){await e.resolve();const r=g.file("testFrom");t.strictEqual(a.workingCopyFileService.hasSaveParticipants,!1);let i;const l=a.workingCopyFileService.addSaveParticipant({participate:async(u,y)=>{try{t.strictEqual(y.reason,v.EXPLICIT),t.strictEqual(y.savedFrom?.toString(),r.toString())}catch(W){i=W}}});if(t.strictEqual(a.workingCopyFileService.hasSaveParticipants,!0),await e.save({force:!0,from:r}),i)throw i;l.dispose()}),test("revert",async()=>{await e.resolve(),e.model?.updateContents("hello revert");let r=0;o.add(e.onDidRevert(()=>{r++})),await e.revert({soft:!0}),t.strictEqual(r,1),t.strictEqual(e.isDirty(),!1),t.strictEqual(e.model?.contents,"hello revert"),await e.revert(),t.strictEqual(r,1),t.strictEqual(e.model?.contents,"hello revert"),await e.revert({force:!0}),t.strictEqual(r,2),t.strictEqual(e.model?.contents,"Hello Html");try{e.model?.updateContents("hello revert"),a.fileService.readShouldThrowError=new f("error",p.FILE_PERMISSION_DENIED),await e.revert({force:!0})}catch{}finally{a.fileService.readShouldThrowError=void 0}t.strictEqual(r,2),t.strictEqual(e.isDirty(),!0);try{e.model?.updateContents("hello revert"),a.fileService.readShouldThrowError=new f("error",p.FILE_NOT_FOUND),await e.revert({force:!0})}catch{}finally{a.fileService.readShouldThrowError=void 0}t.strictEqual(r,3),t.strictEqual(e.isDirty(),!1)}),test("state",async()=>{t.strictEqual(e.hasState(s.SAVED),!0),await e.resolve({contents:w(S.fromString("hello state"))}),t.strictEqual(e.hasState(s.DIRTY),!0);const r=e.save();t.strictEqual(e.hasState(s.DIRTY),!0),t.strictEqual(e.hasState(s.SAVED),!1),t.strictEqual(e.hasState(s.PENDING_SAVE),!0),await r,t.strictEqual(e.hasState(s.DIRTY),!1),t.strictEqual(e.hasState(s.SAVED),!0),t.strictEqual(e.hasState(s.PENDING_SAVE),!1)}),test("joinState",async()=>{await e.resolve({contents:w(S.fromString("hello state"))}),e.save(),t.strictEqual(e.hasState(s.PENDING_SAVE),!0),await e.joinState(s.PENDING_SAVE),t.strictEqual(e.hasState(s.DIRTY),!1),t.strictEqual(e.hasState(s.SAVED),!0),t.strictEqual(e.hasState(s.PENDING_SAVE),!1)}),test("isReadonly, isResolved, dispose, isDisposed",async()=>{t.strictEqual(e.isResolved(),!1),t.strictEqual(e.isReadonly(),!1),t.strictEqual(e.isDisposed(),!1),await e.resolve(),t.ok(e.model),t.strictEqual(e.isResolved(),!0),t.strictEqual(e.isReadonly(),!1),t.strictEqual(e.isDisposed(),!1);let r=!1;o.add(e.onWillDispose(()=>{r=!0}));let i=!1;o.add(e.model.onWillDispose(()=>{i=!0})),e.dispose(),t.strictEqual(e.isDisposed(),!0),t.strictEqual(r,!0),t.strictEqual(i,!0)}),test("readonly change event",async()=>{a.fileService.readonly=!0,await e.resolve(),t.strictEqual(!!e.isReadonly(),!0),a.fileService.readonly=!1;let r=!1;o.add(e.onDidChangeReadonly(()=>{r=!0})),await e.resolve(),t.strictEqual(e.isReadonly(),!1),t.strictEqual(r,!0)}),L()});export{V as TestStoredFileWorkingCopyModel,J as TestStoredFileWorkingCopyModelFactory,z as TestStoredFileWorkingCopyModelWithCustomSave,K as TestStoredFileWorkingCopyModelWithCustomSaveFactory};
