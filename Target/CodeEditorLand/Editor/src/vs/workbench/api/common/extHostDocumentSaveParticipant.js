import"../../../base/common/event.js";import{URI as h}from"../../../base/common/uri.js";import{illegalState as E}from"../../../base/common/errors.js";import"./extHost.protocol.js";import{TextEdit as y}from"./extHostTypes.js";import{Range as x,TextDocumentSaveReason as S,EndOfLine as _}from"./extHostTypeConverters.js";import"./extHostDocuments.js";import"../../common/editor.js";import{LinkedList as T}from"../../../base/common/linkedList.js";import"../../../platform/log/common/log.js";import"../../../platform/extensions/common/extensions.js";import{SerializableObjectWithBuffers as b}from"../../services/extensions/common/proxyIdentifier.js";class q{constructor(e,s,o,i={timeout:1500,errors:3}){this._logService=e;this._documents=s;this._mainThreadBulkEdits=o;this._thresholds=i}_callbacks=new T;_badListeners=new WeakMap;dispose(){this._callbacks.clear()}getOnWillSaveTextDocumentEvent(e){return(s,o,i)=>{const t={dispose:this._callbacks.push([s,o,e])};return Array.isArray(i)&&i.push(t),t}}async $participateInSave(e,s){const o=h.revive(e);let i=!1;const n=setTimeout(()=>i=!0,this._thresholds.timeout),t=[];try{for(const r of[...this._callbacks]){if(i)break;const d=this._documents.getDocument(o),u=await this._deliverEventAsyncAndBlameBadListeners(r,{document:d,reason:S.to(s)});t.push(u)}}finally{clearTimeout(n)}return t}_deliverEventAsyncAndBlameBadListeners([e,s,o],i){const n=this._badListeners.get(e);return typeof n=="number"&&n>this._thresholds.errors?Promise.resolve(!1):this._deliverEventAsync(o,e,s,i).then(()=>!0,t=>{if(this._logService.error(`onWillSaveTextDocument-listener from extension '${o.identifier.value}' threw ERROR`),this._logService.error(t),!(t instanceof Error)||t.message!=="concurrent_edits"){const r=this._badListeners.get(e);this._badListeners.set(e,r?r+1:1),typeof r=="number"&&r>this._thresholds.errors&&this._logService.info(`onWillSaveTextDocument-listener from extension '${o.identifier.value}' will now be IGNORED because of timeouts and/or errors`)}return!1})}_deliverEventAsync(e,s,o,i){const n=[],t=Date.now(),{document:r,reason:d}=i,{version:u}=r,f=Object.freeze({document:r,reason:d,waitUntil(a){if(Object.isFrozen(n))throw E("waitUntil can not be called async");n.push(Promise.resolve(a))}});try{s.apply(o,[f])}catch(a){return Promise.reject(a)}return Object.freeze(n),new Promise((a,l)=>{const m=setTimeout(()=>l(new Error("timeout")),this._thresholds.timeout);return Promise.all(n).then(c=>{this._logService.debug(`onWillSaveTextDocument-listener from extension '${e.identifier.value}' finished after ${Date.now()-t}ms`),clearTimeout(m),a(c)}).catch(c=>{clearTimeout(m),l(c)})}).then(a=>{const l={edits:[]};for(const m of a)if(Array.isArray(m)&&m.every(c=>c instanceof y))for(const{newText:c,newEol:v,range:p}of m)l.edits.push({resource:r.uri,versionId:void 0,textEdit:{range:p&&x.from(p),text:c,eol:v&&_.from(v)}});if(l.edits.length!==0)return u===r.version?this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(new b(l)):Promise.reject(new Error("concurrent_edits"))})}}export{q as ExtHostDocumentSaveParticipant};
