import{isThenable as c}from"../../../../base/common/async.js";import{CharCode as d}from"../../../../base/common/charCode.js";import"../../common/extHostRpcService.js";import"../../../services/extensions/common/extHostCustomers.js";import{ExtensionHostKind as a}from"../../../services/extensions/common/extensionHostKind.js";import{SerializableObjectWithBuffers as f}from"../../../services/extensions/common/proxyIdentifier.js";import{parseJsonAndRestoreBufferRefs as p,stringifyJsonWithBufferRefs as y}from"../../../services/extensions/common/rpcProtocol.js";function m(r){return{_serviceBrand:void 0,remoteAuthority:null,getProxy(){return r},set(e,t){return t},dispose:void 0,assertRegistered:void 0,drain:void 0,extensionHostKind:a.LocalProcess}}function E(r){return m(new Proxy({},{get(e,t){return r&&t in r?r[t]:()=>Promise.resolve(void 0)}}))}class H{_serviceBrand;remoteAuthority=null;extensionHostKind=a.LocalProcess;_callCountValue=0;_idle;_completeIdle;_locals;_proxies;constructor(){this._locals=Object.create(null),this._proxies=Object.create(null)}drain(){return Promise.resolve()}get _callCount(){return this._callCountValue}set _callCount(e){this._callCountValue=e,this._callCountValue===0&&(this._completeIdle?.(),this._idle=void 0)}sync(){return new Promise(e=>{setTimeout(e,0)}).then(()=>{if(this._callCount!==0)return this._idle||(this._idle=new Promise((e,t)=>{this._completeIdle=e})),this._idle})}getProxy(e){return this._proxies[e.sid]||(this._proxies[e.sid]=this._createProxy(e.sid)),this._proxies[e.sid]}_createProxy(e){const t={get:(o,i)=>(typeof i=="string"&&!o[i]&&i.charCodeAt(0)===d.DollarSign&&(o[i]=(...s)=>this._remoteCall(e,i,s)),o[i])};return new Proxy(Object.create(null),t)}set(e,t){return this._locals[e.sid]=t,t}_remoteCall(e,t,o){return this._callCount++,new Promise(i=>{setTimeout(i,0)}).then(()=>{const i=this._locals[e],s=u(o);let l;try{const n=i[t].apply(i,s);l=c(n)?n:Promise.resolve(n)}catch(n){l=Promise.reject(n)}return l.then(n=>(this._callCount--,u(n)),n=>(this._callCount--,Promise.reject(n)))})}dispose(){throw new Error("Not implemented!")}assertRegistered(e){throw new Error("Not implemented!")}}function u(r){if(!r)return r;if(Array.isArray(r))return r.map(u);if(r instanceof f){const{jsonString:e,referencedBuffers:t}=y(r);return p(e,t,null)}else return JSON.parse(JSON.stringify(r))}export{E as AnyCallRPCProtocol,m as SingleProxyRPCProtocol,H as TestRPCProtocol};
